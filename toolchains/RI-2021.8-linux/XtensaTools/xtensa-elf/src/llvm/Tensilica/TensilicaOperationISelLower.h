//===-- TensilicaOperationISelLower.h - Tensilica DAG Lowering Interface --===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file defines the interfaces that Tensilica uses to lower ISD operations 
// into a sequence of a target intrinsic nodes.
//
//===----------------------------------------------------------------------===//

#ifndef LLVM_LIB_CODEGEN_TENSILICA_TENSILICAOPERATIONISELLOWER_H
#define LLVM_LIB_CODEGEN_TENSILICA_TENSILICAOPERATIONISELLOWER_H

#include "llvm/CodeGen/SelectionDAG.h"
#include "llvm/Support/KnownBits.h"
#include "Tensilica/TensilicaSubtargetInfo.h"

#define TENSILICA_OP_ISEL_LAST_INTRN true
#define TENSILICA_OP_ISEL_HAS_CHAIN true
#define TENSILICA_OP_ISEL_ISD_OPCODE true
#define TENSILICA_OP_ISEL_ENABLE true

#define TENSILICA_OP_ISEL_USE_OPND(x) x
#define TENSILICA_OP_ISEL_DEF_OPND(x) x

#define TENSILICA_OP_ISEL_INTRN_OPND(x) ((x << 8) & 0xff00)
#define TENSILICA_OP_ISEL_INTRN(x) (x & 0xff)

#define TENSILICA_OP_ISEL_MAX_INPUTS (12)

namespace llvm {
namespace Tensilica {

// Enum to generate the operands of the target intrinsic
enum OpISelOperandType {
  // The input to the intrinsic is from the original operation
  TENSILICA_OP_ISEL_OPND = 0x1,
  // The input is a immediate
  TENSILICA_OP_ISEL_IMM = 0x2,
  // The input is a temporary generated by a previous intrinsic in the
  // expanded sequence
  TENSILICA_OP_ISEL_TMP = 0x4
};

struct OpISelInfo;

// Call back to check if lowering can be done on Op with result VT
typedef bool (*OpPredicateFunc)(SelectionDAG &DAG, SDValue Op, MVT VT,
                                OpISelInfo *ISelInfo);

// An external function handler to do the lowering
typedef SDNode *(*LowerOpFunc)(SDValue Op, SelectionDAG &DAG);

// An external function handler to match the imm shuffle mask of vsel
// intrinsics
typedef bool (*VSelImmMatchFunc)(ArrayRef<int> ShuffleMask,
                                 bool IsOpnd1Undef, int &PatternIdx);

// Struct to represent the intrinsic operand and its mapping to the
// input operation operand
struct OpISelOperandInfo {
  OpISelOperandType OpndType;
  union {
    // Index of the operation operand if the input is the operation operand
    unsigned OpOpndIdx;
    // The constant offset used in case of an constant immediate
    int Imm;
    // Index of the last intrinsic in the expanded operation sequence that
    // generated this temporary
    unsigned TmpDefIdx;
  } Value;
};

struct OpISelInfo {
  // ISD opcode + extra information (eg: selectcc/setcc condition code)
  // The ISD opcode is stored in the upper 24-bits, while the extra
  // information is in the lower 8-bits
  unsigned Id;
  // Call-back to check if lowering can be done
  OpPredicateFunc PredFunc;
  // MVT of the operation
  MVT VT;
  // Use an external function to perform the lowering
  LowerOpFunc LowerOp;
  // Intrinsic id or the ISD opcode (if ISDOpcode is true)
  unsigned Opcode;
  // Inputs
  unsigned NumInputs;
  OpISelOperandInfo InOpndInfos[TENSILICA_OP_ISEL_MAX_INPUTS];
  MVT ResultMVT;
  // An intrinsic or another ISD opcode
  bool ISDOpcode;
  // If PredFunc does not match this, use the increment to skip the sequence
  unsigned Increment;
  bool HasChain;
  // Is this the last intrinsic in the expanded operation sequence
  bool LastIntrn;
  // If Memory, size in bytes, and offset
  bool IsMemOp;
  int Size;
  int Offset;

  bool operator<(const OpISelInfo &RHS) const { return Id < RHS.Id; }

  bool operator==(const OpISelInfo &RHS) const { return RHS.Id == Id; }

  static bool always_match(SelectionDAG &DAG, SDValue Op, MVT VT,
                           OpISelInfo *ISelInfo) {
    return true;
  }

  static bool never_match(SelectionDAG &DAG, SDValue Op, MVT VT,
                          OpISelInfo *ISelInfo) {
    return false;
  }

  static bool check_smul16(SelectionDAG &DAG, SDValue Op, MVT VT,
                           OpISelInfo *ISelInfo) {
    if (DAG.getTarget().getOptLevel() < CodeGenOpt::Default)
      return false;

    if (Op.getValueType() != MVT::i32)
      return false;

    const SubtargetInfo &Subtarget =
        static_cast<const SubtargetInfo &>(DAG.getSubtarget());

    if (!Subtarget.coproc() || Subtarget.hasMul16())
      return false;

    if (DAG.ComputeNumSignBits(Op.getOperand(0)) >= 17 &&
        DAG.ComputeNumSignBits(Op.getOperand(1)) >= 17)
      return true;

    return false;
  }

  static bool check_umul16(SelectionDAG &DAG, SDValue Op, MVT VT,
                           OpISelInfo *ISelInfo) {
    if (DAG.getTarget().getOptLevel() < CodeGenOpt::Default)
      return false;

    if (Op.getValueType() != MVT::i32)
      return false;

    const SubtargetInfo &Subtarget =
        static_cast<const SubtargetInfo &>(DAG.getSubtarget());

    if (!Subtarget.coproc() || Subtarget.hasMul16())
      return false;

    APInt Mask = APInt::getHighBitsSet(32, 16);
    if ((DAG.computeKnownBits(Op.getOperand(0)).Zero & Mask) == Mask &&
        (DAG.computeKnownBits(Op.getOperand(1)).Zero & Mask) == Mask)
      return true;

    return false;
  }

  static bool match_type_with_coproc(SelectionDAG &DAG, SDValue Op, MVT VT,
                                     OpISelInfo *ISelInfo) {
    const SubtargetInfo &Subtarget =
        static_cast<const SubtargetInfo &>(DAG.getSubtarget());
    if (!Subtarget.coproc())
      return false;
    return match_type(DAG, Op, VT, ISelInfo);
  }

  static bool match_type(SelectionDAG &DAG, SDValue Op, MVT VT,
                         OpISelInfo *ISelInfo) {
    if (Op.getValueType() == MVT::Other)
      return Op.getOperand(1).getValueType() == VT;
    return Op.getValueType() == VT;
  }

  static bool match_type_and_vec_bool_cond(SelectionDAG &DAG, SDValue Op,
                                           MVT VT, OpISelInfo *ISelInfo) {
    EVT EltVT = Op.getOperand(0).getValueType().getVectorElementType();
    if (EltVT != MVT::i1)
      return false;
    return Op.getValueType() == VT;
  }

  static bool match_struct_ctype_memop(SelectionDAG &DAG, SDValue Op, MVT VT,
                                       OpISelInfo *ISelInfo) {
    MemSDNode *N = cast<MemSDNode>(Op.getNode());
    if (N->getMemoryVT() != VT)
      return false;
    Type *Ty = N->getMemoryVT().getTypeForEVT(*DAG.getContext());
    if (N->getAlignment() < DAG.getDataLayout().getABITypeAlignment(Ty))
      return false;
    return match_type(DAG, Op, VT, ISelInfo);
  }

  static bool match_v1_extract_vector_elt(SelectionDAG &DAG, SDValue Op, MVT VT,
                                          OpISelInfo *ISelInfo) {
    if (Op.getOperand(0).getValueType() == VT &&
        Op.getValueType() == ISelInfo->ResultMVT) {
      ConstantSDNode *Const = dyn_cast<ConstantSDNode>(Op.getOperand(1));
      if (!Const || Const->getZExtValue() != 0)
        return false;
      return true;
    }
    return false;
  }

  static bool match_struct_ctype_memop_unaligned(SelectionDAG &DAG, SDValue Op,
                                                 MVT VT,
                                                 OpISelInfo *ISelInfo) {
    MemSDNode *N = cast<MemSDNode>(Op.getNode());
    if (N->getMemoryVT() != VT)
      return false;
    return match_type(DAG, Op, VT, ISelInfo);
  }

  static bool match_src_dst_type(SelectionDAG &DAG, SDValue Op, MVT VT,
                                 OpISelInfo *ISelInfo) {
    return Op.getValueType() == ISelInfo->ResultMVT &&
           Op.getOperand(0).getValueType() == VT;
  }

  static bool check_concat_two_vectors(SelectionDAG &DAG, SDValue Op, MVT VT,
                                       OpISelInfo *ISelInfo) {
    return Op.getNumOperands() == 2 &&
           Op.getValueType() == ISelInfo->ResultMVT &&
           Op.getOperand(0).getValueType() == VT;
  }

  static bool check_extract_subvector_lo_half(SelectionDAG &DAG, SDValue Op,
                                              MVT VT,
                                              OpISelInfo *ISelInfo) {
    SDValue Vec = Op.getOperand(0);

    if (Op.getValueType() != ISelInfo->ResultMVT || Vec.getValueType() != VT)
      return false;

    SDValue Idx = Op.getOperand(1);

    if (!isa<ConstantSDNode>(Idx) ||
        cast<ConstantSDNode>(Idx)->getZExtValue() != 0)
      return false;
    return true;
  }

  static bool check_extract_subvector_up_half(SelectionDAG &DAG, SDValue Op,
                                              MVT VT,
                                              OpISelInfo *ISelInfo) {
    SDValue Vec = Op.getOperand(0);

    if (Op.getValueType() != ISelInfo->ResultMVT || Vec.getValueType() != VT)
      return false;

    SDValue Idx = Op.getOperand(1);

    MVT DestVecVT = Op.getSimpleValueType();
    unsigned DestNumElems = DestVecVT.getVectorNumElements();

    if (!isa<ConstantSDNode>(Idx) ||
        cast<ConstantSDNode>(Idx)->getZExtValue() != DestNumElems)
      return false;
    return true;
  }

  static bool check_vector_fp_to_int(SelectionDAG &DAG, SDValue Op, MVT VT,
                                     OpISelInfo *ISelInfo) {
    return Op.getValueType() == ISelInfo->ResultMVT &&
           Op.getOperand(0).getValueType() == VT;
  }

  static bool check_fp_to_int(SelectionDAG &DAG, SDValue Op, MVT VT,
                              OpISelInfo *ISelInfo) {
    SDValue Opnd = Op.getOperand(0);
    return Opnd.getValueType() == VT;
  }

  static bool check_set_cc(SelectionDAG &DAG, SDValue Op, MVT VT,
                           OpISelInfo *ISelInfo) {
    SDValue LHS = Op.getOperand(0);
    return LHS.getValueType() == VT;
  }

  static bool check_select_fp_min(SelectionDAG &DAG, SDValue Op, MVT VT,
                                  OpISelInfo *ISelInfo) {
    SDValue LHS = Op.getOperand(0);
    SDValue RHS = Op.getOperand(1);
    SDValue TrueValue = Op.getOperand(2);
    SDValue FalseValue = Op.getOperand(3);
    bool fp_cmp_res =
        LHS.getValueType() == VT && TrueValue.getValueType() == VT;
    ISD::CondCode CC = cast<CondCodeSDNode>(Op.getOperand(4))->get();
    if (fp_cmp_res && CC == ISD::SETOLT && DAG.isEqualTo(LHS, TrueValue) &&
        DAG.isEqualTo(RHS, FalseValue))
      return true;
    return false;
  }

  static bool check_vector_reduction(SelectionDAG &DAG, SDValue Op, MVT VT,
                                     OpISelInfo *ISelInfo) {
    // Check the vector type and result type
    if (Op.getOperand(0)->getSimpleValueType(0) == VT &&
        Op.getSimpleValueType() == ISelInfo->ResultMVT)
      return true;
    return false;
  }

  static bool check_select_fp_min_swap(SelectionDAG &DAG, SDValue Op, MVT VT,
                                       OpISelInfo *ISelInfo) {
    SDValue LHS = Op.getOperand(0);
    SDValue RHS = Op.getOperand(1);
    SDValue TrueValue = Op.getOperand(2);
    SDValue FalseValue = Op.getOperand(3);
    bool fp_cmp_res =
        LHS.getValueType() == VT && TrueValue.getValueType() == VT;
    ISD::CondCode CC = cast<CondCodeSDNode>(Op.getOperand(4))->get();
    if (fp_cmp_res && CC == ISD::SETOLT && DAG.isEqualTo(LHS, FalseValue) &&
        DAG.isEqualTo(RHS, TrueValue))
      return true;
    return false;
  }

  static bool check_select_fp_max(SelectionDAG &DAG, SDValue Op, MVT VT,
                                  OpISelInfo *ISelInfo) {
    SDValue LHS = Op.getOperand(0);
    SDValue RHS = Op.getOperand(1);
    SDValue TrueValue = Op.getOperand(2);
    SDValue FalseValue = Op.getOperand(3);
    bool fp_cmp_res =
        LHS.getValueType() == VT && TrueValue.getValueType() == VT;
    ISD::CondCode CC = cast<CondCodeSDNode>(Op.getOperand(4))->get();
    if (fp_cmp_res && CC == ISD::SETOGT && DAG.isEqualTo(LHS, TrueValue) &&
        DAG.isEqualTo(RHS, FalseValue))
      return true;
    return false;
  }

  static bool check_select_fp_max_swap(SelectionDAG &DAG, SDValue Op, MVT VT,
                                       OpISelInfo *ISelInfo) {
    SDValue LHS = Op.getOperand(0);
    SDValue RHS = Op.getOperand(1);
    SDValue TrueValue = Op.getOperand(2);
    SDValue FalseValue = Op.getOperand(3);
    bool fp_cmp_res =
        LHS.getValueType() == VT && TrueValue.getValueType() == VT;
    ISD::CondCode CC = cast<CondCodeSDNode>(Op.getOperand(4))->get();
    if (fp_cmp_res && CC == ISD::SETOGT && DAG.isEqualTo(LHS, FalseValue) &&
        DAG.isEqualTo(RHS, TrueValue))
      return true;
    return false;
  }

  static bool check_select_fp_cc(SelectionDAG &DAG, SDValue Op, MVT VT,
                                 OpISelInfo *ISelInfo) {
    SDValue LHS = Op.getOperand(0);
    SDValue TrueValue = Op.getOperand(2);
    return LHS.getValueType() == MVT::f32 && TrueValue.getValueType() == VT;
  }

  static bool check_select_dp_cc(SelectionDAG &DAG, SDValue Op, MVT VT,
                                 OpISelInfo *ISelInfo) {
    SDValue LHS = Op.getOperand(0);
    SDValue TrueValue = Op.getOperand(2);
    return LHS.getValueType() == MVT::f64 && TrueValue.getValueType() == VT;
  }

  static bool check_select_hp_cc(SelectionDAG &DAG, SDValue Op, MVT VT,
                                 OpISelInfo *ISelInfo) {
    SDValue LHS = Op.getOperand(0);
    SDValue TrueValue = Op.getOperand(2);
    return LHS.getValueType() == MVT::f16 && TrueValue.getValueType() == VT;
  }

  static bool check_select_int_cc(SelectionDAG &DAG, SDValue Op, MVT VT,
                                  OpISelInfo *ISelInfo) {
    SDValue LHS = Op.getOperand(0);
    SDValue TrueValue = Op.getOperand(2);
    return LHS.getValueType() == MVT::i32 && TrueValue.getValueType() == VT;
  }

  static bool check_const_h_0_0(SelectionDAG &DAG, SDValue Op, MVT VT,
                                OpISelInfo *ISelInfo) {
    return VT == MVT::f16 &&
           cast<ConstantFPSDNode>(Op)->getValueAPF().bitwiseIsEqual(
               APFloat(APFloat::IEEEhalf(), "0.0"));
  }

  static bool check_const_h_1_0(SelectionDAG &DAG, SDValue Op, MVT VT,
                                OpISelInfo *ISelInfo) {
    return VT == MVT::f16 &&
           cast<ConstantFPSDNode>(Op)->getValueAPF().bitwiseIsEqual(
               APFloat(APFloat::IEEEhalf(), "1.0"));
  }

  static bool check_const_h_2_0(SelectionDAG &DAG, SDValue Op, MVT VT,
                                OpISelInfo *ISelInfo) {
    return VT == MVT::f16 &&
           cast<ConstantFPSDNode>(Op)->getValueAPF().bitwiseIsEqual(
               APFloat(APFloat::IEEEhalf(), "2.0"));
  }

  static bool check_const_h_0_5(SelectionDAG &DAG, SDValue Op, MVT VT,
                                OpISelInfo *ISelInfo) {
    return VT == MVT::f16 &&
           cast<ConstantFPSDNode>(Op)->getValueAPF().bitwiseIsEqual(
               APFloat(APFloat::IEEEhalf(), "0.5"));
  }

  static bool check_const_s_0_0(SelectionDAG &DAG, SDValue Op, MVT VT,
                                OpISelInfo *ISelInfo) {
    return VT == MVT::f32 &&
           cast<ConstantFPSDNode>(Op)->getValueAPF().bitwiseIsEqual(
               APFloat(0.0f));
  }

  static bool check_const_s_1_0(SelectionDAG &DAG, SDValue Op, MVT VT,
                                OpISelInfo *ISelInfo) {
    return VT == MVT::f32 &&
           cast<ConstantFPSDNode>(Op)->getValueAPF().bitwiseIsEqual(
               APFloat(1.0f));
  }

  static bool check_const_s_2_0(SelectionDAG &DAG, SDValue Op, MVT VT,
                                OpISelInfo *ISelInfo) {
    return VT == MVT::f32 &&
           cast<ConstantFPSDNode>(Op)->getValueAPF().bitwiseIsEqual(
               APFloat(2.0f));
  }

  static bool check_const_s_0_5(SelectionDAG &DAG, SDValue Op, MVT VT,
                                OpISelInfo *ISelInfo) {
    return VT == MVT::f32 &&
           cast<ConstantFPSDNode>(Op)->getValueAPF().bitwiseIsEqual(
               APFloat(0.5f));
  }

  static bool check_const_d_0_0(SelectionDAG &DAG, SDValue Op, MVT VT,
                                OpISelInfo *ISelInfo) {
    return VT == MVT::f64 &&
           cast<ConstantFPSDNode>(Op)->getValueAPF().bitwiseIsEqual(
               APFloat(0.0));
  }

  static bool check_const_d_1_0(SelectionDAG &DAG, SDValue Op, MVT VT,
                                OpISelInfo *ISelInfo) {
    return VT == MVT::f64 &&
           cast<ConstantFPSDNode>(Op)->getValueAPF().bitwiseIsEqual(
               APFloat(1.0));
  }

  static bool check_const_d_2_0(SelectionDAG &DAG, SDValue Op, MVT VT,
                                OpISelInfo *ISelInfo) {
    return VT == MVT::f64 &&
           cast<ConstantFPSDNode>(Op)->getValueAPF().bitwiseIsEqual(
               APFloat(2.0));
  }

  static bool check_const_d_0_5(SelectionDAG &DAG, SDValue Op, MVT VT,
                                OpISelInfo *ISelInfo) {
    return VT == MVT::f64 &&
           cast<ConstantFPSDNode>(Op)->getValueAPF().bitwiseIsEqual(
               APFloat(0.5));
  }

  static bool check_bitcast_itof(SelectionDAG &DAG, SDValue Op, MVT VT,
                                 OpISelInfo *ISelInfo) {
    return Op.getValueType() == MVT::f32 &&
           Op.getOperand(0).getValueType() == MVT::i32;
  }

  static bool check_bitcast_ftoi(SelectionDAG &DAG, SDValue Op, MVT VT,
                                 OpISelInfo *ISelInfo) {
    return Op.getValueType() == MVT::i32 &&
           Op.getOperand(0).getValueType() == MVT::f32;
  }

  static bool check_int_vector_madd_msub(SelectionDAG &DAG, SDValue Op, MVT VT,
                                         OpISelInfo *ISelInfo) {
    return Op->getOperand(0).getValueType() == ISelInfo->ResultMVT &&
           Op->getOperand(1).getValueType() == VT &&
           Op->getOperand(1).getValueType() == Op->getOperand(2).getValueType();
  }

  static bool check_build_vector_splat_zero(SelectionDAG &DAG, SDValue Op,
                                            MVT VT,
                                            OpISelInfo *ISelInfo) {
    if (Op.getValueType() != VT)
      return false;

    return ISD::isBuildVectorAllZeros(Op.getNode());
  }

  static bool check_boolean_vector_bnot(SelectionDAG &DAG, SDValue Op, MVT VT,
                                        OpISelInfo *ISelInfo) {
    EVT ResVT = Op.getValueType();
    if (ResVT != VT)
      return false;

    EVT EltVT = ResVT.getVectorElementType();
    if (EltVT != MVT::i1)
      return false;

    SDValue Oprnd0 = Op.getOperand(0);
    SDValue Oprnd1 = Op.getOperand(1);

    BuildVectorSDNode *BVN0 = dyn_cast<BuildVectorSDNode>(Oprnd0.getNode());
    BuildVectorSDNode *BVN1 = dyn_cast<BuildVectorSDNode>(Oprnd1.getNode());

    // Only one of the operands is BuildVectorSDNode.
    if ((!BVN0 && !BVN1) || (BVN0 && BVN0))
      return false;

    BuildVectorSDNode *BVN = BVN0 ? BVN0 : BVN1;
    unsigned Index = BVN == BVN0 ? 1 : 0;

    if (ISD::isBuildVectorAllOnes(BVN)) {
      ISelInfo->InOpndInfos[0].Value.OpOpndIdx = Index;
      return true;
    }
    return false;
  }

  static bool check_build_vector_splat(SelectionDAG &DAG, SDValue Op, MVT VT,
                                       OpISelInfo *ISelInfo) {
    if (Op.getValueType() != VT)
      return false;
    BuildVectorSDNode *BVN = cast<BuildVectorSDNode>(Op.getNode());
    SDValue Splatted;
    unsigned Index = 0;
    for (unsigned i = 0, e = BVN->getNumOperands(); i != e; ++i) {
      SDValue Op = BVN->getOperand(i);
      if (Op.isUndef())
        continue;
      if (!Splatted) {
        Splatted = Op;
        Index = i;
      } else if (Splatted != Op) {
        return false;
      }
    }
    assert(ISelInfo->NumInputs == 1);
    assert(ISelInfo->InOpndInfos[0].OpndType == TENSILICA_OP_ISEL_OPND);
    ISelInfo->InOpndInfos[0].Value.OpOpndIdx = Index;
    return true;
  }

  // Check if the operands of the given BUILD_VECTOR node are all zeros except
  // the first operand
  static bool check_scalar_to_vect_mov(SelectionDAG &DAG, SDValue Op, MVT VT,
                                       OpISelInfo *ISelInfo) {
    SDValue Op0 = Op.getOperand(0);
    // Check if the type of the first operand is the same as the vector element
    // type
    if (Op.getValueType() != VT ||
        Op.getValueType().getVectorElementType() != Op0.getValueType())
      return false;

    // Check if rest of operands are all zeros
    for (unsigned i = 1; i < Op.getNumOperands(); ++i) {
      SDValue Oprnd = Op.getOperand(i);
      EVT VT = Oprnd.getValueType();
      if (VT.isInteger()) {
        ConstantSDNode *CN = dyn_cast<ConstantSDNode>(Oprnd);
        if (!CN || CN->getSExtValue() != 0)
          return false;
      } else if (VT.isFloatingPoint()) {
        ConstantFPSDNode *CN = dyn_cast<ConstantFPSDNode>(Oprnd);
        if (!CN || !CN->isZero())
          return false;
      } else
        return false;
    }
    return true;
  }

  static bool check_vector_shift_with_scalar(SelectionDAG &DAG, SDValue Op,
                                             MVT VT,
                                             OpISelInfo *ISelInfo) {
    if (Op.getValueType() != VT)
      return false;
    BuildVectorSDNode *BVN = dyn_cast<BuildVectorSDNode>(Op->getOperand(1));
    if (!BVN)
      return false;

    SDValue SV = BVN->getSplatValue();
    if (!SV)
      return false;

    if (SV.getValueType() == MVT::i32)
      return true;

    // FIXME: we should also consider splat pattern with 'VECTOR_SHUFFLE'.
    return false;
  }

  static bool check_vector_shift_with_immediate(SelectionDAG &DAG, SDValue Op,
                                                MVT VT,
                                                OpISelInfo *ISelInfo) {
    if (Op.getValueType() != VT)
      return false;
    BuildVectorSDNode *BVN = dyn_cast<BuildVectorSDNode>(Op->getOperand(1));
    if (!BVN)
      return false;

    SDValue SV = BVN->getSplatValue();
    if (!SV)
      return false;

    ConstantSDNode *CN = dyn_cast<ConstantSDNode>(SV);
    if (!CN)
      return false;

    int64_t CV = CN->getSExtValue();
    EVT ResVT = Op.getValueType();
    EVT EltVT = ResVT.getVectorElementType();
    unsigned EltBitSize = EltVT.getSizeInBits();

    // FIXME: We need use imm range info to generate precise condition
    // on the immediate.
    if (CV >= 0 && CV <= EltBitSize) {
      ISelInfo->InOpndInfos[1].Value.Imm = (int)CV;
      return true;
    }

    return false;
  }

  static bool check_vec_sign_ext_i32_inreg(SelectionDAG &DAG, SDValue Op,
                                           MVT VT, OpISelInfo *ISelInfo) {
    EVT LHS_VT = Op.getOperand(0).getValueType();
    EVT RHS_VT = cast<VTSDNode>(Op.getOperand(1))->getVT();
    return RHS_VT == VT && LHS_VT.getVectorElementType() == MVT::i32;
  }

  static bool check_vec_sign_ext_i16_inreg(SelectionDAG &DAG, SDValue Op,
                                           MVT VT, OpISelInfo *ISelInfo) {
    EVT LHS_VT = Op.getOperand(0).getValueType();
    EVT RHS_VT = cast<VTSDNode>(Op.getOperand(1))->getVT();
    return RHS_VT == VT && LHS_VT.getVectorElementType() == MVT::i16;
  }

  static bool check_vec_zsext_bool_to_int(SelectionDAG &DAG, SDValue Op, MVT VT,
                                          OpISelInfo *ISelInfo) {
    EVT LHS_VT = Op.getValueType();
    EVT RHS_VT = Op.getOperand(0).getValueType();
    return RHS_VT.getVectorElementType() == MVT::i1 && LHS_VT == VT &&
           RHS_VT.getVectorNumElements() == LHS_VT.getVectorNumElements();
  }

  static bool check_vec_trunc_int_to_bool(SelectionDAG &DAG, SDValue Op, MVT VT,
                                          OpISelInfo *ISelInfo) {
    EVT LHS_VT = Op.getValueType();
    EVT RHS_VT = Op.getOperand(0).getValueType();
    return LHS_VT.getVectorElementType() == MVT::i1 && RHS_VT == VT &&
           RHS_VT.getVectorNumElements() == LHS_VT.getVectorNumElements();
  }

  static bool check_masked_load_no_pass_thru(SelectionDAG &DAG, SDValue Op,
                                             MVT VT,
                                             OpISelInfo *ISelInfo) {
    const MaskedLoadSDNode *MLD = cast<MaskedLoadSDNode>(Op);
    SDValue PassThru = MLD->getPassThru();
    if (Op.getValueType() != VT)
      return false;
    if (PassThru->isUndef())
      return true;
    BuildVectorSDNode *BVN = dyn_cast<BuildVectorSDNode>(PassThru);
    if (BVN && ISD::isBuildVectorAllZeros(BVN))
      return true;
    return false;
  }

  static bool match_masked_store_type(SelectionDAG &DAG, SDValue Op, MVT VT,
                                      OpISelInfo *ISelInfo) {
    MaskedStoreSDNode *N = cast<MaskedStoreSDNode>(Op.getNode());
    return N->isUnindexed() && N->getValue().getValueType() == VT;
  }

  static bool check_gather(SelectionDAG &DAG, SDValue Op, MVT VT,
                           OpISelInfo *ISelInfo) {
    SDValue Mask = Op.getOperand(2);
    assert(Op.getOperand(3).getOpcode() != ISD::TargetConstant &&
           "Cannot be a constant!");
    if (cast<MemSDNode>(Op.getNode())->getMemoryVT() != VT)
      return false;
    BuildVectorSDNode *BVN = dyn_cast<BuildVectorSDNode>(Mask);
    if (Mask->isUndef() || (BVN && ISD::isBuildVectorAllOnes(BVN)))
      return true;
    return false;
  }

  static bool check_gather_no_pass_thru(SelectionDAG &DAG, SDValue Op, MVT VT,
                                        OpISelInfo *ISelInfo) {
    SDValue PassThru = Op.getOperand(1);
    if (cast<MemSDNode>(Op.getNode())->getMemoryVT() != VT)
      return false;
    if (PassThru->isUndef())
      return true;
    BuildVectorSDNode *BVN = dyn_cast<BuildVectorSDNode>(PassThru);
    if (BVN && ISD::isBuildVectorAllZeros(BVN))
      return true;
    return false;
  }

  static bool check_gather_pass_thru(SelectionDAG &DAG, SDValue Op, MVT VT,
                                     OpISelInfo *ISelInfo) {
    return cast<MemSDNode>(Op.getNode())->getMemoryVT() == VT;
  }

  static bool check_scatter(SelectionDAG &DAG, SDValue Op, MVT VT,
                            OpISelInfo *ISelInfo) {
    if (cast<MemSDNode>(Op.getNode())->getMemoryVT() != VT)
      return false;
    SDValue Mask = Op.getOperand(2);
    BuildVectorSDNode *BVN = dyn_cast<BuildVectorSDNode>(Mask);
    if (Mask->isUndef() || (BVN && ISD::isBuildVectorAllOnes(BVN)))
      return true;
    return false;
  }

  static bool check_pred_scatter(SelectionDAG &DAG, SDValue Op, MVT VT,
                                 OpISelInfo *ISelInfo) {
    return cast<MemSDNode>(Op.getNode())->getMemoryVT() == VT;
  }

  static bool match_bool_extract_type(SelectionDAG &DAG, SDValue Op, MVT VT,
                                      OpISelInfo *ISelInfo) {
    return Op.getOperand(0).getValueType() == VT;
  }

  static bool match_unaligned_xtcomplex_load_store(SelectionDAG &DAG,
                                                   SDValue Op, MVT VT,
                                                   OpISelInfo *ISelInfo) {
    MemSDNode *N = cast<MemSDNode>(Op.getNode());
    if (N->getMemoryVT() != VT)
      return false;
    Type *Ty = N->getMemoryVT().getTypeForEVT(*DAG.getContext());
    return N->getAlignment() < DAG.getDataLayout().getABITypeAlignment(Ty);
  }

  static SDNode *LowerConstantHPToConstant(SDValue Op, SelectionDAG &DAG) {
    ConstantFPSDNode *CFPNode = cast<ConstantFPSDNode>(Op);
    return DAG
        .getConstant(CFPNode->getValueAPF().bitcastToAPInt().zext(32),
                     SDLoc(Op), MVT::i32)
        .getNode();
  }

  static SDNode *LowerConstantFPToConstant(SDValue Op, SelectionDAG &DAG) {
    ConstantFPSDNode *CFPNode = cast<ConstantFPSDNode>(Op);
    return DAG
        .getConstant(CFPNode->getValueAPF().bitcastToAPInt(), SDLoc(Op),
                     MVT::i32)
        .getNode();
  }

  static SDNode *LowerConstantDPToConstantLo(SDValue Op, SelectionDAG &DAG) {
    SDLoc DL(Op);
    ConstantFPSDNode *CFPNode = cast<ConstantFPSDNode>(Op);
    APInt Val = CFPNode->getValueAPF().bitcastToAPInt();
    APInt LowVal = Val.getLoBits(32);
    return DAG.getConstant(LowVal.trunc(32), DL, MVT::i32).getNode();
  }

  static SDNode *LowerConstantDPToConstantHi(SDValue Op, SelectionDAG &DAG) {
    SDLoc DL(Op);
    ConstantFPSDNode *CFPNode = cast<ConstantFPSDNode>(Op);
    APInt Val = CFPNode->getValueAPF().bitcastToAPInt();
    APInt HighVal = Val.lshr(32);
    return DAG.getConstant(HighVal.trunc(32), DL, MVT::i32).getNode();
  }

  static SDNode *LowerExtractVectorElt(SDValue Op, SelectionDAG &DAG) {
    SDLoc dl(Op);
    SDValue Idx = Op.getOperand(1);
    SDValue Vec = Op.getOperand(0);
    std::vector<int> ShuffleMask;
    ShuffleMask.push_back(cast<ConstantSDNode>(Idx)->getZExtValue());
    unsigned NumElems = Vec.getValueType().getVectorNumElements();
    for (unsigned I = 0; I < NumElems - 1; ++I)
      ShuffleMask.push_back(-1);
    SDValue Undef = DAG.getNode(ISD::UNDEF, dl, Vec.getValueType());
    return DAG.getVectorShuffle(Vec.getValueType(), dl, Vec, Undef, ShuffleMask)
        .getNode();
  }

  // Big-endian version
  static SDNode *LowerExtractVectorElt_BE(SDValue Op, SelectionDAG &DAG) {
    SDLoc dl(Op);
    SDValue Idx = Op.getOperand(1);
    SDValue Vec = Op.getOperand(0);
    std::vector<int> ShuffleMask;
    unsigned NumElems = Vec.getValueType().getVectorNumElements();
    for (unsigned I = 0; I < NumElems - 1; ++I)
      ShuffleMask.push_back(-1);
    ShuffleMask.push_back(cast<ConstantSDNode>(Idx)->getZExtValue());
    SDValue Undef = DAG.getNode(ISD::UNDEF, dl, Vec.getValueType());
    return DAG.getVectorShuffle(Vec.getValueType(), dl, Vec, Undef, ShuffleMask)
        .getNode();
  }

  static SDNode *LowerExtractVectorEltVar(SDValue Op, SelectionDAG &DAG) {
    SDLoc DL(Op);
    SDValue Idx = Op.getOperand(1);
    SDValue Vec = Op.getOperand(0);
    std::vector<SDValue> Values;
    for (unsigned I = 0; I < Vec.getValueType().getVectorNumElements(); ++I)
      Values.push_back(Idx);
    MVT ScalarVT;
    EVT VT = Vec.getValueType();
    switch (VT.getVectorElementType().getSimpleVT().SimpleTy) {
    case MVT::f32:
    case MVT::i32:
      ScalarVT = MVT::i32;
      break;
    case MVT::f16:
    case MVT::i16:
      ScalarVT = MVT::i16;
      break;
    case MVT::i8:
      ScalarVT = MVT::i8;
      break;
    default:
      assert("Unsupported element type for vector extract!");
    }
    MVT VectorVT = MVT::getVectorVT(ScalarVT, VT.getVectorNumElements());
    return DAG.getNode(ISD::BUILD_VECTOR, DL, VectorVT, Values).getNode();
  }

  static SDNode *LowerVectorShuffleConstIntsHalf(SDValue Op,
                                                 SelectionDAG &DAG) {
    SDLoc DL(Op);
    ShuffleVectorSDNode *SVNode = cast<ShuffleVectorSDNode>(Op);
    ArrayRef<int> ShuffleMask = SVNode->getMask();
    std::vector<SDValue> Values;
    for (unsigned I = 0; I < ShuffleMask.size(); ++I)
      Values.push_back(DAG.getConstant(ShuffleMask[I], DL, MVT::i32));
    EVT VT = Op.getValueType();
    assert(VT.getVectorElementType().getSimpleVT().SimpleTy == MVT::f16 &&
           "Expecting f16 element type!");
    MVT VectorVT = MVT::getVectorVT(MVT::i32, VT.getVectorNumElements());
    return DAG.getNode(ISD::BUILD_VECTOR, DL, VectorVT, Values).getNode();
  }

  static SDNode *LowerVectorShuffleConstInts(SDValue Op, SelectionDAG &DAG) {
    SDLoc DL(Op);
    ShuffleVectorSDNode *SVNode = cast<ShuffleVectorSDNode>(Op);
    ArrayRef<int> ShuffleMask = SVNode->getMask();
    std::vector<SDValue> Values;
    MVT ScalarVT;
    EVT VT = Op.getValueType();
    switch (VT.getVectorElementType().getSimpleVT().SimpleTy) {
    case MVT::f64:
    case MVT::i64:
      ScalarVT = MVT::i64;
      break;
    case MVT::f32:
    case MVT::i32:
      ScalarVT = MVT::i32;
      break;
    case MVT::f16:
    case MVT::i16:
      ScalarVT = MVT::i16;
      break;
    case MVT::i8:
      ScalarVT = MVT::i8;
      break;
    default:
      assert("Unsupported element type for vector shuffle!");
    }
    if (ScalarVT == MVT::i64) {
      bool IsLE = DAG.getDataLayout().isLittleEndian();
      for (unsigned I = 0; I < ShuffleMask.size() * 2; ++I)
        if (I % 2)
          Values.push_back(
              DAG.getConstant(IsLE ? 0 : ShuffleMask[I / 2], DL, MVT::i32));
        else
          Values.push_back(
              DAG.getConstant(IsLE ? ShuffleMask[I / 2] : 0, DL, MVT::i32));
      MVT VectorVT2 = MVT::getVectorVT(MVT::i32, VT.getVectorNumElements() * 2);
      SDValue BV = DAG.getNode(ISD::BUILD_VECTOR, DL, VectorVT2, Values);
      MVT VectorVT = MVT::getVectorVT(ScalarVT, VT.getVectorNumElements());
      return DAG.getNode(ISD::BITCAST, DL, VectorVT, BV).getNode();
    } else {
      for (unsigned I = 0; I < ShuffleMask.size(); ++I)
        Values.push_back(DAG.getConstant(ShuffleMask[I], DL, MVT::i32));
      MVT VectorVT = MVT::getVectorVT(ScalarVT, VT.getVectorNumElements());
      return DAG.getNode(ISD::BUILD_VECTOR, DL, VectorVT, Values).getNode();
    }
  }

  static SDNode *LowerVectorShuffleConstIntsBE(SDValue Op, SelectionDAG &DAG) {
    SDLoc DL(Op);
    ShuffleVectorSDNode *SVNode = cast<ShuffleVectorSDNode>(Op);
    ArrayRef<int> ShuffleMask = SVNode->getMask();
    std::vector<SDValue> Values;
    MVT ScalarVT;
    EVT VT = Op.getValueType();
    switch (VT.getVectorElementType().getSimpleVT().SimpleTy) {
    case MVT::f64:
    case MVT::i64:
      ScalarVT = MVT::i64;
      break;
    case MVT::f32:
    case MVT::i32:
      ScalarVT = MVT::i32;
      break;
    case MVT::f16:
    case MVT::i16:
      ScalarVT = MVT::i16;
      break;
    case MVT::i8:
      ScalarVT = MVT::i8;
      break;
    default:
      assert("Unsupported element type for vector shuffle!");
    }
    bool IsLE = DAG.getDataLayout().isLittleEndian();
    if (ScalarVT == MVT::i64) {
      for (unsigned I = 0; I < ShuffleMask.size() * 2; ++I) {
        unsigned ShuffleMaskVal =
            2 * ShuffleMask.size() - 1 - ShuffleMask[I / 2];
        if (I % 2)
          Values.push_back(
              DAG.getConstant(IsLE ? 0 : ShuffleMaskVal, DL, MVT::i32));
        else
          Values.push_back(
              DAG.getConstant(IsLE ? ShuffleMaskVal : 0, DL, MVT::i32));
      }
      MVT VectorVT2 = MVT::getVectorVT(MVT::i32, VT.getVectorNumElements() * 2);
      SDValue BV = DAG.getNode(ISD::BUILD_VECTOR, DL, VectorVT2, Values);
      MVT VectorVT = MVT::getVectorVT(ScalarVT, VT.getVectorNumElements());
      return DAG.getNode(ISD::BITCAST, DL, VectorVT, BV).getNode();
    } else {
      // For big-endian machines, (eg: HiFi5), the indirect shuffle instructions
      // (eg: AE_SEL16X4) uses a little-endian ordering (right to left across
      // the 2 vectors) - TENX-55386
      for (unsigned I = 0; I < ShuffleMask.size(); ++I) {
        unsigned ShuffleMaskVal = 2 * ShuffleMask.size() - 1 - ShuffleMask[I];
        Values.push_back(DAG.getConstant(ShuffleMaskVal, DL, MVT::i32));
      }
      MVT VectorVT = MVT::getVectorVT(ScalarVT, VT.getVectorNumElements());
      return DAG.getNode(ISD::BUILD_VECTOR, DL, VectorVT, Values).getNode();
    }
  }

  static SDNode *LowerZSextBuildVectorOfOnes(SDValue Op, SelectionDAG &DAG) {
    SDLoc DL(Op);
    std::vector<SDValue> Values;
    EVT VT = Op.getValueType();
    MVT ScalarVT;
    switch (VT.getVectorElementType().getSimpleVT().SimpleTy) {
    case MVT::i64:
    case MVT::i32:
      ScalarVT = MVT::i32;
      break;
    case MVT::i16:
      ScalarVT = MVT::i16;
      break;
    case MVT::i8:
      ScalarVT = MVT::i8;
      break;
    default:
      assert("Unsupported element type for vector shuffle!");
    }
    unsigned NumVecElems = VT.getVectorNumElements();
    if (VT.getVectorElementType().getSimpleVT().SimpleTy == MVT::i64) {
      NumVecElems *= 2;
      for (unsigned I = 0; I < NumVecElems; ++I)
        if (I % 2 == 0)
          Values.push_back(DAG.getConstant(1, DL, MVT::i32));
        else
          Values.push_back(DAG.getConstant(0, DL, MVT::i32));
    } else {
      for (unsigned I = 0; I < NumVecElems; ++I)
        Values.push_back(DAG.getConstant(1, DL, MVT::i32));
    }
    MVT VectorVT = MVT::getVectorVT(ScalarVT, NumVecElems);
    SDValue BV = DAG.getNode(ISD::BUILD_VECTOR, DL, VectorVT, Values);
    return DAG.getNode(ISD::BITCAST, DL, VT, BV).getNode();
  }

  static SDNode *LowerZSextBuildVectorOfZeros(SDValue Op, SelectionDAG &DAG) {
    SDLoc DL(Op);
    std::vector<SDValue> Values;
    EVT VT = Op.getValueType();
    MVT ScalarVT;
    switch (VT.getVectorElementType().getSimpleVT().SimpleTy) {
    case MVT::i64:
    case MVT::i32:
      ScalarVT = MVT::i32;
      break;
    case MVT::i16:
      ScalarVT = MVT::i16;
      break;
    case MVT::i8:
      ScalarVT = MVT::i8;
      break;
    default:
      assert("Unsupported element type for vector shuffle!");
    }
    unsigned NumVecElems = VT.getVectorNumElements();
    if (VT.getVectorElementType().getSimpleVT().SimpleTy == MVT::i64)
      NumVecElems *= 2;
    for (unsigned I = 0; I < NumVecElems; ++I)
      Values.push_back(DAG.getConstant(0, DL, MVT::i32));
    MVT VectorVT = MVT::getVectorVT(ScalarVT, NumVecElems);
    SDValue BV = DAG.getNode(ISD::BUILD_VECTOR, DL, VectorVT, Values);
    return DAG.getNode(ISD::BITCAST, DL, VT, BV).getNode();
  }

  static SDNode *LowerZSextBuildVectorOfAllOnes(SDValue Op, SelectionDAG &DAG) {
    SDLoc DL(Op);
    std::vector<SDValue> Values;
    EVT VT = Op.getValueType();
    MVT ScalarVT;
    switch (VT.getVectorElementType().getSimpleVT().SimpleTy) {
    case MVT::i64:
    case MVT::i32:
      ScalarVT = MVT::i32;
      break;
    case MVT::i16:
      ScalarVT = MVT::i16;
      break;
    case MVT::i8:
      ScalarVT = MVT::i8;
      break;
    default:
      assert("Unsupported element type for vector shuffle!");
    }
    unsigned NumVecElems = VT.getVectorNumElements();
    if (VT.getVectorElementType().getSimpleVT().SimpleTy == MVT::i64)
      NumVecElems *= 2;
    for (unsigned I = 0; I < NumVecElems; ++I)
      Values.push_back(DAG.getConstant(0xffffffff, DL, MVT::i32));
    MVT VectorVT = MVT::getVectorVT(ScalarVT, NumVecElems);
    SDValue BV = DAG.getNode(ISD::BUILD_VECTOR, DL, VectorVT, Values);
    return DAG.getNode(ISD::BITCAST, DL, VT, BV).getNode();
  }

  static SDNode *LowerTruncBuildVectorOfZeros(SDValue Op, SelectionDAG &DAG) {
    SDLoc DL(Op);
    std::vector<SDValue> Values;
    EVT VT = Op.getOperand(0).getValueType();
    MVT ScalarVT;
    switch (VT.getVectorElementType().getSimpleVT().SimpleTy) {
    case MVT::i64:
    case MVT::i32:
      ScalarVT = MVT::i32;
      break;
    case MVT::i16:
      ScalarVT = MVT::i16;
      break;
    case MVT::i8:
      ScalarVT = MVT::i8;
      break;
    default:
      assert("Unsupported element type for vector shuffle!");
    }
    unsigned NumVecElems = VT.getVectorNumElements();
    if (VT.getVectorElementType().getSimpleVT().SimpleTy == MVT::i64)
      NumVecElems *= 2;
    for (unsigned I = 0; I < NumVecElems; ++I)
      Values.push_back(DAG.getConstant(0, DL, MVT::i32));
    MVT VectorVT = MVT::getVectorVT(ScalarVT, NumVecElems);
    SDValue BV = DAG.getNode(ISD::BUILD_VECTOR, DL, VectorVT, Values);
    return DAG.getNode(ISD::BITCAST, DL, VT, BV).getNode();
  }

  static SDNode *LowerMScatterGatherOffsets(SDValue Op, SelectionDAG &DAG) {
    SDLoc DL(Op);
    std::vector<SDValue> Values;
    EVT VT = Op.getOperand(4).getValueType();
    EVT MemVT = cast<MemSDNode>(Op.getNode())->getMemoryVT();
    unsigned Log2Scale = countTrailingZeros(
        (unsigned)(MemVT.getVectorElementType().getSizeInBits() / 8));
    if (Log2Scale == 0)
      return Op.getOperand(4).getNode();
    SmallVector<SDValue, 16> Ops(VT.getVectorNumElements(),
                                 DAG.getConstant(Log2Scale, DL, MVT::i32));
    SDValue ScaleVec = DAG.getNode(ISD::BUILD_VECTOR, DL, VT, Ops);
    return DAG.getNode(ISD::SHL, DL, VT, Op.getOperand(4), ScaleVec).getNode();
  }

  static SDNode *LowerBuildVectorBool(SDValue Op, SelectionDAG &DAG,
                                      int ElemBitWidth) {
    SDLoc DL(Op);
    std::vector<SDValue> Values;
    std::vector<SDValue> OneValues;

    EVT VT = Op.getValueType();
    MVT ScalarVT = MVT::getIntegerVT(ElemBitWidth);
    unsigned NumVecElems = VT.getVectorNumElements();
    MVT VectorVT = MVT::getVectorVT(ScalarVT, NumVecElems);

    for (unsigned I = 0; I < NumVecElems; ++I)
      Values.push_back(Op.getOperand(I));
    SDValue BV = DAG.getNode(ISD::BUILD_VECTOR, DL, VectorVT, Values);

    for (unsigned I = 0; I < NumVecElems; ++I)
      OneValues.push_back(DAG.getConstant(0x1, DL, MVT::i32));
    SDValue BVOnes = DAG.getNode(ISD::BUILD_VECTOR, DL, VectorVT, OneValues);

    return DAG
        .getNode(ISD::SETCC, DL, VT, BV, BVOnes, DAG.getCondCode(ISD::SETEQ))
        .getNode();
  }

  static SDNode *LowerBuildVectorBool8(SDValue Op, SelectionDAG &DAG) {
    return LowerBuildVectorBool(Op, DAG, 8);
  }

  static SDNode *LowerBuildVectorBool16(SDValue Op, SelectionDAG &DAG) {
    return LowerBuildVectorBool(Op, DAG, 16);
  }

  static SDNode *LowerBuildVectorBool32(SDValue Op, SelectionDAG &DAG) {
    return LowerBuildVectorBool(Op, DAG, 32);
  }

  static SDNode *NoLower(SDValue Op, SelectionDAG &DAG) { return Op.getNode(); }

  static void ExpandShuffleMaskRev(unsigned NumElemsInSeliTableMask,
                                   ArrayRef<int> ShuffleMask,
                                   std::vector<int> &ExpandedShuffleMask) {
    unsigned Factor = NumElemsInSeliTableMask / ShuffleMask.size();
    for (int I = ShuffleMask.size() - 1; I >= 0; --I) {
      for (int J = Factor - 1; J >= 0; --J) {
        if (ShuffleMask[I] == -1)
          ExpandedShuffleMask.push_back(-1);
        else
          ExpandedShuffleMask.push_back(ShuffleMask[I] * Factor + J);
      }
    }
  }

  static void ExpandShuffleMask(unsigned NumElemsInSeliTableMask,
                                ArrayRef<int> ShuffleMask,
                                std::vector<int> &ExpandedShuffleMask) {
    unsigned Factor = NumElemsInSeliTableMask / ShuffleMask.size();
    for (unsigned I = 0; I < ShuffleMask.size(); ++I) {
      for (unsigned J = 0; J < Factor; ++J) {
        if (ShuffleMask[I] == -1)
          ExpandedShuffleMask.push_back(-1);
        else
          ExpandedShuffleMask.push_back(ShuffleMask[I] * Factor + J);
      }
    }
  }

  static bool MatchShuffleMask(std::vector<int> &ExpandedShuffleMask,
                               const int *SeliTableMask) {
    unsigned MaskSize = ExpandedShuffleMask.size();
    // Check for direct match of the shuffle mask with the seli table mask
    for (unsigned I = 0; I < MaskSize; ++I)
      if (ExpandedShuffleMask[I] != -1 &&
          ExpandedShuffleMask[I] != SeliTableMask[I])
        return false;
    return true;
  }

  static bool MatchShuffleMaskUndef(std::vector<int> &ExpandedShuffleMask,
                                    const int *SeliTableMask) {
    unsigned MaskSize = ExpandedShuffleMask.size();
    // Check for modulo match of the shuffle mask with the seli table mask.
    // that allows matching if the 1st operand is undefined
    // and the mask uses the 0th operand's indices
    for (unsigned I = 0; I < MaskSize; ++I)
      if (ExpandedShuffleMask[I] != -1 &&
          ((ExpandedShuffleMask[I] % MaskSize) !=
           (SeliTableMask[I] % MaskSize)))
        return false;
    return true;
  }
};

struct OpAction {
  unsigned ISD;
  MVT VT;
  TargetLoweringBase::LegalizeAction Action;
  enum { NoPred = 1, UnsafeFPMath };
  unsigned AddActionPred;
};

struct LoadStoreAction {
  unsigned ISD;
  unsigned ExtType;
  MVT ValVT;
  MVT MemVT;
  TargetLoweringBase::LegalizeAction Action;
};

struct PromotedOpAction {
  unsigned ISD;
  MVT SrcVT;
  MVT DestVT;
};

struct OpDesc {
  unsigned ISD;
  MVT VT;
};

struct TypeDesc {
  unsigned TypeID;
  unsigned BitWidth;
  unsigned NumElements;
};

} // namespace Tensilica
} // namespace llvm

#endif // LLVM_LIB_CODEGEN_TENSILICA_TENSILICAOPERATIONISELLOWER_H
