//===-- TensilicaIntrinsicISelLower.h - Tensilica ISel Proto Interface ----===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file defines the interfaces that Tensilica uses to lower intrinsics into
// a machine selection DAG.
//
//===----------------------------------------------------------------------===//

#ifndef LLVM_LIB_CODEGEN_TENSILICA_TENSILICAINTRINSICISELLOWER_H
#define LLVM_LIB_CODEGEN_TENSILICA_TENSILICAINTRINSICISELLOWER_H

#include "llvm/CodeGen/ISDOpcodes.h"

#define XTENSA_INTRN_ISEL_LAST_INSN_IN_PROTO true
#define XTENSA_INTRN_ISEL_ISD_OPCODE         true
#define XTENSA_INTRN_ISEL_NEEDS_GLUE         true

#define XTENSA_INTRN_ISEL_USE_OPND(x)  x
#define XTENSA_INTRN_ISEL_DEF_OPND(x)  x

#define XTENSA_INTRN_ISEL_INSN_OPND(x) ((x << 8) & 0xff00)
#define XTENSA_INTRN_ISEL_INSN(x)      (x & 0xff)

#define XTENSA_INTRN_ISEL_SUPER_REG(x) ((x << 16) & 0xffff0000)
#define XTENSA_INTRN_ISEL_SUB_REG(x)   (x & 0xffff)

#define XTENSA_INTRN_ISEL_MAX_INPUTS   (24)
#define XTENSA_INTRN_ISEL_MAX_OUTPUTS  (9)
#define XTENSA_INTRN_ISEL_MAX_IMMS     (18)

namespace llvm {
namespace Tensilica {

// For linking instructions within a proto sequence
enum TensilicaISelLinkType {
  TENSILICA_ISEL_CHAIN,
  TENSILICA_ISEL_GLUE,
  TENSILICA_ISEL_NONE
};

// Enum to generate the operands of the generated DAG node
enum IntrnISelOperandType {
  // The input is an operand of the target intrinsic 
  XTENSA_INTRN_ISEL_OPND       = 0x1, 
  // The input is a constant to be materialized as is
  XTENSA_INTRN_ISEL_IMM        = 0x2, 
  // The input is a temp generated by a previous node in the expanded sequence
  XTENSA_INTRN_ISEL_TMP        = 0x4, 
  // The input is the last use (either a temp or the intrinsic input operand)
  XTENSA_INTRN_ISEL_LAST_USE   = 0x8,
  // Physical register
  XTENSA_INTRN_ISEL_PHYS_REG   = 0x10
};

// Predicate to check if the input immediate satisfies the immediates
// range constraints
typedef bool (*ISelImmPredicateFunc)(int32_t ImmVal);

// Struct to represent the information required to generate the machine
// node operand
struct IntrnISelOperandInfo {
  unsigned OpndType;
  union {
    // Index of the intrinsic operand if the input/output is an intrinsic 
    // operand. The index is relative to either the input or the outputs.
    int IntrnOpnd;
    // Index of the last(for input)/current(for output) instruction/operand in 
    // the proto sequence that generated this temporary 
    int TmpDef;
  } Index;
  // The constant offset used in case of an immediate intrinsic operand or the
  // constant value in case of a constant immediate. For reg operands,
  // use physical register number
  int ImmValue;
  // MachineValueType of the input operand
  MVT::SimpleValueType VT;
};

// Struct to represent the immediate predicate to be applied to a given
// intrinsic operand
struct ISelImmPred {
  // Index of the intrinsic immediate operand
  unsigned IntrnOpndIdx;
  // The predicate function to be applied
  ISelImmPredicateFunc Pred;
};

// Struct to represent an instruction in the proto sequence that is used
// to generate the corresponding machine node
struct IntrinsicISelInfo {
  // Intrinsic id
  unsigned Id;
  // The machine instruction opcode
  unsigned Opcode;
  // Index of this instruction in the proto sequence
  unsigned Idx;
  // Inputs
  unsigned NumInputs;
  IntrnISelOperandInfo InOpndInfos[XTENSA_INTRN_ISEL_MAX_INPUTS];
  // Outputs
  unsigned NumOutputs;
  IntrnISelOperandInfo OutOpndInfos[XTENSA_INTRN_ISEL_MAX_OUTPUTS];
  // Immediate predicate to be applied for each input immediate
  unsigned NumImmPreds;
  ISelImmPred ImmPreds[XTENSA_INTRN_ISEL_MAX_IMMS];
  bool IsMemOp;
  int Offset;
  unsigned Size;
  // Is this an ISD opcode
  bool ISDOpcode;
  // Do we need a glue
  bool NeedsGlue;
  // Is this the last instruction in the proto sequence
  bool LastInst;
  
  bool operator<(const IntrinsicISelInfo &RHS) const {
    return Id < RHS.Id;
  }
  
  bool operator==(const IntrinsicISelInfo &RHS) const {
    return RHS.Id == Id;
  }
};

} // namespace Tensilica
} // namespace llvm

#endif // LLVM_LIB_CODEGEN_TENSILICA_TENSILICAINTRINSICISELLOWER_H
