//===-- RISCVISelDAGToDAG.cpp - A dag to dag inst selector for RISCV ------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// This file defines an instruction selector for the RISCV target.
//
//===----------------------------------------------------------------------===//

#if defined(TENSILICA) || 1
#include "Tensilica/TensilicaIntrinsicISelLower.h"
#include "Tensilica/TensilicaISelDAGToDAG.h"
#endif
#include "MCTargetDesc/RISCVMCTargetDesc.h"
#include "RISCV.h"
#include "RISCVTargetMachine.h"
#include "Utils/RISCVMatInt.h"
#include "llvm/CodeGen/MachineFrameInfo.h"
#include "llvm/CodeGen/SelectionDAGISel.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/MathExtras.h"
#include "llvm/Support/raw_ostream.h"
using namespace llvm;

#define DEBUG_TYPE "riscv-isel"

// RISCV-specific code to select RISCV machine instructions for
// SelectionDAG operations.
namespace {
#if defined(TENSILICA) || 1
class RISCVDAGToDAGISel final : public Tensilica::SDAGISel {
#else
class RISCVDAGToDAGISel final : public SelectionDAGISel {
#endif
  const RISCVSubtarget *Subtarget = nullptr;

public:
#if defined(TENSILICA) || 1
  explicit RISCVDAGToDAGISel(RISCVTargetMachine &TargetMachine,
                             CodeGenOpt::Level OptLevel)
      : Tensilica::SDAGISel(TargetMachine, OptLevel) {}
#else
  explicit RISCVDAGToDAGISel(RISCVTargetMachine &TargetMachine)
      : SelectionDAGISel(TargetMachine) {}
#endif

  StringRef getPassName() const override {
    return "RISCV DAG->DAG Pattern Instruction Selection";
  }

  bool runOnMachineFunction(MachineFunction &MF) override {
    Subtarget = &MF.getSubtarget<RISCVSubtarget>();
    return SelectionDAGISel::runOnMachineFunction(MF);
  }

  void PostprocessISelDAG() override;

  void Select(SDNode *Node) override;

  bool SelectInlineAsmMemoryOperand(const SDValue &Op, unsigned ConstraintID,
                                    std::vector<SDValue> &OutOps) override;

  bool SelectAddrFI(SDValue Addr, SDValue &Base);

#if defined(TENSILICA) || 1
  void
  ReplaceUsesOfIntrnOutputs(const Tensilica::IntrinsicISelInfo *IntrISelInfo,
                            SDNode *Old, SDNode *New);
  bool SelectAddrCommon(SDValue N, SDValue &Base, SDValue &Offset,
                        std::function<bool(int32_t)> func);
  bool SelectINTRINSIC_W_CHAIN(SDNode *N);
  bool SelectINTRINSIC_WO_CHAIN(SDNode *N);
  SDNode *SelectSELECT_CC(SDNode *N);
  SDNode *SelectImmBeforeSHL(SDNode *N);

  /// getI32Imm - Return a target constant with the specified value, of type
  /// i32.
  inline SDValue getI32Imm(unsigned Imm, const SDLoc &dl) {
    return CurDAG->getTargetConstant(Imm, dl, MVT::i32);
  }

  // Return true if Imm can be added with ADDI.
  inline bool immADDI(int32_t Imm) {
    return isInt<12>(Imm);
  }

  inline bool immMOVI(int32_t Imm) {
    return isInt<12>(Imm);
  }

  inline bool immANDI(int32_t Imm) {
    return isInt<12>(Imm);
  }

  inline SDNode *addImmediate(SDLoc &dl, SDValue N, int32_t Imm) {
    assert(immADDI(Imm) && "Invalid Imm");
    return CurDAG->getMachineNode(RISCV::ADDI, dl, MVT::i32,
                                  N, getI32Imm(Imm, dl));
  }

  inline SDNode *movImmediate(SDLoc &dl, int32_t Imm) {
    SDValue ZeroReg = CurDAG->getRegister(RISCV::X0, MVT::i32);
    return addImmediate(dl, ZeroReg, Imm);
  }

  inline SDNode *shiftRightLogicalImmediate(SDLoc &dl, SDValue N, 
                                            uint32_t Imm) {
    return CurDAG->getMachineNode(RISCV::SRLI, dl, MVT::i32,
                                  N, getI32Imm(Imm, dl));
  }
#endif

// Include the pieces autogenerated from the target description.
#include "RISCVGenDAGISel.inc"

// Include the autogenerated complex pattern definitions
#if defined(TENSILICA) || 1
#define GET_ISEL_LOWER_IMM_PRED_COMPLEX_PATTERN
#include "TensilicaGenIntrinsicISelLower.inc"
#endif

private:
  void doPeepholeLoadStoreADDI();
};
}

void RISCVDAGToDAGISel::PostprocessISelDAG() {
  doPeepholeLoadStoreADDI();
}

static SDNode *selectImm(SelectionDAG *CurDAG, const SDLoc &DL, int64_t Imm,
                         MVT XLenVT) {
  RISCVMatInt::InstSeq Seq;
  RISCVMatInt::generateInstSeq(Imm, XLenVT == MVT::i64, Seq);

  SDNode *Result = nullptr;
  SDValue SrcReg = CurDAG->getRegister(RISCV::X0, XLenVT);
  for (RISCVMatInt::Inst &Inst : Seq) {
    SDValue SDImm = CurDAG->getTargetConstant(Inst.Imm, DL, XLenVT);
    if (Inst.Opc == RISCV::LUI)
      Result = CurDAG->getMachineNode(RISCV::LUI, DL, XLenVT, SDImm);
    else
      Result = CurDAG->getMachineNode(Inst.Opc, DL, XLenVT, SrcReg, SDImm);

    // Only the first instruction has X0 as its source.
    SrcReg = SDValue(Result, 0);
  }

  return Result;
}

// Returns true if the Node is an ISD::AND with a constant argument. If so,
// set Mask to that constant value.
static bool isConstantMask(SDNode *Node, uint64_t &Mask) {
  if (Node->getOpcode() == ISD::AND &&
      Node->getOperand(1).getOpcode() == ISD::Constant) {
    Mask = cast<ConstantSDNode>(Node->getOperand(1))->getZExtValue();
    return true;
  }
  return false;
}

void RISCVDAGToDAGISel::Select(SDNode *Node) {
  // If we have a custom node, we have already selected.
  if (Node->isMachineOpcode()) {
    LLVM_DEBUG(dbgs() << "== "; Node->dump(CurDAG); dbgs() << "\n");
    Node->setNodeId(-1);
    return;
  }

  // Instruction Selection not handled by the auto-generated tablegen selection
  // should be handled here.
  unsigned Opcode = Node->getOpcode();
  MVT XLenVT = Subtarget->getXLenVT();
  SDLoc DL(Node);
  EVT VT = Node->getValueType(0);
#if defined (TENSILICA) || 1
  SDNode *NewN = nullptr;
#endif

  switch (Opcode) {
  case ISD::Constant: {
    auto ConstNode = cast<ConstantSDNode>(Node);
    if (VT == XLenVT && ConstNode->isNullValue()) {
      SDValue New = CurDAG->getCopyFromReg(CurDAG->getEntryNode(), SDLoc(Node),
                                           RISCV::X0, XLenVT);
      ReplaceNode(Node, New.getNode());
      return;
    }
    int64_t Imm = ConstNode->getSExtValue();
    if (XLenVT == MVT::i64) {
      ReplaceNode(Node, selectImm(CurDAG, SDLoc(Node), Imm, XLenVT));
      return;
    }
    break;
  }
  case ISD::FrameIndex: {
    SDValue Imm = CurDAG->getTargetConstant(0, DL, XLenVT);
    int FI = cast<FrameIndexSDNode>(Node)->getIndex();
    SDValue TFI = CurDAG->getTargetFrameIndex(FI, VT);
    ReplaceNode(Node, CurDAG->getMachineNode(RISCV::ADDI, DL, VT, TFI, Imm));
    return;
  }
  case ISD::SRL: {
    if (!Subtarget->is64Bit())
      break;
    SDValue Op0 = Node->getOperand(0);
    SDValue Op1 = Node->getOperand(1);
    uint64_t Mask;
    // Match (srl (and val, mask), imm) where the result would be a
    // zero-extended 32-bit integer. i.e. the mask is 0xffffffff or the result
    // is equivalent to this (SimplifyDemandedBits may have removed lower bits
    // from the mask that aren't necessary due to the right-shifting).
    if (Op1.getOpcode() == ISD::Constant &&
        isConstantMask(Op0.getNode(), Mask)) {
      uint64_t ShAmt = cast<ConstantSDNode>(Op1.getNode())->getZExtValue();

      if ((Mask | maskTrailingOnes<uint64_t>(ShAmt)) == 0xffffffff) {
        SDValue ShAmtVal =
            CurDAG->getTargetConstant(ShAmt, SDLoc(Node), XLenVT);
        CurDAG->SelectNodeTo(Node, RISCV::SRLIW, XLenVT, Op0.getOperand(0),
                             ShAmtVal);
        return;
      }
    }
    break;
  }

#if defined(TENSILICA) || 1
  case ISD::ADD:
  case ISD::OR:
  case ISD::XOR:
    NewN = SelectImmBeforeSHL(Node);
    break;
  case ISD::SELECT_CC:
    NewN = SelectSELECT_CC(Node);
    break;
  // Note, we return early here since the SelectINTRINSIC could return a
  // a nullptr to denote that ReplaceAllUses is already done
  case ISD::INTRINSIC_VOID:
  case ISD::INTRINSIC_W_CHAIN: {
    if (SelectINTRINSIC_W_CHAIN(Node))
      // We've taken care of everything.
      return;
    break;
  }
  case ISD::INTRINSIC_WO_CHAIN: {
    if (SelectINTRINSIC_WO_CHAIN(Node))
      // We've taken care of everything.
      return;
    break;
  }
#endif

  case RISCVISD::READ_CYCLE_WIDE:
    assert(!Subtarget->is64Bit() && "READ_CYCLE_WIDE is only used on riscv32");

    ReplaceNode(Node, CurDAG->getMachineNode(RISCV::ReadCycleWide, DL, MVT::i32,
                                             MVT::i32, MVT::Other,
                                             Node->getOperand(0)));
    return;
  }

#if defined(TENSILICA) || 1
  // If the helpers above return non-null, we are done.
  if (NewN)
    return;
#endif

  // Select the default instruction.
  SelectCode(Node);
}

bool RISCVDAGToDAGISel::SelectInlineAsmMemoryOperand(
    const SDValue &Op, unsigned ConstraintID, std::vector<SDValue> &OutOps) {
  switch (ConstraintID) {
  case InlineAsm::Constraint_m:
    // We just support simple memory operands that have a single address
    // operand and need no special handling.
    OutOps.push_back(Op);
    return false;
  case InlineAsm::Constraint_A:
    OutOps.push_back(Op);
    return false;
  default:
    break;
  }

  return true;
}

bool RISCVDAGToDAGISel::SelectAddrFI(SDValue Addr, SDValue &Base) {
  if (auto FIN = dyn_cast<FrameIndexSDNode>(Addr)) {
    Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), Subtarget->getXLenVT());
    return true;
  }
  return false;
}

#if defined(TENSILICA) || 1
// If an instruction generates the intrinsics output, replace the uses
// of the original intrinsic output operand with the output of the instruction
void RISCVDAGToDAGISel::ReplaceUsesOfIntrnOutputs(
    const Tensilica::IntrinsicISelInfo *IntrISelInfo, SDNode *Old,
    SDNode *New) {
  assert(IntrISelInfo->NumOutputs <= XTENSA_INTRN_ISEL_MAX_OUTPUTS);
  for (unsigned i = 0; i < IntrISelInfo->NumOutputs; ++i) {
    const Tensilica::IntrnISelOperandInfo &Opnd = IntrISelInfo->OutOpndInfos[i];
    if (Opnd.OpndType == Tensilica::XTENSA_INTRN_ISEL_OPND)
      ReplaceUses(SDValue(Old, Opnd.Index.IntrnOpnd), SDValue(New, i));
  }
}

bool RISCVDAGToDAGISel::SelectAddrCommon(SDValue N,
                                         SDValue &Base,
                                         SDValue &Offset,
                                         std::function<bool(int32_t)> func) {
  SDValue BaseAddr = N;
  int32_t OffsetVal = 0;

  // Recognize Base + Offset.
  if (CurDAG->isBaseWithConstantOffset(N)) {
    BaseAddr = N->getOperand(0);
    OffsetVal = cast<ConstantSDNode>(N->getOperand(1))->getSExtValue();
  }

  // Accept FrameIndex for local objects.  We do not accept FrameIndex
  // for incoming arguments on the stack here.
  FrameIndexSDNode *FIN = nullptr;
  MachineFrameInfo &MFI = MF->getFrameInfo();
  SDLoc dl(N);
  if ((FIN = dyn_cast<FrameIndexSDNode>(BaseAddr)) &&
      !MFI.isFixedObjectIndex(FIN->getIndex())) {
    Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), MVT::i32);
    Offset = getI32Imm(OffsetVal, dl);
    return true;
  }

  // Verify that the offset is valid if a FrameIndex is not involved.
  if (func(OffsetVal)) {
    Base = BaseAddr;
    Offset = getI32Imm(OffsetVal, dl);
    return true;
  }

  // Accept the address as is if zero is a valid offset.
  if (func(0)) {
    Base = N;
    Offset = getI32Imm(0, dl);
    return true;
  }

  return false;
}

bool RISCVDAGToDAGISel::SelectINTRINSIC_W_CHAIN(SDNode *N) {
  const RISCVTargetLowering *TL = Subtarget->getTargetLowering();

  unsigned IntNo = cast<ConstantSDNode>(N->getOperand(1))->getZExtValue();
  const Tensilica::IntrinsicISelInfo *IntrISelInfo =
      TL->getIntrinsicISelInfo(IntNo);
  if (!IntrISelInfo)
    return false;

  // Check if the immediate constraints are satisfied
  if (!TL->checkIntrinsicImmConstraints(N, IntrISelInfo))
    return false;

  // Vector to store the generated instructions. An index into the vector
  // is used to access the results of any temporaries used by a later
  // instruction
  std::vector<SDNode *> Nodes;
  SDNode *Node = nullptr;

  Node = TL->getIntrinsicInst(Nodes, N, N->getOperand(0), CurDAG, IntrISelInfo,
                              getOutLinkType(IntrISelInfo, true));
  Nodes.push_back(Node);
  ReplaceUsesOfIntrnOutputs(IntrISelInfo, N, Node);

  // Generate all the instructions in the proto sequence
  while (!IntrISelInfo->LastInst) {
    // The instructions in the sequence are 'chained'
    SDNode *LastNode = Nodes.back();
    int ChainOpnd = 
        LastNode->getOpcode() == ISD::CopyToReg ? 0 : IntrISelInfo->NumOutputs;
    SDValue Chain = SDValue(LastNode, ChainOpnd);
    ++IntrISelInfo;
    Node = TL->getIntrinsicInst(Nodes, N, Chain, CurDAG, IntrISelInfo,
                                getOutLinkType(IntrISelInfo, true));
    Nodes.push_back(Node);
    ReplaceUsesOfIntrnOutputs(IntrISelInfo, N, Node);
  }
  SDNode *LastNode = Nodes.back();
  // Replace the chain
  assert(SDValue(LastNode, LastNode->getNumValues()-1).getValueType() ==
         MVT::Other);
  ReplaceUses(SDValue(N, N->getNumValues() - 1),
              SDValue(LastNode, LastNode->getNumValues() - 1));
  // Return null since all uses have been replaced
  CurDAG->RemoveDeadNode(N);
  return true;
}

bool RISCVDAGToDAGISel::SelectINTRINSIC_WO_CHAIN(SDNode *N) {
  const RISCVTargetLowering *TL = Subtarget->getTargetLowering();

  unsigned IntNo = cast<ConstantSDNode>(N->getOperand(0))->getZExtValue();
  const Tensilica::IntrinsicISelInfo *IntrISelInfo =
      TL->getIntrinsicISelInfo(IntNo);
  // Couldn't find a match; return the input node
  if (!IntrISelInfo)
    return false;

  // Check if the immediate constraints are satisfied. Return the input
  // node.
  if (!TL->checkIntrinsicImmConstraints(N, IntrISelInfo))
    return false;

  // Array to store the generated instructions. An index into the array
  // is used to access the results of any temporaries used by a later
  // instruction
  std::vector<SDNode *> Nodes;
  SDNode *Node = nullptr;

  Node = TL->getIntrinsicInst(Nodes, N, SDValue(), CurDAG,
                             IntrISelInfo, getOutLinkType(IntrISelInfo, false));
  Nodes.push_back(Node);
  ReplaceUsesOfIntrnOutputs(IntrISelInfo, N, Node);

  // Generate all the instructions in the proto sequence
  while (!IntrISelInfo->LastInst) {
    SDValue LastValue;
    getLastValue(Nodes.back(), LastValue);
    ++IntrISelInfo;
    Node = TL->getIntrinsicInst(Nodes, N, LastValue, CurDAG, IntrISelInfo,
                                getOutLinkType(IntrISelInfo, false));
    Nodes.push_back(Node);
    ReplaceUsesOfIntrnOutputs(IntrISelInfo, N, Node);
  }
  // Return null since all uses have been replaced
  CurDAG->RemoveDeadNode(N);
  return true;
}

SDNode *RISCVDAGToDAGISel::SelectSELECT_CC(SDNode *N) {
  assert(N->getOpcode() == ISD::SELECT_CC && "Wrong opcode");
  SDLoc dl(N);
  MVT XLenVT = Subtarget->getXLenVT();

  EVT VT = N->getValueType(0);
  if (!VT.isInteger())
    return nullptr;

  SDValue CondLHS = N->getOperand(0);
  SDValue CondRHS = N->getOperand(1);
  SDValue TrueValue = N->getOperand(2);
  SDValue FalseValue = N->getOperand(3);

  // Verify that everything is integer.
  assert((CondLHS.getValueType() == XLenVT &&
          CondRHS.getValueType() == XLenVT &&
          TrueValue.getValueType() == XLenVT &&
          FalseValue.getValueType() == XLenVT) &&
         "Types must be all XLenVT.");

  SDValue tem;
  ISD::CondCode CC = cast<CondCodeSDNode>(N->getOperand(4))->get();

  // Canonicalize to EQ, LT, or ULT.
  switch (CC) {
  case ISD::SETGT:
  case ISD::SETUGT:
    tem = CondLHS, CondLHS = CondRHS, CondRHS = tem;
    CC = CC == ISD::SETGT ? ISD::SETLT : ISD::SETULT;
    break;
  case ISD::SETGE:
  case ISD::SETUGE:
    tem = TrueValue, TrueValue = FalseValue, FalseValue = tem;
    CC = CC == ISD::SETGE ? ISD::SETLT : ISD::SETULT;
    break;
  case ISD::SETLE:
  case ISD::SETULE:
    tem = CondLHS, CondLHS = CondRHS, CondRHS = tem;
    tem = TrueValue, TrueValue = FalseValue, FalseValue = tem;
    CC = CC == ISD::SETLE ? ISD::SETLT : ISD::SETULT;
    break;
  case ISD::SETNE:
    tem = TrueValue, TrueValue = FalseValue, FalseValue = tem;
    CC = ISD::SETEQ;
    break;
  default:
    break;
  }

  ConstantSDNode *CondLHSC = dyn_cast<ConstantSDNode>(CondLHS);
  ConstantSDNode *CondRHSC = dyn_cast<ConstantSDNode>(CondRHS);
  ConstantSDNode *TrueValueC = dyn_cast<ConstantSDNode>(TrueValue);
  ConstantSDNode *FalseValueC = dyn_cast<ConstantSDNode>(FalseValue);

  int32_t L = CondLHSC ? CondLHSC->getSExtValue() : 0;
  int32_t R = CondRHSC ? CondRHSC->getSExtValue() : 0;
  int32_t T = TrueValueC ? TrueValueC->getSExtValue() : 0;
  int32_t F = FalseValueC ? FalseValueC->getSExtValue() : 0;

  switch (CC) {
  case ISD::SETEQ: {
    SDValue NewCondLHS;
    bool ZeroOrOneP = false;
    if (CondRHSC && R == 0) {
      NewCondLHS = CondLHS;
      // If we have (X & C) == 0, consider using EXTUI or SLLI to
      // extract the bits we are interested in.
      if (CondLHS->hasOneUse() && CondLHS.getOpcode() == ISD::AND) {
        SDValue CondLHS0 = CondLHS.getOperand(0);
        SDValue CondLHS1 = CondLHS.getOperand(1);
        if (ConstantSDNode *MaskC = dyn_cast<ConstantSDNode>(CondLHS1)) {
          uint32_t Mask = MaskC->getZExtValue();
          unsigned Shift = countTrailingZeros(Mask);
          unsigned Width = countTrailingOnes(Mask >> Shift);
          if (isShiftedMask_32(Mask)) {
            if (Shift == 0) {
              // Use SLLI to get rid of the bits we don't care.
              unsigned L = 32 - Width;
              SDNode *slli = CurDAG->getMachineNode(RISCV::SLLI,
                                                    dl, XLenVT,
                                                    CondLHS0,
                                                    getI32Imm(L, dl));
              NewCondLHS = SDValue(slli, 0);
            } else {
              SDNode *slli = CurDAG->getMachineNode(
                               RISCV::SLLI,
                               dl, XLenVT,
                               CondLHS0,
                               getI32Imm(32 - (Shift + Width), dl));
              SDNode *srli = CurDAG->getMachineNode(
                               RISCV::SRLI,
                               dl, XLenVT,
                               SDValue(slli, 0),
                               getI32Imm(32 - Width, dl));
              NewCondLHS = SDValue(srli, 0);
              ZeroOrOneP = isPowerOf2_32(Mask);
            }
            // Similarly, we could try SRLI here, but we don't.
            // LLVM transforms X & 0xffff0000 to X >u 65535.
          }
        }
      }
    } else {
      // Subtract CondRHS from CondLHS.
      SDNode *sub;
      if (CondRHSC && immADDI(-R))
        sub = addImmediate(dl, CondLHS, -R);
      else
        sub = CurDAG->getMachineNode(RISCV::SUB, dl,
                                     XLenVT, CondLHS, CondRHS);
      NewCondLHS = SDValue(sub, 0);
    }

    if (ZeroOrOneP && TrueValueC && T == 0 &&
        FalseValueC && (F == 3 || F == 5 || F == 9)) {
      unsigned addx_opcode = (F == 3 ? RISCV::SH1ADD :
                              F == 5 ? RISCV::SH2ADD :
                              RISCV::SH3ADD);
      return CurDAG->SelectNodeTo(N, addx_opcode, XLenVT,
                                  NewCondLHS, NewCondLHS);
    }

    if (TrueValueC) {
      if (T == 0)
        // If T == 0, use NewCondLHS as 0 to avoid loading 0.
        TrueValue = NewCondLHS;
      else if (CondRHSC && T == R)
        // If T == R, use CondLHS as R to avoid loading R.
        TrueValue = CondLHS;
    }

    // Recognize CondLHS == CondRHS ? TrueValue : FalseValue.
    return CurDAG->SelectNodeTo(N, RISCV::XT_MOVNEZ, XLenVT,
                                TrueValue,  // when CondLHS == R
                                FalseValue, // when CondLHS != R
                                NewCondLHS);
  }
  case ISD::SETLT:
    // The target-independent optimizer already optimizes:
    //   CondLHS < 0 ? TrueValue : 0
    // to
    //   (CondLHS >>s 31) & TrueValue
    // Recognize CondLHS < 0 ? TrueValue : FalseValue.
    if (CondRHSC && R == 0)
      // One instruction, with F and T already in regs.
      // movltz
      return CurDAG->SelectNodeTo(N, RISCV::XT_MOVLTZ, XLenVT,
                                  FalseValue, // when CondLHS < 0
                                  TrueValue,  // when CondLHS >= 0
                                  CondLHS);

    // Recognize -1 < CondRHS ? TrueValue : FalseValue.
    if (CondLHSC && L == -1)
      // One instruction, with F and T already in regs.
      // movltz
      return CurDAG->SelectNodeTo(N, RISCV::XT_MOVLTZ, XLenVT,
                                  TrueValue,  // when CondRHS >= 0
                                  FalseValue, // when CondRHS < 0
                                  CondRHS);

    // Fall through.
  case ISD::SETULT: {
    unsigned slt_opcode = (CC == ISD::SETLT ? RISCV::SLT : RISCV::SLTU);

    if (CC == ISD::SETULT && CondLHSC && isPowerOf2_32(L + 1)) {
      unsigned ShiftCount = Log2_32(L + 1);
      SDNode *srli = shiftRightLogicalImmediate(dl, CondRHS, ShiftCount);

      if (FalseValueC && F == 0)
        // If F == 0, use the result of SRLI/EXTUI as 0 to avoid
        // loading 0.
        FalseValue = SDValue(srli, 0);

      // Transform
      //   ((1 << C) - 1) < CondRHS ? T : F
      // to
      //   t = CondLHS >>u C
      //   t == 0 ? F : T
      //
      // Two instructions, with T and F already in a reg.
      // srli
      // movnez
      return CurDAG->SelectNodeTo(N, RISCV::XT_MOVNEZ, XLenVT,
                                  FalseValue,
                                  TrueValue,
                                  SDValue(srli,0));
    }

    if (CC == ISD::SETULT && CondRHSC && isPowerOf2_32(R)) {
      unsigned ShiftCount = Log2_32(R);
      SDNode *srli = shiftRightLogicalImmediate(dl, CondLHS, ShiftCount);

      if (TrueValueC && T == 0)
        // If T == 0, use the result of SRLI/EXTUI as 0 to avoid
        // loading 0.
        TrueValue = SDValue(srli, 0);

      // Transform
      //   CondLHS < (1 << C) ? T : F
      // to
      //   t = CondLHS >>u C
      //   t == 0 ? T : F
      //
      // Two instructions, with T and F already in a reg.
      // srli
      // movnez
      return CurDAG->SelectNodeTo(N, RISCV::XT_MOVNEZ, XLenVT,
                                  TrueValue,
                                  FalseValue,
                                  SDValue(srli,0));
    }

    if (FalseValueC && F == 0) {
      // Transform
      //   CondLHS < CondRHS ? 3 : 0
      // to
      //   (CondLHS < CondRHS) * 3
      // where the multiplication is done with ADDX[248]
      if (TrueValueC && (T == 3 || T == 5 || T == 9)) {
        unsigned addx_opcode = (T == 3 ? RISCV::SH1ADD :
                                T == 5 ? RISCV::SH2ADD :
                                RISCV::SH3ADD);
        SDNode *slt = CurDAG->getMachineNode(slt_opcode, dl,
                                             XLenVT, CondLHS, CondRHS);
        return CurDAG->SelectNodeTo(N, addx_opcode, XLenVT,
                                    SDValue(slt, 0),
                                    SDValue(slt, 0));
      }

      // Transform
      //   CondLHS < CondRHS ? -1 : 0
      // to
      //   -(CondLHS < CondRHS)
      if (TrueValueC && T == -1) {
        // Two instructions
        // slt/sltu
        // neg
        SDNode *slt = CurDAG->getMachineNode(slt_opcode, dl,
                                             XLenVT, CondLHS, CondRHS);
        SDValue ZeroReg = CurDAG->getRegister(RISCV::X0, XLenVT);
        return CurDAG->SelectNodeTo(N, RISCV::SUB, XLenVT,
                                    ZeroReg, SDValue(slt, 0));
      }

      // We do not have to handle:
      //
      //   CondLHS < CondRHS ? (1 << C) : 0
      //
      // here because the target-independent optimizer transforms
      // it to:
      //
      //   (CondLHS < CondRHS) << C

      // We do not have to handle:
      //
      //   CondLHS < 0 ? (1 << C) : 0
      //
      // here because the target-independent optimizer transforms it to:
      //
      //   (CondLHS >>u (31 - C)) & (1 << C)
      //
      // and a Pat in XtensaInstrInfo.td further transforms it to:
      //
      //   (CondLHS >>u 31) << C

      // Recognize CondLHS < CondRHS ? TrueValue : 0.
      {
        SDNode *slt = CurDAG->getMachineNode(slt_opcode, dl,
                                              XLenVT, CondLHS, CondRHS);
        return CurDAG->SelectNodeTo(N, RISCV::XT_MOVNEZ, MVT::i32,
                                    SDValue(slt, 0),
                                    TrueValue,
                                    SDValue(slt, 0));
      }
    }

    // Transform
    //   CondLHS < CondRHS ? N+1 : N
    // to
    //   (CondLHS < CondRHS) + N
    // if we can perform the addition with ADDI
    if (FalseValueC && TrueValueC &&
        F != 0 && (unsigned) F + 1 == (unsigned) T &&
        immADDI(F)) {
      // Two instructions
      // slt/sltu
      // addi
      SDNode *slt = CurDAG->getMachineNode(slt_opcode, dl,
                                           MVT::i32, CondLHS, CondRHS);
      return CurDAG->SelectNodeTo(N, RISCV::ADDI, MVT::i32,
                                  SDValue(slt, 0),
                                  getI32Imm(F, dl));
    }

    // Transform
    //   CondLHS < CondRHS ? N-1 : N
    // to
    //   N - (CondLHS < CondRHS)
    if (FalseValueC && TrueValueC &&
        F != 0 && (unsigned) T + 1 == (unsigned) F &&
        immMOVI(F)) {
      // Three instructions, with the tree height being 2
      // movi.n/movi
      // slt/sltu
      // sub
      SDNode *movi = movImmediate(dl, F);
      SDNode *slt = CurDAG->getMachineNode(slt_opcode, dl,
                                           XLenVT, CondLHS, CondRHS);
      return CurDAG->SelectNodeTo(N, RISCV::SUB, XLenVT,
                                  SDValue(movi, 0),
                                  SDValue(slt, 0));
    }

    // Transform
    //   CondLHS < CondRHS ? N+{2,4,8} : N
    // to
    //   N + (CondLHS < CondRHS) * {2,4,8}
    if (FalseValueC && TrueValueC && F != 0 && immMOVI(F)) {
      unsigned addx_opcode = RISCV::NOP; // Something other than a MOVI.

      // Pick an opcode for the immediate.
      if ((unsigned) F + 2 == (unsigned) T)
        addx_opcode = RISCV::SH1ADD;
      else if ((unsigned) F + 4 == (unsigned) T)
        addx_opcode = RISCV::SH2ADD;
      else if ((unsigned) F + 8 == (unsigned) T)
        addx_opcode = RISCV::SH3ADD;

      if (addx_opcode != RISCV::NOP) {
        // Three instructions, with the tree height being 2
        // movi.n/movi
        // slt/sltu
        // addx2/4/8
        SDNode *movi = movImmediate(dl, F);
        SDNode *slt = CurDAG->getMachineNode(slt_opcode, dl,
                                             XLenVT, CondLHS, CondRHS);
        return CurDAG->SelectNodeTo(N, addx_opcode, XLenVT,
                                    SDValue(slt, 0), SDValue(movi, 0));
      }
    }

    // Recognize CondLHS < CondRHS ? TrueValue : FalseValue.
    // Two instructions, assuming T and F are in regs
    // slt/sltu
    // movnez
    SDNode *slt = CurDAG->getMachineNode(slt_opcode, dl,
                                         XLenVT, CondLHS, CondRHS);
    return CurDAG->SelectNodeTo(N, RISCV::XT_MOVNEZ, XLenVT,
                                FalseValue,
                                TrueValue,
                                SDValue(slt, 0));
    break;
  }

  default:
    break;
  }

  return nullptr;
}

SDNode *RISCVDAGToDAGISel::SelectImmBeforeSHL(SDNode *N) {
  MVT XLenVT = Subtarget->getXLenVT();
  if (N->getValueType(0) != XLenVT)
    return nullptr;

  unsigned Opc = N->getOpcode();
  assert((Opc == ISD::ADD || Opc == ISD::OR || Opc == ISD::XOR) &&
         "Wrong opcode");
  SDLoc dl(N);
  SDValue N0 = N->getOperand(0);
  SDValue N1 = N->getOperand(1);

  if (N0->getValueType(0) != XLenVT || N1->getValueType(0) != XLenVT)
    return nullptr;

  // Transform (x << C1) + C2 to (x + C3) << C1 if doing so allows us
  // to add C3 in a cheaper way.
  if (N0->hasOneUse() && N0->getOpcode() == ISD::SHL) {
    ConstantSDNode *ShiftCntN = dyn_cast<ConstantSDNode>(N0->getOperand(1));
    ConstantSDNode *AddendN = dyn_cast<ConstantSDNode>(N1);

    if (ShiftCntN != nullptr && AddendN != nullptr) {
      uint32_t ShiftCnt = ShiftCntN->getZExtValue();
      int64_t Addend = AddendN->getSExtValue();
      if (!isInt<12>(Addend)) {
        // Check that Addend can be added before shifting.
        if ((Addend & ((1 << ShiftCnt) - 1)) == 0) {
          int64_t NewImm = Addend >> ShiftCnt;
          if (isInt<12>(NewImm)) {
            unsigned Opcode;
            switch (N->getOpcode()) {
            case ISD::ADD:
              Opcode = RISCV::ADDI;
              break;
            case ISD::OR:
              Opcode = RISCV::ORI;
              break;
            case ISD::XOR:
              Opcode = RISCV::XORI;
              break;
            default:
              llvm_unreachable("Unexpected opcode");
            }
            SDNode *OpImm = CurDAG->getMachineNode(
                Opcode, dl, XLenVT, N0->getOperand(0), getI32Imm(NewImm, dl));
            return CurDAG->SelectNodeTo(N, RISCV::SLLI, XLenVT,
                                        SDValue(OpImm, 0),
                                        getI32Imm(ShiftCnt, dl));
          }
        }
      }
    }
  }

  return nullptr;
}
#endif

// Merge an ADDI into the offset of a load/store instruction where possible.
// (load (add base, off), 0) -> (load base, off)
// (store val, (add base, off)) -> (store val, base, off)
void RISCVDAGToDAGISel::doPeepholeLoadStoreADDI() {
  SelectionDAG::allnodes_iterator Position(CurDAG->getRoot().getNode());
  ++Position;

  while (Position != CurDAG->allnodes_begin()) {
    SDNode *N = &*--Position;
    // Skip dead nodes and any non-machine opcodes.
    if (N->use_empty() || !N->isMachineOpcode())
      continue;

    int OffsetOpIdx;
    int BaseOpIdx;

    // Only attempt this optimisation for I-type loads and S-type stores.
    switch (N->getMachineOpcode()) {
    default:
      continue;
    case RISCV::LB:
    case RISCV::LH:
    case RISCV::LW:
    case RISCV::LBU:
    case RISCV::LHU:
    case RISCV::LWU:
    case RISCV::LD:
    case RISCV::FLW:
    case RISCV::FLD:
      BaseOpIdx = 0;
      OffsetOpIdx = 1;
      break;
    case RISCV::SB:
    case RISCV::SH:
    case RISCV::SW:
    case RISCV::SD:
    case RISCV::FSW:
    case RISCV::FSD:
      BaseOpIdx = 1;
      OffsetOpIdx = 2;
      break;
    }

    // Currently, the load/store offset must be 0 to be considered for this
    // peephole optimisation.
    if (!isa<ConstantSDNode>(N->getOperand(OffsetOpIdx)) ||
        N->getConstantOperandVal(OffsetOpIdx) != 0)
      continue;

    SDValue Base = N->getOperand(BaseOpIdx);

    // If the base is an ADDI, we can merge it in to the load/store.
    if (!Base.isMachineOpcode() || Base.getMachineOpcode() != RISCV::ADDI)
      continue;

    SDValue ImmOperand = Base.getOperand(1);

    if (auto Const = dyn_cast<ConstantSDNode>(ImmOperand)) {
      ImmOperand = CurDAG->getTargetConstant(
          Const->getSExtValue(), SDLoc(ImmOperand), ImmOperand.getValueType());
    } else if (auto GA = dyn_cast<GlobalAddressSDNode>(ImmOperand)) {
      ImmOperand = CurDAG->getTargetGlobalAddress(
          GA->getGlobal(), SDLoc(ImmOperand), ImmOperand.getValueType(),
          GA->getOffset(), GA->getTargetFlags());
    } else {
      continue;
    }

    LLVM_DEBUG(dbgs() << "Folding add-immediate into mem-op:\nBase:    ");
    LLVM_DEBUG(Base->dump(CurDAG));
    LLVM_DEBUG(dbgs() << "\nN: ");
    LLVM_DEBUG(N->dump(CurDAG));
    LLVM_DEBUG(dbgs() << "\n");

    // Modify the offset operand of the load/store.
    if (BaseOpIdx == 0) // Load
      CurDAG->UpdateNodeOperands(N, Base.getOperand(0), ImmOperand,
                                 N->getOperand(2));
    else // Store
      CurDAG->UpdateNodeOperands(N, N->getOperand(0), Base.getOperand(0),
                                 ImmOperand, N->getOperand(3));

    // The add-immediate may now be dead, in which case remove it.
    if (Base.getNode()->use_empty())
      CurDAG->RemoveDeadNode(Base.getNode());
  }
}

// This pass converts a legalized DAG into a RISCV-specific DAG, ready
// for instruction scheduling.
#if defined(TENSILICA) || 1
FunctionPass *llvm::createRISCVISelDag(RISCVTargetMachine &TM,
                                       CodeGenOpt::Level OptLevel) {
  return new RISCVDAGToDAGISel(TM, OptLevel);
}
#else
FunctionPass *llvm::createRISCVISelDag(RISCVTargetMachine &TM) {
  return new RISCVDAGToDAGISel(TM);
}
#endif
