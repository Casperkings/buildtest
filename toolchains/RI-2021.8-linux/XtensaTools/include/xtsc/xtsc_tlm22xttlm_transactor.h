#ifndef _XTSC_TLM22XTTLM_TRANSACTOR_H_
#define _XTSC_TLM22XTTLM_TRANSACTOR_H_

// Copyright (c) 2006-2019 by Cadence Design Systems, Inc.  ALL RIGHTS RESERVED.
// These coded instructions, statements, and computer programs are the
// copyrighted works and confidential proprietary information of
// Cadence Design Systems, Inc.  They may be adapted and modified by bona fide
// purchasers for internal use, but neither the original nor any adapted
// or modified version may be disclosed or distributed to third parties
// in any manner, medium, or form, in whole or in part, without the prior
// written consent of Cadence Design Systems, Inc.

/**
 * @file 
 */


#include <tlm.h>
#if defined(MTI_SYSTEMC)
#include <peq_with_get.h>
#else
#include <tlm_utils/peq_with_get.h>
#endif
#include <xtsc/xtsc.h>
#include <xtsc/xtsc_parms.h>
#include <xtsc/xtsc_request_if.h>
#include <xtsc/xtsc_request.h>
#include <xtsc/xtsc_respond_if.h>
#include <xtsc/xtsc_response.h>
#include <xtsc/xtsc_fast_access.h>
#include <deque>
#include <vector>
#include <list>
#include <cstring>



namespace xtsc {
// Forward references
class xtsc_core;
};



namespace xtsc_component {


// Forward references
class xtsc_master_tlm2;
class xtsc_xttlm2tlm2_transactor;


/**
 * Constructor parameters for a xtsc_tlm22xttlm_transactor object.
 *
 *  \verbatim
   Name                  Type   Description
   ------------------    ----   --------------------------------------------------------
  
   "num_ports"            u32   The number of TLM2 initiator sockets this transactor has
                                as well as the number of Xtensa TLM (xttlm) port pairs
                                this transactor has.
                                Default = 1.
                                Minimum = 1.

   "byte_width"          u32    Bus width in bytes.  Valid values are 4, 8, 16, 32, and
                                64.  When "apb" is true "byte_width" must be 4.  If
                                byte_width is greater than 32 then "use_pif_block" and
                                "use_pif_burst" are ignored.

   "enable_extensions"   bool   If true, this transactor checks for the presence of   
                                ignorable extensions in the TLM2 payload to set additional
                                attributes in outboud PIF/AXI xttlm requests. The 
                                attributes that are currently supported are :
                                xtsc_request's transaction_id. These extensions are mostly 
                                set by an upstream xtsc_xttlm2tlm2_transactor (with 
                                enable_extensions = true).
                                Default = false. 
                               
   "exclusive_support"   u32    This parameter specifies how the model should support
                                exclusive requests.  It cannot be used if "apb" is set.
                                The legal values and their meaning are:
                                0 = Not supported.
                                1 = Supported with TLM2 ignorabled extensions. This 
                                    option requires that the upstream model has the 
                                    support for these same TLM2 extensions as used by
                                    this transactor. Otherwise this transactor would 
                                    interpret the exclusive transaction as a non-
                                    exclusive transaction.
                                Default = 0.
  
   "priority"            u32    The PIF/AXI priority of requests.  Not used for APB.
                                Default = 3 (highest PIF priority).

   "pc"                  u32    The pc to use for xtsc_request objects.
                                Default = 0xFFFFFFFF.

   "apb"                 bool   If true, then xtsc::xtsc_request objects will be created
                                with their apb argument set true and a type of READ or
                                WRITE.  Note: "apb" and "axi" cannot both be true.
                                Default = false.

   "axi"                 bool   If true, then xtsc::xtsc_request objects will be used
                                with a xtsc::xtsc_request::burst_t of INCR and, in some
                                cases, FIXED (WRAP is never generated by this model).
                                If false, then xtsc_request objects with burst_t of
                                NON_AXI will be used (suitable for PIF, APB, or Xtensa
                                local memory interfaces).
                                Note: "apb" and "axi" cannot both be true.
                                Default = false.

   "use_axi_fixed"       bool   If true, then xtsc::xtsc_request::burst_t of FIXED
                                bursts will be used whenever a single TLM2 transaction
                                has a streaming width attribute value that is less than
                                data width and that is also less than or equal to bus
                                width ("byte_width") and that requires no more than 16
                                beats.  This parameter is ignored if "axi" is false.
                                Default = true.

   "use_pif_block"       bool   If true, then a TLM2 burst transfer transaction will be
                                mapped to a PIF BLOCK_READ|BLOCK_WRITE transaction if 
                                it is possible to do so  based on the attributes of the
                                TLM2 payload. This parameter is ignored if "apb" or 
                                "axi" is true or if "byte_width" is greater than 32.
                                Default = true.

   Note: A TLM2 transaction is considered a burst transfer transaction if the generic
         payload data length attribute is greater then the BUSWIDTH template parameter
         of the socket.

   "use_pif_burst"       bool   If true, then a TLM2 burst transfer transaction will be
                                mapped to a PIF BURST_READ|BURST_WRITE transaction if 
                                it is possible to do so based on the attributes of the
                                TLM2 payload. The transactor first checks if a TLM2  
                                transaction can be mapped into PIF BLOCK_READ|
                                BLOCK_WRITE. If it can't and this parameter is enabled 
                                then the transaction is converted into BURST* 
                                transaction. If this initial check for PIF 
                                BLOCK_READ|BLOCK_WRITE is to be disabled, set 
                                "use_pif_block" to false. This parameter is ignored if 
                                "apb" or "axi" is true or if "byte_width" is greater 
                                than 16.
                                Default = false.

   "max_burst_beats"     u32    If "use_pif_burst" is true, then this specifies the
                                maximum number of transfers (beats) that will be used
                                for PIF BURST_READ or BURST_WRITE transactions.  The
                                original PIF Protocol 3.1 allowed up to 8 transfers.
                                The enhanced PIF burst of Xtensa iDMA hardware in
                                RG-2017.8 and later allowed up to 16 transfers.
                                Default = 8.

   "allow_dmi"           bool   If true, this transactor will attempt to get raw access 
                                to the downstream memory using nb_fast_access in order
                                to support DMI.  If false, no attempt will be made to
                                support DMI.  Even if this parameter is true, DMI can
                                not be supported if the downstream memory does not
                                support raw fast access.
                                Default = true.

   "allow_transport_dbg" bool   If true, this transactor will translate transport_dbg
                                calls to nb_peek/nb_poke calls.  If false, this
                                transactor will return 0 to all transport_dbg calls.
                                This setting can be change during simulation using
                                the allow_transport_dbg() method and the
                                "allow_transport_dbg" command.
                                Default = true.

   "clock_period"        u32    This is the length of this transactor's clock period
                                expressed in terms of the SystemC time resolution
                                (from sc_get_time_resolution()).  A value of 
                                0xFFFFFFFF means to use the XTSC system clock period
                                (from xtsc_get_system_clock_period()).  A value of 0
                                means one delta cycle.
                                Default = 0xFFFFFFFF (i.e. use the system clock period).

   "split_tlm2_phases"   bool   If set to true, the transactor allows accepting and 
                                sending TLM2 transaction's data beats individually, as 
                                soon as they are available using additional phases. 
                                The transactormakes use of TLM2 ignorable phases but 
                                they are not really ignorable, because they expect the 
                                initiator to update the phase to next stage, ie return 
                                TLM_UPDATED rather than just just TLM_ACCEPTED. This 
                                handshake between the transactor and initiator tlm2 model 
                                is required to control the flow of data, similar to 
                                RSP_NACC in PIF or AxREADY in AXI. This parameter provides 
                                more timing accuracy but must ONLY BE ENABLED IF the 
                                upstream TLM2 initiator is able to comprehend and respond 
                                to these additional phases. Advancing transaction with 
                                TLM_COMPLETED when the request is flowing through different
                                stages is forbidded. For different transfers, the same TLM2 
                                generic payload is used and data is placed at its respective
                                index in the payload. The data_length in payload at any time 
                                is the total length of bytes transferred.
                                The additional phases added are (in pair) :
                                BEGIN_WDATA, END_WDATA : 
                                Phases to indicate the start and end of each individual 
                                non-last write data transfer. BEGIN_REQ, END_REQ in this case 
                                are merely used to indicate the start and end of address phase. 
                                BEGIN_WDATA for the first data beat will mostly have similar 
                                payload and timing as what was sent with BEGIN_REQ. BEGIN_WDATA  
                                should however be only received after sending END_REQ.
                                This transactor will update the phase to END_WDATA for received 
                                BEGIN_WDATA phase.
                                BEGIN_WDATA_LAST, END_WDATA_LAST :
                                Phases to send and accept the last write data transfer in a 
                                write  request.
                                BEGIN_RDATA, END_RDATA :
                                Phases to receive the indvidual non-last read response 
                                transfers from the target TLM2 model. This transactor responds 
                                with END_RDATA, to each BEGIN_RDATA received from the target. 
                                The last read response beat is sent through BEGIN_RESP, 
                                END_RESP pair.
                                
                                Default = false.

    \endverbatim
 *
 * @see xtsc_tlm22xttlm_transactor
 * @see xtsc::xtsc_parms
 */
class XTSC_COMP_API xtsc_tlm22xttlm_transactor_parms : public xtsc::xtsc_parms {
public:

  /**
   * Constructor for an xtsc_tlm22xttlm_transactor_parms object.
   *
   * @param width8              Memory data bus width in bytes.
   *
   * @param num_ports           The number of ports this transactor has.
   *
   */
  xtsc_tlm22xttlm_transactor_parms(xtsc::u32 width8 = 4, xtsc::u32 num_ports = 1) {
    init(width8, num_ports);
  }


  /**
   * Do initialization common to both constructors.
   */
  void init(xtsc::u32 width8 = 4, xtsc::u32 num_ports = 1) {
    add("byte_width",           width8);
    add("enable_extensions",    false);
    add("exclusive_support",    0);                        
    add("num_ports",            num_ports);
    add("priority",             3);
    add("pc",                   0xFFFFFFFF);
    add("apb",                  false);
    add("axi",                  false);
    add("use_axi_fixed",        true);
    add("use_pif_block",        true);
    add("use_pif_burst",        false);
    add("max_burst_beats",      8);
    add("allow_dmi",            true);
    add("allow_transport_dbg",  true);
    add("clock_period",         0xFFFFFFFF);
    add("split_tlm2_phases",    false);    
  }


  /// Return what kind of xtsc_parms this is (our C++ type)
  virtual const char* kind() const { return "xtsc_tlm22xttlm_transactor_parms"; }

};





/**
 * Example module implementing an OSCI TLM2 to Xtensa TLM (xttlm) transactor.
 *
 * This module can be used to connect an OSCI TLM2 memory interface master (for example,
 * xtsc_master_tlm2) to an Xtensa TLM memory interface slave (for example, the inbound
 * PIF of xtsc::xtsc_core).
 *
 * For protocol and timing information specific to xtsc_core and the Xtensa ISS, see
 * xtsc::xtsc_core::Information_on_memory_interface_protocols.
 *
 * Here is a block diagram of an xtsc_tlm22xttlm_transactor being used in the
 * xtsc_tlm22xttlm_transactor example:
 * @image html  Example_xtsc_tlm22xttlm_transactor.jpg
 * @image latex Example_xtsc_tlm22xttlm_transactor.eps "xtsc_tlm22xttlm_transactor Example" width=10cm
 *
 * @see xtsc_tlm22xttlm_transactor_parms
 * @see xtsc::xtsc_request
 * @see xtsc::xtsc_response
 * @see xtsc::xtsc_request_if
 * @see xtsc::xtsc_respond_if
 * @see xtsc::xtsc_core
 * @see xtsc::xtsc_core::Information_on_memory_interface_protocols.
 * @see xtsc_master_tlm2
 * @see xtsc_xttlm2tlm2_transactor
 */
class XTSC_COMP_API xtsc_tlm22xttlm_transactor : public sc_core::sc_module, public xtsc::xtsc_module, public xtsc::xtsc_command_handler_interface {
public:


  // Shorthand aliases
  typedef tlm::tlm_target_socket< 32> target_socket_4;  ///< target socket with BUSWIDTH =  32 bits ( 4 bytes)
  typedef tlm::tlm_target_socket< 64> target_socket_8;  ///< target socket with BUSWIDTH =  64 bits ( 8 bytes)
  typedef tlm::tlm_target_socket<128> target_socket_16; ///< target socket with BUSWIDTH = 128 bits (16 bytes)
  typedef tlm::tlm_target_socket<256> target_socket_32; ///< target socket with BUSWIDTH = 256 bits (32 bytes)
  typedef tlm::tlm_target_socket<512> target_socket_64; ///< target socket with BUSWIDTH = 512 bits (64 bytes)


  // The system builder (e.g. sc_main) uses one of the following methods to get a target socket for binding

  /// Get a reference to a target socket with a 4-byte data interface
  target_socket_4& get_target_socket_4(xtsc::u32 port_num = 0);

  /// Get a reference to a target socket with a 8-byte data interface
  target_socket_8& get_target_socket_8(xtsc::u32 port_num = 0);

  /// Get a reference to a target socket with a 16-byte data interface
  target_socket_16& get_target_socket_16(xtsc::u32 port_num = 0);

  /// Get a reference to a target socket with a 32-byte data interface
  target_socket_32& get_target_socket_32(xtsc::u32 port_num = 0);

  /// Get a reference to a target socket with a 64-byte data interface
  target_socket_64& get_target_socket_64(xtsc::u32 port_num = 0);


  sc_core::sc_port  <xtsc::xtsc_request_if>   **m_request_ports;        ///<  From us to downstream slave(s)
  sc_core::sc_export<xtsc::xtsc_respond_if>   **m_respond_exports;      ///<  From downstream slave(s) to us


  // For SystemC
  SC_HAS_PROCESS(xtsc_tlm22xttlm_transactor);

  /// Our C++ type (SystemC uses this)
  virtual const char* kind() const { return "xtsc_tlm22xttlm_transactor"; }


  /**
   * Constructor for an xtsc_tlm22xttlm_transactor.
   * @param     module_name             Name of the xtsc_tlm22xttlm_transactor sc_module.
   * @param     transactor_parms        The remaining parameters for construction.
   * @see xtsc_tlm22xttlm_transactor_parms
   */
  xtsc_tlm22xttlm_transactor(sc_core::sc_module_name module_name, const xtsc_tlm22xttlm_transactor_parms& transactor_parms);


  // Destructor.
  ~xtsc_tlm22xttlm_transactor(void);


  /// For xtsc_connection_interface
  virtual xtsc::u32 get_bit_width(const std::string& port_name, xtsc::u32 interface_num = 0) const;


  /// For xtsc_connection_interface
  virtual sc_core::sc_object *get_port(const std::string& port_name);


  /// For xtsc_connection_interface
  virtual xtsc::xtsc_port_table get_port_table(const std::string& port_table_name) const;


  /// Get the number of memory ports this device has
  xtsc::u32 get_num_ports() { return m_num_ports; }


  /// Return byte width of data interface (from "byte_width" parameter)
  xtsc::u32 get_byte_width() const { return m_width8; }


  /**
   * Method to allow/disallow transport_dbg().
   *
   * @param     allow           If true, tranport_dbg() calls will be allowed.  If false,
   *                            transport_dbg() calls will return 0.
   *
   * @returns the previous setting.
   *
   * @see "allow_transport_dbg" in xtsc_tlm22xttlm_transactor_parms.
   */
  bool allow_transport_dbg(bool allow);


  /**
   * Method to change the clock period.
   *
   * @param     clock_period_factor     Specifies the new length of this device's clock
   *                                    period expressed in terms of the SystemC time
   *                                    resolution (from sc_get_time_resolution()).
   */
  void change_clock_period(xtsc::u32 clock_period_factor);


  /**
   * Implementation of the xtsc::xtsc_command_handler_interface.
   *
   * This implementation supports the following commands:
   *  \verbatim
        allow_transport_dbg <Allow>
          Call xtsc_tlm22xttlm_transactor::allow_transport_dbg(<Allow>).  Where <Allow> is 0|1.
          Return previous <Allow> value for this device.

        change_clock_period <ClockPeriodFactor>
          Call xtsc_tlm22xttlm_transactor::change_clock_period(<ClockPeriodFactor>).
          Return previous <ClockPeriodFactor> for this device.
      \endverbatim
   */
  void execute(const std::string&               cmd_line,
               const std::vector<std::string>&  words,
               const std::vector<std::string>&  words_lc,
               std::ostream&                    result);


  /**
   * Connect this xtsc_tlm22xttlm_transactor to an xtsc_core.
   *
   * This method connects the specified Xtensa TLM master port pair of this
   * xtsc_tlm22xttlm_transactor to the inbound PIF slave port pair of the specified
   * xtsc_core.
   *
   * @param     core                    The xtsc_core to connect with this
   *                                    xtsc_tlm22xttlm_transactor.
   *
   * @param     tlm22xttlm_port         The master port pair of this
   *                                    xtsc_tlm22xttlm_transactor to connect with
   *                                    the inbound PIF interface of core.
   *
   */
  void connect(xtsc::xtsc_core& core, xtsc::u32 tlm22xttlm_port = 0);


  /**
   * Connect an xtsc_master_tlm2 to this xtsc_tlm22xttlm_transactor.
   *
   * This method connects the specified xtsc_master_tlm2 to the specified target socket
   * of this xtsc_tlm22xttlm_transactor.
   *
   * @param     master_tlm2             The xtsc_master_tlm2 to connect to this
   *                                    xtsc_tlm22xttlm_transactor.
   *
   * @param     target_socket           The target socket of this transactor to connect
   *                                    the initiator socket of master_tlm2 to.
   */
  void connect(xtsc_master_tlm2& master_tlm2, xtsc::u32 target_socket);


  /**
   * Connect an xtsc_xttlm2tlm2_transactor transactor to this
   * xtsc_tlm22xttlm_transactor transactor.
   *
   * This method connects the specified TLM2 initiator socket of an upstream
   * xtsc_xttlm2tlm2_transactor to the specified TLM2 target socket of this
   * xtsc_tlm22xttlm_transactor.
   *
   * @param     xttlm2tlm2         The xtsc_xttlm2tlm2_transactor to connect to this
   *                               xtsc_tlm22xttlm_transactor.
   *
   * @param     initiator_socket   The initiator socket of xttlm2tlm2 to connect to this
   *                               xtsc_tlm22xttlm_transactor.
   *
   * @param     target_socket      The target socket of this transactor to connect the 
   *                               initiator socket of xttlm2tlm2 to.
   *
   * @param     single_connect     If true only one socket of this transactor will be
   *                               connected.  If false, the default, then all
   *                               contiguous, unconnected socket numbers of this
   *                               transactor starting at target_socket that have a
   *                               corresponding existing socket in xttlm2tlm2 (starting
   *                               at initiator_socket) will be connected to that
   *                               corresponding socket in xttlm2tlm2.
   *
   * NOTE:  This method is just for special testing purposes.  In general, connecting a
   *        xtsc_xttlm2tlm2_transactor to a xtsc_tlm22xttlm_transactor is not
   *        guarranteed to meet timing requirements.
   *
   * @returns number of sockets that were connected by this call (1 or more)
   */
  xtsc::u32 connect(xtsc_xttlm2tlm2_transactor&     xttlm2tlm2,
                    xtsc::u32                       initiator_socket = 0,
                    xtsc::u32                       target_socket    = 0,
                    bool                            single_connect   = false);


  /**
   * Reset the transactor.
   */
  void reset(bool hard_reset = false);


  /// Get the TextLogger for this component (e.g. to adjust its log level)
  log4xtensa::TextLogger& get_text_logger() { return m_text; }


private:

  /// Perform validation for the get_intiator_socket_BW() methods
  void validate_port_and_width(xtsc::u32 port_num, xtsc::u32 width8);


  /**
   * Information about each transaction.
   */
  class transaction_info {
  public:

    /// Constructor for a new transaction_info
    transaction_info(xtsc_tlm22xttlm_transactor& transactor, tlm::tlm_generic_payload *p_gp, bool blocking, xtsc::u32 port_num) :
      m_transactor      (transactor),
      m_blocking        (blocking),
      m_port_num        (port_num)
    { init(p_gp, blocking, port_num); }

    /// Initialize an already existing transaction_info object
    void init(tlm::tlm_generic_payload *p_gp, bool blocking, xtsc::u32 port_num);

    /// Finialize a transaction_info object
    void fini();


    xtsc_tlm22xttlm_transactor&         m_transactor;           ///<  Our xtsc_tlm22xttlm_transactor object
    bool                                m_blocking;             ///<  True if transaction came in on b_transport, false if nb_transport_fw
    xtsc::u32                           m_port_num;             ///<  Which port transaction came in on
    tlm::tlm_generic_payload           *m_p_gp;                 ///<  The original TLM2 transaction
    std::vector<xtsc::xtsc_request*>    m_requests;             ///<  The sequence of xtsc_request objects corresponding to the TLM2 trans
    std::vector<xtsc::u32>              m_read_data_offsets;    ///<  Offset where read data of corresponding request should be copied to
                                                                ///<  (byte enables from m_p_gp must still be applied)
    std::vector<xtsc::u32>              m_read_data_sizes;      ///<  Number of bytes each response to corresponding request should have
    xtsc::u32                           m_pending_last_rsps;    ///<  Number of last_transfer responses still outstanding
    xtsc::u32                           m_write_requests_rcvd;  ///<  Number of write requests transfers rcvd. Used when split_tlm2_phases is true
    xtsc::u32                           m_requests_sent;        ///<  Number of requests transfers sent. Used when split_tlm2_phases is true
    xtsc::u64                           m_requests_tag;         ///<  tag of requests sent out. Used when split_tlm2_phases is true
    tlm::tlm_phase                      m_phase;                ///<  TLM2 phase this transaction is in
    bool                                m_all_requests_sent;    ///<  Set to true when all xtsc_request's have been sent and accepted
  };


  /// Get a new transaction object (from the pool)
  transaction_info *new_transaction_info(tlm::tlm_generic_payload *p_gp, bool blocking, xtsc::u32 port_num);


  /// Delete a transaction_info (return it to the pool)
  void delete_transaction_info(transaction_info*& p_transaction_info);


  /// Get a new xtsc_request (from the pool) 
  xtsc::xtsc_request *new_request();


  /// Delete an xtsc_request (return it to the pool)
  void delete_request(xtsc::xtsc_request*& p_request);


  /// Helper method for b_transport and nb_transport_fw (via nb_thread)
  bool transport_helper(tlm::tlm_generic_payload& trans, sc_core::sc_time& t, bool blocking, xtsc::u32 port_num);


  /// Implementation of xtsc_respond_if.
  class xtsc_respond_if_impl : public xtsc::xtsc_respond_if, public sc_core::sc_object {
  public:

    /// Constructor
    xtsc_respond_if_impl(const char *object_name, xtsc_tlm22xttlm_transactor& transactor, xtsc::u32 port_num) :
      sc_object         (object_name),
      m_transactor      (transactor),
      m_port_num        (port_num),
      m_p_port          (0)
    {}

    /// The kind of sc_object we are
    const char* kind() const { return "xtsc_tlm22xttlm_transactor::xtsc_respond_if_impl"; }

    /// From downstream slave
    /// @see xtsc::xtsc_respond_if
    bool nb_respond(const xtsc::xtsc_response& response);

    /// Return true if a port has been bound to this implementation
    bool is_connected() { return (m_p_port != 0); }

  protected:

    /// SystemC callback when something binds to us
    virtual void register_port(sc_core::sc_port_base& port, const char *if_typename);

    xtsc_tlm22xttlm_transactor& m_transactor;   ///<  Our xtsc_tlm22xttlm_transactor object
    xtsc::u32                   m_port_num;     ///<  Our port number
    sc_core::sc_port_base      *m_p_port;       ///<  Port that is bound to us
  };


  /// Implementation of tlm_fw_transport_if<>
  class tlm_fw_transport_if_impl : public tlm::tlm_fw_transport_if<>, public sc_core::sc_object {
  public:

    /**
     * Constructor.
     * @param   transactor  A reference to the owning xtsc_tlm22xttlm_transactor object.
     * @param   port_num    The port number that this object serves.
     */
    tlm_fw_transport_if_impl(const char *object_name, xtsc_tlm22xttlm_transactor& transactor, xtsc::u32 port_num) :
      sc_object         (object_name),
      m_transactor      (transactor),
      m_width8          (m_transactor.m_width8),
      m_p_port          (0),
      m_port_num        (port_num)
    {}


    virtual tlm::tlm_sync_enum  nb_transport_fw    (tlm::tlm_generic_payload& trans, tlm::tlm_phase& phase, sc_core::sc_time& t);
    virtual void                b_transport        (tlm::tlm_generic_payload& trans, sc_core::sc_time& t);
    virtual bool                get_direct_mem_ptr (tlm::tlm_generic_payload& trans, tlm::tlm_dmi& dmi_data);
    virtual xtsc::u32           transport_dbg      (tlm::tlm_generic_payload& trans);


    /// Return true if a port has bound to this implementation
    bool is_connected() { return (m_p_port != 0); }


  protected:

    /// SystemC callback when something binds to us
    virtual void register_port(sc_core::sc_port_base& port, const char *if_typename);

    xtsc_tlm22xttlm_transactor& m_transactor;   ///<  Our xtsc_tlm22xttlm_transactor object
    xtsc::u32                   m_width8;       ///<  The bus width in bytes.  See "byte_width"
    sc_core::sc_port_base      *m_p_port;       ///<  Port that is bound to us
    xtsc::u32                   m_port_num;     ///<  Our port number
  };



  /// Class to keep track of address ranges and what DMI access has been granted/invalidated
  class address_range {
  public:
    address_range(xtsc::xtsc_address beg_range, xtsc::xtsc_address end_range) :
      m_beg_range       (beg_range),
      m_end_range       (end_range)
    {}

    xtsc::xtsc_address  m_beg_range;            ///<  Beginning address of the range
    xtsc::xtsc_address  m_end_range;            ///<  End address of the range
  };


  /// Check for the presence of extensions for exclusive access
  bool check_exclusive(tlm::tlm_generic_payload& trans, xtsc::u32 port_num);


  /// Common method to compute/re-compute time delays
  virtual void compute_delays();


  /// Handle incoming requests from each master (one per port)
  void worker_thread(void);


  /// Handle nb_transport_fw (one per port)
  void nb_thread(void);


  /// Common method for sending a response to transaction that came in on nb_transport_fw
  void respond_helper(transaction_info *p_transaction_info);


  typedef tlm_utils::peq_with_get<tlm::tlm_generic_payload> peq;

  // m_target_sockets_BW (BW = Byte width of data interface = BUSWIDTH/8)
  target_socket_4                             **m_target_sockets_4;             ///<  Initiator socket(s) for  4-byte interface
  target_socket_8                             **m_target_sockets_8;             ///<  Initiator socket(s) for  8-byte interface
  target_socket_16                            **m_target_sockets_16;            ///<  Initiator socket(s) for 16-byte interface
  target_socket_32                            **m_target_sockets_32;            ///<  Initiator socket(s) for 32-byte interface
  target_socket_64                            **m_target_sockets_64;            ///<  Initiator socket(s) for 64-byte interface

  xtsc_respond_if_impl                        **m_xtsc_respond_if_impl;         ///<  m_respond_exports bind to these
  tlm_fw_transport_if_impl                    **m_tlm_fw_transport_if_impl;     ///<  m_target_sockets binds to these

  xtsc::u32                                     m_next_port_num_worker;         ///<  Used by worker_thread to get its port number
  xtsc::u32                                     m_next_port_num_nb_thread;      ///<  Used by nb_thread to get its port number
  xtsc::u32                                     m_num_ports;                    ///<  See the "num_ports" parameter
  xtsc::u32                                     m_width8;                       ///<  See the "byte_width" parameter
  bool                                          m_enable_extensions;            ///<  See the "enable_extensions" parameter
  xtsc::u32                                     m_exclusive_support;            ///<  See the "exclusive_support" parameter
  xtsc::u32                                     m_priority;                     ///<  See the "priority" parameter
  xtsc::u32                                     m_pc;                           ///<  See the "pc" parameter
  xtsc::u32                                     m_max_burst_beats;              ///<  See the "max_burst_beats" parameter
  bool                                          m_apb;                          ///<  See the "apb" parameter
  bool                                          m_axi;                          ///<  See the "axi" parameter
  bool                                          m_use_axi_fixed;                ///<  See the "use_axi_fixed" parameter
  bool                                          m_use_pif_block;                ///<  See the "use_pif_block" parameter
  bool                                          m_use_pif_burst;                ///<  See the "use_pif_burst" parameter
  bool                                          m_allow_dmi;                    ///<  See the "allow_dmi" parameter
  bool                                          m_allow_transport_dbg;          ///<  See the "allow_transport_dbg" parameter, command, and method.
  bool                                          m_split_tlm2_phases;            ///<  See "split_tlm2_phases" parameter
  xtsc::u64                                     m_clock_period_value;           ///<  Clock period as u64
  sc_core::sc_time                              m_time_resolution;              ///<  SystemC time resolution
  sc_core::sc_time                              m_clock_period;                 ///<  This transactor's clock period
  sc_core::sc_event                           **m_worker_thread_event;          ///<  To notify worker_thread when transaction is accepted
  sc_core::sc_event                           **m_port_done_event;              ///<  To notify b_transport that response is complete (per port)
  peq                                         **m_peq;                          ///<  For nb_transport_fw/nb_thread (per port)
  bool                                         *m_waiting_for_nacc;             ///<  True if waiting for RSP_NACC from slave
  bool                                         *m_request_got_nacc;             ///<  True if request got RSP_NACC from slave
  bool                                         *m_waiting_for_end_resp;         ///<  Wait for END_RSP from TLM2 initiator(per port)
  xtsc::u8                                     *m_next_id;                      ///<  Next potentially available PIF ID (per port)
  xtsc::u32                                    *m_outstanding_req_count;        ///<  Outstanding request count on a port
  std::map<xtsc::u64,transaction_info*>        *m_tag_to_transaction_info_tab;  ///<  Map tag to transaction info 
  std::map<xtsc::u64,int>                      *m_tag_to_request_tab;           ///<  Map tag to req entry in m_requests 
  std::map<tlm::tlm_generic_payload*, 
                transaction_info*>             *m_trans_to_info_map;            ///<  Map tlm2 gp to transaction_info structure
  std::deque<transaction_info*>               **m_pending_transaction_deque;    ///<  Hold pending transaction_info objects 
  std::vector<transaction_info*>                m_transaction_info_pool;        ///<  Maintain a pool to improve performance
  std::vector<xtsc::xtsc_request*>              m_request_pool;                 ///<  Maintain a pool of requests to improve performance
  xtsc::u32                                     m_transaction_info_count;       ///<  Count number of constructed transaction_info objects
  xtsc::u32                                     m_request_count;                ///<  Count number of constructed xtsc_request objects
  std::vector<sc_core::sc_process_handle>       m_process_handles;              ///<  For reset 
  log4xtensa::TextLogger&                       m_text;                         ///<  Text logger

};


}  // namespace xtsc_component

#endif  // _XTSC_TLM22XTTLM_TRANSACTOR_H_
