// Copyright (c) 2005-2018 by Cadence Design Systems, Inc.  ALL RIGHTS RESERVED.
// These coded instructions, statements, and computer programs are the
// copyrighted works and confidential proprietary information of Cadence Design Systems, Inc.
// They may not be modified, copied, reproduced, distributed, or disclosed to
// third parties in any manner, medium, or form, in whole or in part, without
// the prior written consent of Cadence Design Systems, Inc.

// \w*clock_period\w*\|nacc_wait_time\|m_nacc_wait_time\|m_request_delay\|m_response_delay\|m_response_repeat\|m_recovery_time\|m_read_delay\|m_write_delay\|\<wait\>
// TODO: Document throttle capability when doing clock period changes
// TODO: User may want to increase response_fifo_depth so downstream slave won't get RSP_NACC'd when this devices is throttling

#include <cerrno>
#include <algorithm>
#include <ostream>
#include <string>
#include <vector>
#include <xtsc/xtsc_router.h>
#include <xtsc/xtsc_arbiter.h>
#include <xtsc/xtsc_core.h>
#include <xtsc/xtsc_dma_engine.h>
#include <xtsc/xtsc_master.h>
#include <xtsc/xtsc_memory_trace.h>
#include <xtsc/xtsc_pin2tlm_memory_transactor.h>
#include <xtsc/xtsc_tlm22xttlm_transactor.h>
#include <xtsc/xtsc_logging.h>

/*
 *  Theory of Operation
 *  
 *  Incoming requests are received in the nb_request() method.  Typically a copy is made
 *  of the request which is then added to m_request_fifo and m_router_thread_event is
 *  notified.  When not operating as a PIF width converter (PWC), this event is handled
 *  by router_thread and when operating as a PWC it is handled by router_pwc_thread.
 *
 *  If "m_use_wait_on_outstanding_write" is enabled then the read request waiting on an 
 *  outstanding write is parked into m_waiting_reads_fifo and waiting_reads_thread 
 *  is notified to keep read request waiting till the response of outstanding write is 
 *  not received. 
 *
 *  Incoming responses are received in the nb_respond() method.  Typically a copy is
 *  made of the response which is then added to the appropriate FIFO (base on port) in
 *  the m_response_fifos array and the m_response_arbiter_thread_event is notified.
 *  When not operating as a PWC, this event is handled by response_arbiter_thread and
 *  when operating as a PWC it is handled by response_arbiter_pwc_thread.
 *
 *  When "immediate_timing" is true, the threads are not used ("immediate_timing" must
 *  be false when operating as a PWC)
 *
 *  PWC Operation
 *
 *  If a request is received whose downstream PIF has the same width as the upstream
 *  PIF, then the request is passed downstream unchanged.  Otherwise, the
 *  convert_request() method is called to perform all required conversions, including
 *  combining multiple requests into a single request, converting a single request into
 *  multiple requests, and changing the request type (i.e from a block request to a
 *  non-block request or vice-versa) and various other fields of the request.
 *
 *  If a response is received from a downstream PIF which has the same width as the
 *  upstream PIF, then the response is passed upstream unchanged.  Otherwise, the
 *  convert_response() method is called to perform all required conversions, including
 *  combining multiple responses into a single response and converting a single response
 *  into multiple responses.
 *
 *  When a response comes in on a PIF interface that is not the same width as the master
 *  PIF, then the response has to be match up to the original request so that the
 *  necessary conversions can be made to the response.  The router uses the request and
 *  response ID fields to enable this match-up and so has to reassign the request ID in
 *  requests sent downstream to ensure uniqueness (of course, the original request ID
 *  has to be used for the responses sent back upstream).
 *
 *  The main structures associated with PWC operation are:
 *
 *  1) class req_rsp_info: This class holds the state information necessary for the
 *     entire sequence from the receipt of the request (or the first transfer of a
 *     BLOCK_WRITE or RCW request) until the response (or last response if BLOCK_READ)
 *     is sent back upstream.  
 *
 *  2) m_req_rsp_table[]: This array holds all outstanding req_rsp_info objects.  It is
 *     indexed by the downstream request tag.
 *
 *  3) m_requests[]: This array holds all ready-to-send-downstream requests generated by
 *     the call from router_pwc_thread() to convert_request().  The array is empty when
 *     convert_request() is called and may or may not be empty when convert_request()
 *     returns.  If it is not empty, the router_pwc_thread() sends each of the requests
 *     in it downstream before clearing it and calling convert_request() again for the
 *     next incoming request.  If the array is empty, then m_p_nascent_request in
 *     req_rsp_info will point to the partially formed converted request.
 *
 *  4) m_responses[]: This array holds all ready-to-send-upstream responses generated by
 *     the call from response_arbiter_pwc_thread() to convert_response().  The array is
 *     empty when convert_response() is called and may or may not be empty when
 *     convert_response() returns.  If it is not empty, the response_arbiter_pwc_thread()
 *     sends each of the responses in it upstream before clearing it and calling
 *     convert_response() again for the next incoming response.  If the array is empty,
 *     then m_p_nascent_response in req_rsp_info will point to the partially formed
 *     converted response.
 *
 */


using namespace std;
#if SYSTEMC_VERSION >= 20050601
using namespace sc_core;
#endif
using namespace xtsc;
using log4xtensa::WARN_LOG_LEVEL;
using log4xtensa::INFO_LOG_LEVEL;
using log4xtensa::VERBOSE_LOG_LEVEL;



#if !defined(_WIN32)
const u32 xtsc_component::xtsc_router::READ;
const u32 xtsc_component::xtsc_router::WRITE;
const u32 xtsc_component::xtsc_router::BLOCK_READ;
const u32 xtsc_component::xtsc_router::BLOCK_WRITE;
const u32 xtsc_component::xtsc_router::BURST_READ;
const u32 xtsc_component::xtsc_router::BURST_WRITE;
const u32 xtsc_component::xtsc_router::RCW;
const u32 xtsc_component::xtsc_router::RCW1;
const u32 xtsc_component::xtsc_router::RCW2;
const u32 xtsc_component::xtsc_router::SNOOP;
const u32 xtsc_component::xtsc_router::PEEK;
const u32 xtsc_component::xtsc_router::POKE;
const u32 xtsc_component::xtsc_router::FAST_ACCESS;
const u32 xtsc_component::xtsc_router::LOAD_RETIRED;
#endif


xtsc_component::xtsc_router::xtsc_router(sc_module_name module_name, const xtsc_router_parms& router_parms) :
  sc_module                        (module_name),
  xtsc_module                      (*(sc_module*)this),
  m_request_export                 ("m_request_export"),
  m_respond_port                   ("m_respond_port"),
  m_request_impl                   ("m_request_impl", *this),
  m_request_fifo_depth             (router_parms.get_non_zero_u32("request_fifo_depth")),
  m_request_fifo                   ("m_request_fifo",       m_request_fifo_depth),
  m_waiting_reads_fifo             ("m_waiting_reads_fifo", m_request_fifo_depth),
  m_ready_reads_fifo               ("m_ready_reads_fifo",   m_request_fifo_depth),
  m_router_parms                   (router_parms),
  m_use_block_requests             (router_parms.get_bool("use_block_requests")),
  m_master_byte_width              (router_parms.get_u32("master_byte_width")),
  m_read_only                      (router_parms.get_bool("read_only")),
  m_write_only                     (router_parms.get_bool("write_only")),
  m_wait_on_outstanding_write      (router_parms.get_bool("wait_on_outstanding_write")),
  m_log_peek_poke                  (router_parms.get_bool("log_peek_poke")),
  m_num_bit_fields                 (0),
  m_lua_port_function              (""),
  m_lua_addr_function              (""),
  m_lua_function                   (false),
  m_route_by_priority              (router_parms.get_u32_vector("route_by_priority")),
  m_use_route_by_priority          (m_route_by_priority.size()>0),
  m_use_route_by_type              (false),
#if IEEE_1666_SYSTEMC >= 201101L
  m_router_thread_event            ("m_router_thread_event"),
  m_response_arbiter_thread_event  ("m_response_arbiter_thread_event"),
  m_waiting_reads_thread_event     ("m_waiting_reads_thread_event"),
  m_outstanding_write_event        ("m_outstanding_write_event"),
#endif
  m_file                           (NULL),
  m_filter_peeks                   (false),
  m_filter_pokes                   (false),
  m_filter_requests                (false),
  m_filter_responses               (false),
  m_filtered_request               (),
  m_filtered_response              (m_filtered_request),
  m_profile_buffers                (router_parms.get_bool("profile_buffers")),
  m_text                           (log4xtensa::TextLogger::getInstance(name())),
  m_binary                         (log4xtensa::BinaryLogger::getInstance(name()))
{

  m_words.clear();
  m_line                        = "";
  m_line_count                  = 0;
  m_next_slot                   = 0;
  m_num_slaves                  = router_parms.get_u32("num_slaves");
  m_default_port_num            = router_parms.get_u32("default_port_num");
  m_default_delta               = router_parms.get_u64("default_delta");

  m_transaction_id_counts       = NULL;
  m_transaction_id_timestamps   = NULL;
  m_log_data_binary             = true;

  m_interleave_responses        = router_parms.get_bool("interleave_responses");
  m_flexible_request_id         = router_parms.get_bool("flexible_request_id");
  m_delay_from_receipt          = router_parms.get_bool("delay_from_receipt");
  m_immediate_timing            = router_parms.get_bool("immediate_timing");

  if (m_profile_buffers) {
    m_max_num_requests            = 0;
    m_max_num_requests_tag        = 0;
    m_max_num_responses           = new u32[m_num_slaves];
    m_max_num_responses_tag       = new u64[m_num_slaves];
    for (u32 i=0; i<m_num_slaves; i++) {
      m_max_num_responses[i]      = 0;
      m_max_num_responses_tag[i]  = 0;
    }
    m_max_num_responses_timestamp = new sc_time[m_num_slaves];
  }
  
  // Get clock period 
  u32 clock_period = router_parms.get_u32("clock_period");
  if (clock_period == 0xFFFFFFFF) {
    m_clock_period = xtsc_get_system_clock_period();
  }
  else {
    m_clock_period = sc_get_time_resolution() * clock_period;
  }

  u32 nacc_wait_time    = router_parms.get_u32("nacc_wait_time");
  u32 read_delay        = router_parms.get_u32("read_delay");
  u32 write_delay       = router_parms.get_u32("write_delay");

  compute_delays();

  m_slave_byte_widths = router_parms.get_u32_vector("slave_byte_widths");
  m_is_pwc = (m_slave_byte_widths.size() != 0);
  if (m_is_pwc) {
    if (m_immediate_timing) {
      ostringstream oss;
      oss << "xtsc_router '" << name() << "': \"immediate_timing\" must be false if \"slave_byte_widths\" is set";
      throw xtsc_exception(oss.str());
    }
    if (m_slave_byte_widths.size() != m_num_slaves) {
      ostringstream oss;
      oss << "xtsc_router '" << name() << "': size of \"slave_byte_widths\" (" << m_slave_byte_widths.size()
          << ") != \"num_slaves\" (" << m_num_slaves << ")";
      throw xtsc_exception(oss.str());
    }
    for (u32 i=0; i<m_num_slaves; ++i) {
      if ((m_slave_byte_widths[i] != 4) && (m_slave_byte_widths[i] != 8) && (m_slave_byte_widths[i] != 16) && (m_slave_byte_widths[i] != 32)) {
        ostringstream oss;
        oss << "xtsc_router '" << name() << "': slave_byte_widths[" << i << "]=" << m_slave_byte_widths[i]
            << " which is not one of the valid values of 4|8|16|32.";
        throw xtsc_exception(oss.str());
      }
    }
    if ((m_master_byte_width != 4) && (m_master_byte_width != 8) && (m_master_byte_width != 16) && (m_master_byte_width != 32)) {
      ostringstream oss;
      oss << "xtsc_router '" << name() << "': master_byte_width=" << m_master_byte_width 
          << " which is not one of the valid non-default values of 4|8|16|32.";
      throw xtsc_exception(oss.str());
    }

  }

  m_request_ports = new sc_port<xtsc_request_if>*[m_num_slaves];
  for (u32 i=0; i<m_num_slaves; i++) {
    ostringstream oss;
    oss << "m_request_ports[" << i << "]";
    m_request_ports[i] = new sc_port<xtsc_request_if>(oss.str().c_str());
  }

  m_respond_exports     = new sc_export<xtsc_respond_if>*[m_num_slaves];
  m_respond_impl        = new xtsc_respond_if_impl*      [m_num_slaves];
  for (u32 i=0; i<m_num_slaves; i++) {
    ostringstream oss1;
    oss1 << "m_respond_exports[" << i << "]";
    m_respond_exports[i] = new sc_export<xtsc_respond_if>(oss1.str().c_str());
    ostringstream oss2;
    oss2 << "m_respond_impl[" << i << "]";
    m_respond_impl[i] = new xtsc_respond_if_impl(oss2.str().c_str(), *this, i);
    (*m_respond_exports[i])(*m_respond_impl[i]);
  }

  m_response_fifos = new sc_fifo<response_info*>*[m_num_slaves];
  vector<u32> response_fifo_depths = router_parms.get_u32_vector("response_fifo_depths");
  if ((response_fifo_depths.size() != 0) && (response_fifo_depths.size() != m_num_slaves)) {
    ostringstream oss;
    oss << "xtsc_router '" << name() << "': size of \"response_fifo_depths\" (" << response_fifo_depths.size()
        << ") != \"num_slaves\" (" << m_num_slaves << ")";
    throw xtsc_exception(oss.str());
  }
  u32 response_fifo_depth = router_parms.get_u32("response_fifo_depth");
  for (u32 i=0; i<m_num_slaves; i++) {
    ostringstream oss;
    oss << "m_response_fifos[" << i << "]";
    u32 depth = (response_fifo_depths.size() ? response_fifo_depths[i] : response_fifo_depth);
    if (depth == 0) {
      ostringstream oss;
      oss << "xtsc_router '" << name() << "': depth from \"response_fifo_depths\" or \"response_fifo_depth\" cannot be 0";
      throw xtsc_exception(oss.str());
    }
    m_response_fifos[i] = new sc_fifo<response_info*>(oss.str().c_str(), depth);
  }

  m_request_export(m_request_impl);

  const char *route_by_type = router_parms.get_c_str("route_by_type");
  if (route_by_type && route_by_type[0]) {
    m_route_by_type = route_by_type;
    m_use_route_by_type = true;
    string::size_type port_types_beg = 0;
    string port_types;
    bool more_port_types = true;
    u32 port_cnt = 0;
    do {
      string::size_type next_port_types = m_route_by_type.find_first_of(";", port_types_beg);
      if (next_port_types == string::npos) {
        port_types = m_route_by_type.substr(port_types_beg);
        more_port_types = false;
      }
      else {
        port_types = m_route_by_type.substr(port_types_beg, next_port_types - port_types_beg);
        port_types_beg = next_port_types + 1;
      }
      port_cnt += 1;
      if (port_cnt > m_num_slaves) {
        ostringstream oss;
        oss << kind() << " '" << name() << "' More <PortTypes> specified then \"num_slaves\" (" << m_num_slaves
            << ") in \"route_by_type\": " << m_route_by_type;
        throw xtsc_exception(oss.str());
      }
      string::size_type types_beg = 0;
      string type;
      bool more_types = true;
      u32 type_cnt = 0;
      do {
        string::size_type next_type = port_types.find_first_of(",", types_beg);
        if (next_type == string::npos) {
          type = port_types.substr(types_beg);
          more_types = false;
        }
        else {
          type = port_types.substr(types_beg, next_type - types_beg);
          types_beg = next_type + 1;
        }
        type_cnt += 1;
        string type_uc = type;
        transform(type_uc.begin(), type_uc.end(), type_uc.begin(), ::toupper);
        u32 type_u32 = 0xFF;
             if (type_uc == "READ"         ) { type_u32 = READ;         }
        else if (type_uc == "WRITE"        ) { type_u32 = WRITE;        }
        else if (type_uc == "BLOCK_READ"   ) { type_u32 = BLOCK_READ;   }
        else if (type_uc == "BLOCK_WRITE"  ) { type_u32 = BLOCK_WRITE;  }
        else if (type_uc == "BURST_READ"   ) { type_u32 = BURST_READ;   }
        else if (type_uc == "BURST_WRITE"  ) { type_u32 = BURST_WRITE;  }
        else if (type_uc == "RCW"          ) { type_u32 = RCW;          }
        else if (type_uc == "RCW1"         ) { type_u32 = RCW1;         }
        else if (type_uc == "RCW2"         ) { type_u32 = RCW2;         }
        else if (type_uc == "SNOOP"        ) { type_u32 = SNOOP;        }
        else if (type_uc == "PEEK"         ) { type_u32 = PEEK;         }
        else if (type_uc == "POKE"         ) { type_u32 = POKE;         }
        else if (type_uc == "FAST_ACCESS"  ) { type_u32 = FAST_ACCESS;  }
        else if (type_uc == "LOAD_RETIRED" ) { type_u32 = LOAD_RETIRED; }
        else {
          ostringstream oss;
          oss << kind() << " '" << name() << "' Unrecognized <Type> (" << type << ") found in <PortTypes> #" << port_cnt << " ("
              << port_types << ") in \"route_by_type\": " << m_route_by_type;
          throw xtsc_exception(oss.str());
        }
        if (m_type_port_map.find(type_u32) != m_type_port_map.end()) {
          ostringstream oss;
          oss << kind() << " '" << name() << "' <Type> (" << type << ") found multiple times in \"route_by_type\": " << m_route_by_type;
          throw xtsc_exception(oss.str());
        }
        m_type_port_map[type_u32] = port_cnt-1;
      } while (more_types);
    } while (more_port_types);
    map<u32,u32>::const_iterator it;
    it = m_type_port_map.find(RCW);
    if (it != m_type_port_map.end()) {
      if ((m_type_port_map.find(RCW1) != m_type_port_map.end()) || (m_type_port_map.find(RCW2) != m_type_port_map.end())) {
        ostringstream oss;
        oss << kind() << " '" << name() << "' <Type> RCW1 and RCW2 cannot be specified when RCW is specified in \"route_by_type\": "
            << m_route_by_type;
        throw xtsc_exception(oss.str());
      }
      m_type_port_map[RCW1] = it->second;
      m_type_port_map[RCW2] = it->second;
    }
    it = m_type_port_map.find(READ);
    if (it == m_type_port_map.end()) {
      ostringstream oss;
      oss << kind() << " '" << name() << "' <Type> READ not found in \"route_by_type\": " << m_route_by_type;
      throw xtsc_exception(oss.str());
    }
    u32 read_port = it->second;
    u32 read_types[] = { BLOCK_READ, BURST_READ, RCW1, SNOOP, PEEK, FAST_ACCESS, LOAD_RETIRED };
    for (u32 i=0; i<sizeof(read_types)/sizeof(read_types[0]); ++i) {
      if (m_type_port_map.find(read_types[i]) == m_type_port_map.end()) {
        m_type_port_map[read_types[i]] = read_port;
      }
    }
    it = m_type_port_map.find(WRITE);
    if (it == m_type_port_map.end()) {
      ostringstream oss;
      oss << kind() << " '" << name() << "' <Type> WRITE not found in \"route_by_type\": " << m_route_by_type;
      throw xtsc_exception(oss.str());
    }
    u32 write_port = it->second;
    u32 write_types[] = { BLOCK_WRITE, BURST_WRITE, RCW2, POKE };
    for (u32 i=0; i<sizeof(write_types)/sizeof(write_types[0]); ++i) {
      if (m_type_port_map.find(write_types[i]) == m_type_port_map.end()) {
        m_type_port_map[write_types[i]] = write_port;
      }
    }
  }

  bool default_routing = router_parms.get_bool("default_routing");
  const char *routing_table = router_parms.get_c_str("routing_table");
  m_address_routing_bits = router_parms.get_u32_vector("address_routing_bits");
  m_address_routing = (m_address_routing_bits.size() != 0);
  m_address_routing_turbo_mask = 0;
  m_address_routing_turbo_size = 0;

  if (!m_address_routing && !m_is_pwc && (m_master_byte_width != 0)) {
    ostringstream oss;
    oss << "xtsc_router '" << name() << "': master_byte_width=" << m_master_byte_width 
        << " should be left at its default value of 0 unless \"address_routing_bits\" or \"slave_byte_widths\" is set";
    throw xtsc_exception(oss.str());
  }

  if (m_address_routing) {
    if ((m_master_byte_width !=  4) &&
        (m_master_byte_width !=  8) &&
        (m_master_byte_width != 16) &&
        (m_master_byte_width != 32) &&
        (m_master_byte_width != 64))
    {
      ostringstream oss;
      oss << "xtsc_router '" << name() << "': master_byte_width=" << m_master_byte_width 
          << " which is not one of the valid non-default values of 4|8|16|32|64 which may be used when also"
          << " using \"address_routing_bits\".";
      throw xtsc_exception(oss.str());
    }
    if (m_slave_byte_widths.size() != 0) {
      ostringstream oss;
      oss << "xtsc_router '" << name()
          << "' has conflicting parameters:  \"address_routing_bits\" and \"slave_byte_widths\" cannot both be set";
      throw xtsc_exception(oss.str());
    }
    if (m_use_block_requests) {
      ostringstream oss;
      oss << "xtsc_router '" << name()
          << "' has conflicting parameters:  \"address_routing_bits\" and \"use_block_requests\" cannot both be set";
      throw xtsc_exception(oss.str());
    }
    if (!default_routing) {
      ostringstream oss;
      oss << "xtsc_router '" << name()
          << "' has conflicting parameters:  If \"address_routing_bits\" is set then \"default_routing\" must be false";
      throw xtsc_exception(oss.str());
    }
    if (routing_table && routing_table[0]) {
      ostringstream oss;
      oss << "xtsc_router '" << name()
          << "' has conflicting parameters:  \"address_routing_bits\" and \"routing_table\" cannot both be set";
      throw xtsc_exception(oss.str());
    }
    if (m_default_delta != 0) {
      ostringstream oss;
      oss << "xtsc_router '" << name()
          << "' has conflicting parameters:  \"address_routing_bits\" and \"default_delta\" cannot both be set";
      throw xtsc_exception(oss.str());
    }
    if (m_default_port_num != ADDRESS_ERROR) {
      ostringstream oss;
      oss << "xtsc_router '" << name()
          << "' has conflicting parameters:  \"address_routing_bits\" and \"default_port_num\" cannot both be set";
      throw xtsc_exception(oss.str());
    }
    if ((m_address_routing_bits.size() & 0x1) != 0) {
      ostringstream oss;
      oss << "xtsc_router '" << name() << "' parameter \"address_routing_bits\" has " << m_address_routing_bits.size()
          << " entries which is not an even number as is required.";
      throw xtsc_exception(oss.str());
    }
    u32 num_slaves_log2 = 0;
    u32 mask = 1;
    for (u32 i=0; i<32; ++i) {
      if (m_num_slaves & mask) num_slaves_log2 = i;
      mask <<= 1;
    }
    if ((m_num_slaves <= 1) || ((u32) (1 << num_slaves_log2) != m_num_slaves)) {
      ostringstream oss;
      oss << "xtsc_router '" << name() << "': when parameter \"address_routing_bits\" is set then \"num_slaves\"=" << m_num_slaves
          << " must be a power of 2 greater than 1";
      throw xtsc_exception(oss.str());
    }
    u32 byte_lane_bits = (m_master_byte_width ==  4) ? 2 :
                         (m_master_byte_width ==  8) ? 3 :
                         (m_master_byte_width == 16) ? 4 :
                         (m_master_byte_width == 32) ? 5 :
                         (m_master_byte_width == 64) ? 6 : 0;
    if (byte_lane_bits == 0) {
      ostringstream oss;
      oss << "PROGRAM ERROR:  unhandled xtsc_router_parms value for \"master_byte_width\"=" << m_master_byte_width << " in "
          << __FILE__ << ":" << __LINE__;
      throw xtsc_exception(oss.str());
    }
    u32 routing_bits = 0;
    u32 routing_lsb = 31;
    XTSC_DEBUG(m_text, "Address routing bit fields:");
    for (u32 i=0; i<m_address_routing_bits.size(); ++i) {
      if (m_address_routing_bits[i] < byte_lane_bits) {
        ostringstream oss;
        oss << "xtsc_router '" << name() << "' parameter \"address_routing_bits\" values must all be greater than or equal to " 
            << byte_lane_bits << " (= log2(\"master_byte_width\"))";
        throw xtsc_exception(oss.str());
      }
      if (m_address_routing_bits[i] >= 32) {
        ostringstream oss;
        oss << "xtsc_router '" << name() << "': values specified in the \"address_routing_bits\" parameter must all be less than 32";
        throw xtsc_exception(oss.str());
      }
      if ((i & 1) == 0) {
        u32 bit_field_bits = m_address_routing_bits[i] - m_address_routing_bits[i+1] + 1;
        routing_bits += bit_field_bits;
        u32 pre_shift = m_address_routing_bits[i+1];
        u32 mask = ((1 << bit_field_bits) - 1);
        bit_field_info *p_info = new bit_field_info(pre_shift, mask, num_slaves_log2-routing_bits);
        m_address_routing_info.push_back(p_info);
        if (m_address_routing_bits[i+1] < routing_lsb) { routing_lsb = m_address_routing_bits[i+1]; }
        XTSC_DEBUG(m_text, " address[" << m_address_routing_bits[i] << ":" << m_address_routing_bits[i+1] <<
                           "] => pre_shift=" << p_info->m_pre_shift <<
                           " mask=0x" << hex << setfill('0') << setw(8) << p_info->m_mask << dec <<
                           " post_shift=" << p_info->m_post_shift);
      }
    }
    if (routing_bits != num_slaves_log2) {
      ostringstream oss;
      oss << "xtsc_router '" << name() << "': the number of routing bits (=" << routing_bits
          << ") implied by the \"address_routing_bits\" parameter does not equal " << num_slaves_log2
          << " (from log2(\"num_slaves\") with \"num_slaves\"=" << m_num_slaves << ")";
      throw xtsc_exception(oss.str());
    }
    m_address_routing_turbo_size =  1 << routing_lsb;
    m_address_routing_turbo_mask = XTSC_MAX_ADDRESS ^ (m_address_routing_turbo_size - 1);
    m_num_bit_fields = m_address_routing_info.size();
  }
  else if (default_routing) {

    if (routing_table && routing_table[0]) {
      // Treat routing_table as a char * file name
      m_file_name = routing_table;

      // Open the file
      m_file = new xtsc_script_file(m_file_name.c_str(), "routing_table", name(), kind(), false);
      m_file_name = m_file->name();

      XTSC_LOG(m_text, xtsc_get_constructor_log_level(), "Loading routing table from file '" << m_file_name << "'.");

      while ((m_line_count = m_file->get_words(m_words, m_line, true))) {

        if (m_words[0] == "lua_function") {
          if ((m_words.size() < 2) || (m_words.size() > 3)) {
            ostringstream oss;
            oss << "Invalid lua_function line.  Format is: lua_function <LuaPortFunction> [<LuaAddrFunction>]" << endl;
            oss << m_line;
            oss << m_file->info_for_exception();
            throw xtsc_exception(oss.str());
          }
          m_lua_port_function = m_words[1];
          if (m_words.size() == 3) {
            m_lua_addr_function = m_words[2];
          }
          m_lua_function = true;
          continue;
        }

        if ((m_words.size() != 3) && (m_words.size() != 4)) {
          ostringstream oss;
          oss << "Found invalid number of words (expected 3 or 4):" << endl;
          oss << m_line;
          oss << m_file->info_for_exception();
          throw xtsc_exception(oss.str());
        }

        u32 port_num = get_u32(0);
        xtsc_address start_address8 = get_u64(1);
        xtsc_address end_address8   = get_u64(2);
        xtsc_address delta          = 0;
        if (m_words.size() == 4) {
          u64 new_base_address8 = get_u64(3);
          delta = new_base_address8 - start_address8;
        }
        if ((port_num >= m_num_slaves) && (port_num != ADDRESS_ERROR) && (port_num != DISCARD_REQUEST)) {
          ostringstream oss;
          if (m_num_slaves) {
            oss << "port_num=" << port_num << " is too large (max port_num=" << (m_num_slaves-1) << ")";
          }
          else {
            oss << "port_num=" << port_num << " is invalid for this null router (which has no output ports).";
          }
          oss << endl << m_line;
          oss << m_file->info_for_exception();
          throw xtsc_exception(oss.str());
        }
        vector<xtsc_address_range_entry>::const_iterator irt;
        for (irt = m_routing_table.begin(); irt != m_routing_table.end(); ++irt) {
          if ((((irt->m_start_address8 >= start_address8) && (irt->m_start_address8 <= end_address8)) ||
               ((irt->m_end_address8   >= start_address8) && (irt->m_end_address8   <= end_address8))) &&
              ((irt->m_port_num != port_num) || (irt->m_delta != delta)))
          {
            ostringstream oss;
            oss << "Routing table entry overlaps earlier routing table entry but port numbers or address translations do not match."
                << endl;
            oss << "Earlier entry:  " << irt->m_port_num << " 0x" << hex << irt->m_start_address8 << " 0x"
                << irt->m_end_address8 << " 0x" << (irt->m_start_address8 + irt->m_delta) << endl;
            oss << "Current entry:  " <<        port_num << " 0x" << hex <<        start_address8 << " 0x"
                <<        end_address8 << " 0x" << (       start_address8 +        delta) << endl;
            oss << m_line;
            oss << m_file->info_for_exception();
            throw xtsc_exception(oss.str());
          }
        }
        XTSC_LOG(m_text, xtsc_get_constructor_log_level(), "0x" << hex << port_num << ": 0x" << start_address8 <<
                                                           "-0x" << end_address8 << " delta=0x" << delta);
        xtsc_address_range_entry entry(start_address8, end_address8, port_num, delta);
        m_routing_table.push_back(entry);
      }

    }
    else if (!m_use_route_by_priority && !m_use_route_by_type) {
      if (m_num_slaves) {
        u64 max_memory_size = 0x100000000LL;
        u64 aperture_size = max_memory_size / m_num_slaves;
        if ((aperture_size * m_num_slaves) != max_memory_size) {
          ostringstream oss;
          oss << "xtsc_router '" << name()
              << "': To use default routing requires that the number of slaves be a power of 2: m_num_slaves=" << m_num_slaves;
          throw xtsc_exception(oss.str());
        }
        XTSC_LOG(m_text, xtsc_get_constructor_log_level(), "Creating routing table with " << m_num_slaves <<
                                                            " equally sized memory apertures of 0x" << hex <<
                                                            aperture_size << " bytes");
        xtsc_address smallest_next_address = 0;
        for (u32 i=0; i< m_num_slaves; i++) {
          xtsc_address_range_entry entry(smallest_next_address, (xtsc_address)(smallest_next_address+aperture_size-1), i,
                                         m_default_delta);
          m_routing_table.push_back(entry);
          smallest_next_address = (xtsc_address) (smallest_next_address + aperture_size);
        }
      }
    }

  }

  ostringstream route_by_priority;
  for (u32 i=0; i<m_route_by_priority.size(); ++i) { route_by_priority << (i ? "," : "") << m_route_by_priority[i]; }
  for (u32 i=0; i<16; ++i) { m_priority_port_map[i] = m_default_port_num; }
  if (m_use_route_by_priority) {
    if (m_is_pwc                                ||
        m_master_byte_width                     ||
        m_use_block_requests                    ||
        !default_routing                        ||
        (routing_table && routing_table[0])     ||
        m_default_delta                         ||
        m_address_routing                       ||
        m_use_route_by_type)
    {
      ostringstream oss;
      oss << kind() << " '" << name() << "' parameters \"slave_byte_widths\", \"master_byte_width\", \"use_block_requests\", "
                                      << "\"default_routing\", \"routing_table\", \"default_delta\", \"address_routing_bits\", "
                                      << "and \"route_by_type\" cannot be changed from their default when \"route_by_priority\" is used.";
      throw xtsc_exception(oss.str());
    }
    if ((m_route_by_priority.size() % 3) != 0) {
      ostringstream oss;
      oss << kind() << " '" << name() << "' parameter \"route_by_priority\" must contain a multiple of 3 entries, but " << m_route_by_priority.size()
          << " were found: " << route_by_priority.str();
      throw xtsc_exception(oss.str());
    }
    for (u32 i=0; i<m_route_by_priority.size(); i+=3) {
      if (m_route_by_priority[i] > m_route_by_priority[i+1]) {
        ostringstream oss;
        oss << kind() << " '" << name() << "': BeginPriorityValue may not exceed EndPriorityValue in parameter \"route_by_priority\"[" << i << "]: " 
            << route_by_priority.str();
        throw xtsc_exception(oss.str());
      }
      if (m_route_by_priority[i+1] > 15) {
        ostringstream oss;
        oss << kind() << " '" << name() << "': EndPriorityValue may not exceed 15 in parameter \"route_by_priority\"[" << (i+1) << "]: " 
            << route_by_priority.str();
        throw xtsc_exception(oss.str());
      }
      for (u32 j=m_route_by_priority[i]; j<=m_route_by_priority[i+1]; ++j) {
        if (m_priority_port_map[j] != m_default_port_num) {
        ostringstream oss;
        oss << kind() << " '" << name() << "': PriorityValue of " << j << " is specified multiple times in parameter \"route_by_priority\": " 
            << route_by_priority.str();
        throw xtsc_exception(oss.str());
        }
        m_priority_port_map[j] = m_route_by_priority[i+2];
      }
    }
  }

  m_use_wait_on_outstanding_write = false;

  if (m_use_route_by_type) {
    if (m_is_pwc                                ||
        m_master_byte_width                     ||
        m_use_block_requests                    ||
        !default_routing                        ||
        (routing_table && routing_table[0])     ||
        m_default_delta                         ||
        m_address_routing                       ||
        (m_default_port_num != ADDRESS_ERROR))
    {
      cout << "m_master_byte_width=" << m_master_byte_width << endl;
      cout << "m_use_block_requests=" << m_use_block_requests << endl;
      cout << "!default_routing=" << !default_routing << endl;
      cout << "(routing_table && routing_table[0])=" << (routing_table && routing_table[0]) << endl;
      cout << "m_default_delta=" << m_default_delta << endl;
      cout << "m_address_routing=" << m_address_routing << endl;
      cout << "(m_default_port_num != ADDRESS_ERROR)=" << (m_default_port_num != ADDRESS_ERROR) << endl;
      ostringstream oss;
      oss << kind() << " '" << name() << "' parameters \"slave_byte_widths\", \"master_byte_width\", \"use_block_requests\", "
                                      << "\"default_routing\", \"routing_table\", \"default_delta\", \"address_routing_bits\", "
                                      << "and \"default_port_num\" cannot be changed from their default when \"route_by_type\" is used.";
      throw xtsc_exception(oss.str());
    }

    if (m_wait_on_outstanding_write) {
      if (!m_immediate_timing) {
        m_use_wait_on_outstanding_write = true;
      } else {
        ostringstream oss;
        oss << kind() << " '" << name() << "' parameter \"immediate_timing\" and \"wait_on_outstanding_write\""
                                        << " cannot both be used at the same time.";
        throw xtsc_exception(oss.str());
      }
    }
  } 

  if (m_flexible_request_id) {
    m_transaction_id_counts     = new map<u64, u32>[m_num_slaves];
    m_transaction_id_timestamps = new map<u64, u64>[m_num_slaves];
  }

  if (m_use_wait_on_outstanding_write) {
      SC_THREAD(waiting_reads_thread);                  m_process_handles.push_back(sc_get_current_process_handle());
  }

  if (!m_immediate_timing) {
    if (m_is_pwc) {
      SC_THREAD(router_pwc_thread);                     m_process_handles.push_back(sc_get_current_process_handle());
    }
    else {
      SC_THREAD(router_thread);                         m_process_handles.push_back(sc_get_current_process_handle());
    }
  }

  if (m_num_slaves) {
    if (m_is_pwc) {
      SC_THREAD(response_arbiter_pwc_thread);           m_process_handles.push_back(sc_get_current_process_handle());
    }
    else {
      SC_THREAD(response_arbiter_thread);               m_process_handles.push_back(sc_get_current_process_handle());
    }
  }

  for (u32 i=0; i<m_num_slaves; ++i) {
    ostringstream oss;
    oss.str(""); oss << "m_request_ports"   << "[" << i << "]"; m_port_types[oss.str()] = REQUEST_PORT;
    oss.str(""); oss << "m_respond_exports" << "[" << i << "]"; m_port_types[oss.str()] = RESPOND_EXPORT;
    oss.str(""); oss << "master_port"       << "[" << i << "]"; m_port_types[oss.str()] = PORT_TABLE;
  }
  if (m_num_slaves == 1) {
  m_port_types["master_port"]      = PORT_TABLE;
  }
  m_port_types["master_ports"]     = PORT_TABLE;
  m_port_types["m_request_export"] = REQUEST_EXPORT;
  m_port_types["m_respond_port"]   = RESPOND_PORT;
  m_port_types["slave_port"]       = PORT_TABLE;

  xtsc_register_command(*this, *this, "change_clock_period", 1, 1,
      "change_clock_period <ClockPeriodFactor>", 
      "Call xtsc_router::change_clock_period(<ClockPeriodFactor>).  Return previous <ClockPeriodFactor> for this device."
  );

  xtsc_register_command(*this, *this, "dump_filtered_request", 0, 0,
      "dump_filtered_request", 
      "Dump the most recent previous xtsc_request that passed a xtsc_request watchfilter."
  );

  xtsc_register_command(*this, *this, "dump_filtered_response", 0, 0,
      "dump_filtered_response", 
      "Dump the most recent previous xtsc_response that passed a xtsc_response watchfilter."
  );

  xtsc_register_command(*this, *this, "dump_profile_results", 0 , 0,
      "dump_profile_results",
      "Dump max used buffers for request and response fifos."
  );
  
  xtsc_register_command(*this, *this, "dump_transaction_id_counts", 0, 1,
      "dump_transaction_id_counts [<Verbose>]", 
      "Return the buffer from calling dump_transaction_id_counts(<Verbose>).  <Verbose> may be 0|1 (default is 0)." 
  );

  xtsc_register_command(*this, *this, "peek", 2, 2,
      "peek <StartAddress> <NumBytes>", 
      "Peek <NumBytes> of memory starting at <StartAddress>."
  );

  xtsc_register_command(*this, *this, "poke", 2, -1,
      "poke <StartAddress> <NumBytes> <Byte1> <Byte2> . . . <ByteN>", 
      "Poke <NumBytes> (=N) of memory starting at <StartAddress>."
  );

  xtsc_register_command(*this, *this, "reset", 0, 1,
      "reset", 
      "Call xtsc_router::reset()."
  );

  xtsc_register_command(*this, *this, "watchfilter_add", 2, 2,
      "watchfilter_add <FilterName> <EventName>", 
      "Calls xtsc_router::watchfilter_add(<FilterName>, <Event>) and returns the watchfilter number."
      "  <EventName> can be a hyphen (-) to mean the last event created by the xtsc_event_create command."
  );

  xtsc_register_command(*this, *this, "watchfilter_dump", 0, 0,
      "watchfilter_dump", 
      "Return xtsc_router::watchfilter_dump()."
  );

  xtsc_register_command(*this, *this, "watchfilter_remove", 1, 1,
      "watchfilter_remove <Watchfilter>", 
      "Return xtsc_router::watchfilter_remove(<Watchfilter>).  An * removes all watchfilters."
  );
  

  xtsc_event_register(m_router_thread_event,           "m_router_thread_event",           this);
  xtsc_event_register(m_response_arbiter_thread_event, "m_response_arbiter_thread_event", this);
  xtsc_event_register(m_waiting_reads_thread_event,    "m_waiting_reads_thread_event",    this);
  xtsc_event_register(m_outstanding_write_event,       "m_outstanding_write_event",       this);

  log4xtensa::LogLevel ll = xtsc_get_constructor_log_level();
  XTSC_LOG(m_text, ll,        "Constructed xtsc_router '" << name() << "':");
  XTSC_LOG(m_text, ll,        " num_slaves                 = "   << m_num_slaves);
  { ostringstream oss; if (m_is_pwc) for (u32 i=0; i<m_num_slaves; ++i) oss << (i ? "," : "") << m_slave_byte_widths[i];
  XTSC_LOG(m_text, ll,        " slave_byte_widths          = "   << oss.str());
  }
  if (m_is_pwc || m_address_routing) {
  XTSC_LOG(m_text, ll,        " master_byte_width          = "   << m_master_byte_width);
  }
  if (m_is_pwc) {
  XTSC_LOG(m_text, ll,        " use_block_requests         = "   << boolalpha << m_use_block_requests);
  }
  XTSC_LOG(m_text, ll,        " default_routing            = "   << boolalpha << default_routing);
  XTSC_LOG(m_text, ll,        " routing_table              = "   << (routing_table ? (m_file ? m_file_name : routing_table) : ""));
  XTSC_LOG(m_text, ll, hex << " default_port_num           = 0x" << m_default_port_num);
  XTSC_LOG(m_text, ll, hex << " default_delta              = 0x" << m_default_delta);
  { ostringstream oss; for (u32 i=0; i<m_address_routing_bits.size(); ++i) oss << (i ? "," : "") << m_address_routing_bits[i];
  XTSC_LOG(m_text, ll,        " address_routing_bits       = "   << oss.str());
  }
  XTSC_LOG(m_text, ll,        " route_by_priority          = "   << route_by_priority.str());
  XTSC_LOG(m_text, ll,        " route_by_type              = "   << m_route_by_type);
  XTSC_LOG(m_text, ll,        " read_only                  = "   << boolalpha << m_read_only);
  XTSC_LOG(m_text, ll,        " write_only                 = "   << boolalpha << m_write_only);
  XTSC_LOG(m_text, ll,        " wait_on_outstanding_write  = "   << boolalpha << m_wait_on_outstanding_write);
  XTSC_LOG(m_text, ll,        " log_peek_poke              = "   << boolalpha << m_log_peek_poke);
  XTSC_LOG(m_text, ll,        " interleave_responses       = "   << boolalpha << m_interleave_responses);
  XTSC_LOG(m_text, ll,        " flexible_request_id        = "   << boolalpha << m_flexible_request_id);
  XTSC_LOG(m_text, ll,        " immediate_timing           = "   << boolalpha << m_immediate_timing);
  if (!m_immediate_timing) {
  if (clock_period == 0xFFFFFFFF) {
  XTSC_LOG(m_text, ll, hex << " clock_period               = 0x" << clock_period << " (" << m_clock_period << ")");
  } else {
  XTSC_LOG(m_text, ll,        " clock_period               = "   << clock_period << " (" << m_clock_period << ")");
  }
  XTSC_LOG(m_text, ll,        " delay_from_receipt         = "   << boolalpha << m_delay_from_receipt);
  XTSC_LOG(m_text, ll,        " request_delay              = "   << router_parms.get_u32("request_delay"));
  if (read_delay == 0xFFFFFFFF) {
  XTSC_LOG(m_text, ll, hex << " read_delay                 = 0x" << read_delay << " (" << m_read_delay << ")");
  } else {
  XTSC_LOG(m_text, ll,        " read_delay                 = "   << read_delay << " (" << m_read_delay << ")");
  }
  if (write_delay == 0xFFFFFFFF) {
  XTSC_LOG(m_text, ll, hex << " write_delay                = 0x" << write_delay << " (" << m_write_delay << ")");
  } else {
  XTSC_LOG(m_text, ll,        " write_delay                = "   << write_delay << " (" << m_write_delay << ")");
  }
  if (nacc_wait_time == 0xFFFFFFFF) {
  XTSC_LOG(m_text, ll, hex << " nacc_wait_time             = 0x" << nacc_wait_time << " (" << m_nacc_wait_time << ")");
  } else {
  XTSC_LOG(m_text, ll,        " nacc_wait_time             = "   << nacc_wait_time << " (" << m_nacc_wait_time << ")");
  }
  XTSC_LOG(m_text, ll,        " response_delay             = "   << router_parms.get_u32("response_delay"));
  XTSC_LOG(m_text, ll,        " response_repeat            = "   << router_parms.get_u32("response_repeat"));
  XTSC_LOG(m_text, ll,        " recovery_time              = "   << router_parms.get_u32("recovery_time"));
  XTSC_LOG(m_text, ll,        " request_fifo_depth         = "   << m_request_fifo_depth);
  XTSC_LOG(m_text, ll,        " response_fifo_depth        = "   << router_parms.get_u32("response_fifo_depth"));
  { ostringstream oss; for (u32 i=0; i<response_fifo_depths.size(); i++) { oss << (i ? "," : "") << response_fifo_depths[i]; }
  XTSC_LOG(m_text, ll,        " response_fifo_depths       = "   << oss.str());
  }
  }
  XTSC_LOG(m_text, ll,        " profile_buffers            = "   << boolalpha << m_profile_buffers);

  if (m_lua_function) {
  XTSC_LOG(m_text, ll,        " <LuaPortFunction>          = "   << m_lua_port_function);
  XTSC_LOG(m_text, ll,        " <LuaAddrFunction>          = "   << m_lua_addr_function);
  }

  if (m_is_pwc) {
    for (u32 i=0; i<8; ++i) {
      m_requests[i] = NULL;
      m_responses[i] = NULL;
    }
  }

  reset(true);

}



xtsc_component::xtsc_router::~xtsc_router(void) {

  if (m_profile_buffers) {
    delete [] m_max_num_responses;
    delete [] m_max_num_responses_timestamp;
    delete [] m_max_num_responses_tag;
  }

  if (m_flexible_request_id) {
    delete [] m_transaction_id_counts;
    delete [] m_transaction_id_timestamps;
  }

  if (m_request_ports) {
    for (u32 i=0; i<m_num_slaves; i++) {
      if (m_request_ports[i]) {
        delete m_request_ports[i];
        m_request_ports[i] = 0;
      }
    }
    delete [] m_request_ports;
    m_request_ports = 0;
  }

  if (m_respond_exports) {
    for (u32 i=0; i<m_num_slaves; i++) {
      if (m_respond_exports[i]) {
        delete m_respond_exports[i];
        m_respond_exports[i] = 0;
      }
    }
    delete [] m_respond_exports;
    m_respond_exports = 0;
  }

  if (m_response_fifos) {
    for (u32 i=0; i<m_num_slaves; i++) {
      if (m_response_fifos[i]) {
        delete m_response_fifos[i];
        m_response_fifos[i] = 0;
      }
    }
    delete [] m_response_fifos;
    m_response_fifos = 0;
  }


}



u32 xtsc_component::xtsc_router::get_bit_width(const string& port_name, u32 interface_num) const {
  if (!m_is_pwc) return 0;

       if (port_name == "m_request_export") return m_master_byte_width*8;
  else if (port_name == "m_respond_port"  ) return m_master_byte_width*8;

  string name_portion;
  u32    index;
  xtsc_parse_port_name(port_name, name_portion, index);

  if ((name_portion != "m_respond_ports") && (name_portion != "m_request_exports")) {
    ostringstream oss;
    oss << kind() << " \"" << name() << "\" has no port named \"" << port_name << "\"" << endl;
    throw xtsc_exception(oss.str());
  }

  if (index > m_num_slaves - 1) {
    ostringstream oss;
    oss << kind() << " \"" << name() << "\": Invalid index: \"" << port_name << "\".  Valid range: 0-" << (m_num_slaves-1) << endl;
    throw xtsc_exception(oss.str());
  }

  return m_slave_byte_widths[index]*8;
}



sc_object *xtsc_component::xtsc_router::get_port(const string& port_name) {
       if (port_name == "m_request_export") return &m_request_export;
  else if (port_name == "m_respond_port"  ) return &m_respond_port;

  string name_portion;
  u32    index;
  xtsc_parse_port_name(port_name, name_portion, index);

  if ((name_portion != "m_respond_exports") && (name_portion != "m_request_ports")) {
    ostringstream oss;
    oss << kind() << " \"" << name() << "\" has no port named \"" << port_name << "\"" << endl;
    throw xtsc_exception(oss.str());
  }

  if (index > m_num_slaves - 1) {
    ostringstream oss;
    oss << kind() << " \"" << name() << "\": Invalid index: \"" << port_name << "\".  Valid range: 0-" << (m_num_slaves-1) << endl;
    throw xtsc_exception(oss.str());
  }

  return ((name_portion == "m_respond_exports") ? (sc_object*) m_respond_exports[index] : (sc_object*) m_request_ports[index]);
}



xtsc_port_table xtsc_component::xtsc_router::get_port_table(const string& port_table_name) const {
  xtsc_port_table table;

  if (port_table_name == "slave_port") {
    table.push_back("m_request_export");
    table.push_back("m_respond_port");
    return table;
  }

  if (port_table_name == "master_ports") {
    for (u32 i=0; i<m_num_slaves; ++i) {
      ostringstream oss;
      oss << "master_port" << "[" << i << "]";
      table.push_back(oss.str());
    }
    return table;
  }

  string name_portion;
  u32    index;
  bool   indexed = xtsc_parse_port_name(port_table_name, name_portion, index);

  if ((name_portion == "master_ports") && !indexed) {
    ostringstream oss;
    for (u32 i=0; i<m_num_slaves; ++i) {
      oss.str(""); oss << "master_port" << "[" << i << "]"; table.push_back(oss.str());
    }
    return table;
  }

  if ((name_portion != "master_port") || ((m_num_slaves > 1) && !indexed)) {
    ostringstream oss;
    oss << kind() << " \"" << name() << "\" has no port table named \"" << port_table_name << "\"" << endl;
    throw xtsc_exception(oss.str());
  }

  if (index > m_num_slaves - 1) {
    ostringstream oss;
    oss << kind() << " \"" << name() << "\": Invalid index: \"" << port_table_name << "\".  Valid range: 0-" << (m_num_slaves-1)
        << endl;
    throw xtsc_exception(oss.str());
  }

  ostringstream oss;
  oss.str(""); oss << "m_request_ports"   << "[" << index << "]"; table.push_back(oss.str());
  oss.str(""); oss << "m_respond_exports" << "[" << index << "]"; table.push_back(oss.str());

  return table;
}



void xtsc_component::xtsc_router::reset(bool /*hard_reset*/) {
  XTSC_INFO(m_text, "xtsc_router::reset()");

  m_lock                        = false;
  m_token                       = m_num_slaves - 1;
  m_waiting_for_nacc            = false;
  m_request_got_nacc            = false;
  m_last_request_time_stamp     = SC_ZERO_TIME - (m_delay_from_receipt ? m_recovery_time : m_request_delay);
  m_last_response_time_stamp    = SC_ZERO_TIME - (m_delay_from_receipt ? m_recovery_time : m_response_delay);

  if (m_is_pwc) {
    m_pending_request_tag        = 0;            // Indicates there is no pending request
    m_active_block_read_tag      = 0;            // Indicates no BLOCK_READ response is in progress
    m_issued_split_requests.clear();
    m_req_rsp_table.clear();

    for (u32 i=0; (i<8) && (m_requests[i] != NULL); ++i) {
      delete_request_info(m_requests[i]);
    }
    for (u32 i=0; (i<8) && (m_responses[i] != NULL); ++i) {
      delete_response_info(m_responses[i]);
    }
  }

  // Cancel notified events
  m_router_thread_event.cancel();
  m_response_arbiter_thread_event.cancel();
  m_waiting_reads_thread_event.cancel();
  m_outstanding_write_event.cancel();

  xtsc_reset_processes(m_process_handles);
}



void xtsc_component::xtsc_router::change_clock_period(u32 clock_period_factor) {
  m_clock_period = sc_get_time_resolution() * clock_period_factor;
  XTSC_INFO(m_text, "change_clock_period(" << clock_period_factor << ") => " << m_clock_period);
  compute_delays();
}



void xtsc_component::xtsc_router::compute_delays() {
  // Convert delays from an integer number of periods to sc_time values
  u32 nacc_wait_time    = m_router_parms.get_u32("nacc_wait_time");
  if (nacc_wait_time == 0xFFFFFFFF) {
    m_nacc_wait_time = m_clock_period;
  }
  else {
    m_nacc_wait_time = sc_get_time_resolution() * nacc_wait_time;
    if (m_nacc_wait_time > m_clock_period) {
      ostringstream oss;
      oss << "xtsc_router '" << name() << "': \"nacc_wait_time\" of " << m_nacc_wait_time << " exceeds clock period of "
          << m_clock_period;
      throw xtsc_exception(oss.str());
    }
  }

  m_request_delay       = m_clock_period * m_router_parms.get_u32("request_delay");
  m_response_delay      = m_clock_period * m_router_parms.get_u32("response_delay");
  m_response_repeat     = m_clock_period * m_router_parms.get_u32("response_repeat");
  m_recovery_time       = m_clock_period * m_router_parms.get_u32("recovery_time");

  u32 read_delay        = m_router_parms.get_u32("read_delay");
  u32 write_delay       = m_router_parms.get_u32("write_delay");

  m_read_delay          = ((read_delay  == 0xFFFFFFFF) ? m_request_delay : (m_clock_period * read_delay));
  m_write_delay         = ((write_delay == 0xFFFFFFFF) ? m_request_delay : (m_clock_period * write_delay));
}



void xtsc_component::xtsc_router::man(ostream& os) {
  os << " xtsc_router supports watchfilters using xtsc_filter kinds of 'xtsc_request', 'xtsc_response', 'xtsc_peek', and 'xtsc_poke'."
     << endl;
}


void xtsc_component::xtsc_router::execute(const string&                 cmd_line, 
                                          const vector<string>&         words,
                                          const vector<string>&         words_lc,
                                          ostream&                      result)
{
  ostringstream res;

  if (false) {
  }
  else if (words[0] == "change_clock_period") {
    u32 clock_period_factor = xtsc_command_argtou32(cmd_line, words, 1);
    res << m_clock_period.value();
    change_clock_period(clock_period_factor);
  }
  else if (words[0] == "dump_filtered_request") {
    res << m_filtered_request;
  }
  else if (words[0] == "dump_filtered_response") {
    res << m_filtered_response;
  }
  else if (words[0] == "dump_profile_results") {
    dump_profile_results(res);
  }
  else if (words[0] == "dump_transaction_id_counts") {
    bool verbose = false;
    if (words.size() > 1) {
      verbose = xtsc_command_argtobool(cmd_line, words, 1);
    }
    dump_transaction_id_counts(res, verbose);
  }
  else if (words[0] == "peek") {
    xtsc_address start_address = xtsc_command_argtou64(cmd_line, words, 1);
    u32          num_bytes     = xtsc_command_argtou32(cmd_line, words, 2);
    u8 *buffer = new u8[num_bytes];
    m_request_impl.nb_peek(start_address, num_bytes, buffer);
    ostringstream oss;
    oss << setfill('0') << hex;
    for (u32 i=0; i<num_bytes; ++i) {
      oss << "0x" << setw(2) << (u32) buffer[i];
      if (i < num_bytes-1) {
        oss << " ";
      }
    }
    res << oss.str();
    delete [] buffer;
  }
  else if (words[0] == "poke") {
    xtsc_address start_address = xtsc_command_argtou64(cmd_line, words, 1);
    u32          num_bytes     = xtsc_command_argtou32(cmd_line, words, 2);
    if (words.size() != num_bytes+3) {
      ostringstream oss;
      oss << "Command '" << cmd_line << "' specifies num_bytes=" << num_bytes << " but contains " << (words.size()-3)
          << " byte arguments.";
      throw xtsc_exception(oss.str());
    }
    if (num_bytes) {
      u8 *buffer = new u8[num_bytes];
      for (u32 i=0; i<num_bytes; ++i) {
        buffer[i] = (u8) xtsc_command_argtou32(cmd_line, words, 3+i);
      }
      m_request_impl.nb_poke(start_address, num_bytes, buffer);
      delete [] buffer;
    }
  }
  else if (words[0] == "reset") {
    reset();
  }
  else if (words[0] == "watchfilter_add") {
    sc_event& event = xtsc_event_get(words[2]);
    res << watchfilter_add(words[1], event);
  }
  else if (words[0] == "watchfilter_dump") {
    watchfilter_dump(res);
  }
  else if (words[0] == "watchfilter_remove") {
    u32 watchfilter = ((words[1] == "*") ? 0xFFFFFFFF : xtsc_command_argtou32(cmd_line, words, 1));
    res << watchfilter_remove(watchfilter);
  }
  else {
    ostringstream oss;
    oss << name() << "::" << __FUNCTION__ << "() called for unknown command '" << cmd_line << "'.";
    throw xtsc_exception(oss.str());
  }

  result << res.str();
}



void xtsc_component::xtsc_router::connect(xtsc_arbiter& arbiter) {
  arbiter.m_request_port(m_request_export);
  m_respond_port(arbiter.m_respond_export);
}



void xtsc_component::xtsc_router::connect(xtsc_core& core, const char *memory_port_name, u32 port_num) {
  string lc = (memory_port_name ? memory_port_name : "");
  transform(lc.begin(), lc.end(), lc.begin(), ::tolower);
  if (lc == "inbound_pif" || lc == "snoop") {
    if (port_num >= m_num_slaves) {
      ostringstream oss;
      oss << "xtsc_router '" << name() << "':  Invalid port_num specified to xtsc_router::connect():  port_num=" << port_num;
      if (m_num_slaves) {
        oss << ".  Valid range is 0 to " << (m_num_slaves - 1) << ".";
      }
      else {
        oss << ".  This router has no slave ports.";
      }
      throw xtsc_exception(oss.str());
    }
    (*m_request_ports[port_num])(core.get_request_export(memory_port_name));
    core.get_respond_port(memory_port_name)(*m_respond_exports[port_num]);
  }
  else {
    core.get_request_port(memory_port_name)(m_request_export);
    m_respond_port(core.get_respond_export(memory_port_name));
  }
}



void xtsc_component::xtsc_router::connect(xtsc_dma_engine& dma_engine) {
  dma_engine.m_request_port(m_request_export);
  m_respond_port(dma_engine.m_respond_export);
}



void xtsc_component::xtsc_router::connect(xtsc_master& master) {
  master.m_request_port(m_request_export);
  m_respond_port(master.m_respond_export);
}



void xtsc_component::xtsc_router::connect(xtsc_memory_trace& memory_trace, u32 port_num) {
  u32 num_ports = memory_trace.get_num_ports();
  if (port_num >= num_ports) {
    ostringstream oss;
    oss << "Invalid port_num=" << port_num << " in connect(): " << endl;
    oss << memory_trace.kind() << " '" << memory_trace.name() << "' has " << num_ports << " ports numbered from 0 to "
        << num_ports-1 << endl;
    throw xtsc_exception(oss.str());
  }
  (*memory_trace.m_request_ports[port_num])(m_request_export);
  m_respond_port(*memory_trace.m_respond_exports[port_num]);
}



void xtsc_component::xtsc_router::connect(xtsc_router& router, u32 port_num) {
  u32 num_slaves = router.get_num_slaves();
  if (port_num >= num_slaves) {
    ostringstream oss;
    oss << "Invalid port_num=" << port_num << " in connect(): " << endl;
    oss << router.kind() << " '" << router.name() << "' has " << num_slaves << " ports numbered from 0 to " << num_slaves-1 << endl;
    throw xtsc_exception(oss.str());
  }
  (*router.m_request_ports[port_num])(m_request_export);
  m_respond_port(*router.m_respond_exports[port_num]);
}



void xtsc_component::xtsc_router::connect(xtsc_pin2tlm_memory_transactor& pin2tlm, u32 port_num) {
  u32 num_slaves = pin2tlm.get_num_ports();
  if (port_num >= num_slaves) {
    ostringstream oss;
    oss << "Invalid port_num=" << port_num << " in connect(): " << endl;
    oss << pin2tlm.kind() << " '" << pin2tlm.name() << "' has " << num_slaves << " ports numbered from 0 to " << num_slaves-1 << endl;
    throw xtsc_exception(oss.str());
  }
  (*pin2tlm.m_request_ports[port_num])(m_request_export);
  m_respond_port(*pin2tlm.m_respond_exports[port_num]);
}



void xtsc_component::xtsc_router::connect(xtsc_tlm22xttlm_transactor& tlm22xttlm, u32 port_num) {
  u32 num_slaves = tlm22xttlm.get_num_ports();
  if (port_num >= num_slaves) {
    ostringstream oss;
    oss << "Invalid port_num=" << port_num << " in connect(): " << endl;
    oss << tlm22xttlm.kind() << " '" << tlm22xttlm.name() << "' has " << num_slaves << " ports numbered from 0 to " << num_slaves-1
        << endl;
    throw xtsc_exception(oss.str());
  }
  (*tlm22xttlm.m_request_ports[port_num])(m_request_export);
  m_respond_port(*tlm22xttlm.m_respond_exports[port_num]);
}



u32 xtsc_component::xtsc_router::watchfilter_add(const string& filter_name, sc_event& event) {
  const xtsc_filter& filter = xtsc_filter_get(filter_name);
  const string& filter_kind = filter.get_kind();
  if ((filter_kind != "xtsc_peek") && (filter_kind != "xtsc_poke") && (filter_kind != "xtsc_request") && (filter_kind != "xtsc_response")) {
    ostringstream oss;
    oss << kind() << "::" << __FUNCTION__ << "() does not support filter kind of '" << filter_kind << "'";
    throw xtsc_exception(oss.str());
  }
  watchfilter_info *p_watchfilter_info = new watchfilter_info(filter_kind, filter_name, event);
  u32 watchfilter = xtsc_get_next_watchfilter_number();
  p_watchfilter_info->m_watchfilter = watchfilter;
  m_watchfilters[watchfilter] = p_watchfilter_info;
  if (filter_kind == "xtsc_peek") {
    m_peek_watchfilters.insert(watchfilter);
    m_filter_peeks = true;
  }
  else if (filter_kind == "xtsc_poke") {
    m_poke_watchfilters.insert(watchfilter);
    m_filter_pokes = true;
  }
  else if (filter_kind == "xtsc_request") {
    m_request_watchfilters.insert(watchfilter);
    m_filter_requests = true;
  }
  else if (filter_kind == "xtsc_response") {
    m_response_watchfilters.insert(watchfilter);
    m_filter_responses = true;
  }
  else {
    ostringstream oss;
    oss << "Program Bug: " << kind() << "::" << __FUNCTION__ << "(): Unhandled case of xtsc_filter kind of '" << filter_kind << "'";
    throw xtsc_exception(oss.str());
  }
  return watchfilter;
}



void xtsc_component::xtsc_router::watchfilter_dump(ostream& os) {
  for (map<u32, watchfilter_info*>::const_iterator i = m_watchfilters.begin(); i != m_watchfilters.end(); ++i) {
    os << i->first << " " << i->second->m_filter_kind << " " << i->second->m_filter_name << endl;
  }
}



u32 xtsc_component::xtsc_router::watchfilter_remove(u32 watchfilter) {
  if (watchfilter == 0xFFFFFFFF) {
    u32 cnt = m_peek_watchfilters    .size() +
              m_poke_watchfilters    .size() + 
              m_request_watchfilters .size() + 
              m_response_watchfilters.size();

    m_peek_watchfilters    .clear();
    m_poke_watchfilters    .clear();
    m_request_watchfilters .clear();
    m_response_watchfilters.clear();

    m_filter_peeks     = false;
    m_filter_pokes     = false;
    m_filter_requests  = false;
    m_filter_responses = false;

    return cnt;
  }
  map<u32, watchfilter_info*>::iterator i = m_watchfilters.find(watchfilter);
  if (i == m_watchfilters.end()) {
    ostringstream oss;
    oss << this->kind() << "::" << __FUNCTION__ << "(): '" << name() << "' does not have a watchfilter of " << watchfilter << "."
        << "  Here are the existing watchfilters:" << endl;
    watchfilter_dump(oss);
    throw xtsc_exception(oss.str());
  }
  if (i->second->m_filter_kind == "xtsc_peek") {
    m_peek_watchfilters.erase(watchfilter);
    m_filter_peeks = (m_peek_watchfilters.size() != 0);
  }
  else if (i->second->m_filter_kind == "xtsc_poke") {
    m_poke_watchfilters.erase(watchfilter);
    m_filter_pokes = (m_poke_watchfilters.size() != 0);
  }
  else if (i->second->m_filter_kind == "xtsc_request") {
    m_request_watchfilters.erase(watchfilter);
    m_filter_requests = (m_request_watchfilters.size() != 0);
  }
  else if (i->second->m_filter_kind == "xtsc_response") {
    m_response_watchfilters.erase(watchfilter);
    m_filter_responses = (m_response_watchfilters.size() != 0);
  }
  else {
    ostringstream oss;
    oss << "Program Bug: " << this->kind() << "::" << __FUNCTION__ << "(): Unhandled case of filter kind of '" << i->second->m_filter_kind
        << "'";
    throw xtsc_exception(oss.str());
  }
  delete i->second;
  m_watchfilters.erase(i);
  return 1;
}



void xtsc_component::xtsc_router::dump_profile_results(ostream& os) {
  if (m_profile_buffers) {
    sc_time sys_clock_period = xtsc_get_system_clock_period(); 
    double cycles =  m_max_num_requests_timestamp / sys_clock_period;
    os  << "Max buffered requests: " << setw(10) << m_max_num_requests << " - " 
        << setw(8) << setprecision(1) << std::fixed << cycles << " - tag=" << m_max_num_requests_tag << endl;         
    for (u32 i=0; i<m_num_slaves; i++) {
      cycles = m_max_num_responses_timestamp[i] / sys_clock_period;
      os  << "Max buffered responses["<< i << "]: " << setw(6) << m_max_num_responses[i] << " - " 
          << setw(8) << setprecision(1) << std::fixed << cycles << " - tag=" << m_max_num_responses_tag[i] << endl;  
    }
  }
  else {
    os  << "\"profile_buffers\" is not enabled." << endl;
  }  
}



void xtsc_component::xtsc_router::end_of_simulation() {
  if (m_profile_buffers) {
    ostringstream oss;
    dump_profile_results(oss);
    string log_str  = oss.str();
    log_str = log_str.substr(0, log_str.length()-1);
    xtsc_log_multiline(m_text, INFO_LOG_LEVEL, log_str);  
  }
  if (m_flexible_request_id) {
    ostringstream oss;
    u32 total = dump_transaction_id_counts(oss, false);
    if (total) {
      string log_str  = oss.str();
      log_str = log_str.substr(0, log_str.length()-1);
      xtsc_log_multiline(m_text, WARN_LOG_LEVEL, log_str);  
    }
  }
}



void xtsc_component::xtsc_router::reset_fifos() {
  wait(SC_ZERO_TIME);
  if (m_response_fifos) {
    for (u32 i=0; i<m_num_slaves; i++) {
      while (m_response_fifos[i]->num_available()) {
        response_info *p_response_info;
        m_response_fifos[i]->nb_read(p_response_info);
        delete_response_info(p_response_info);
      }
    }
  }
  while (m_request_fifo.num_available()) {
    request_info *p_request_info;
    m_request_fifo.nb_read(p_request_info);
    delete_request_info(p_request_info);
  }
}



void xtsc_component::xtsc_router::router_thread(void) {
  request_info *p_request_info = NULL;

  try {
    // Reset internal fifos
    reset_fifos();

    while (true) {
      wait(m_router_thread_event);
      XTSC_DEBUG(m_text, "router_thread woke up.");
      while (m_request_fifo.num_available() || m_ready_reads_fifo.num_available()) {

        if (m_ready_reads_fifo.num_available()) { //Prioritize this request first
          m_ready_reads_fifo.nb_read(p_request_info);
          XTSC_DEBUG(m_text, "handle waiting read: " << p_request_info->m_request);
          handle_request(p_request_info);
          delete_request_info(p_request_info);
        }
        else {
          // Get our current transaction
          m_request_fifo.nb_read(p_request_info);
          XTSC_DEBUG(m_text, "router_thread() got: " << p_request_info->m_request);
          // Calculate delay (net => No Earlier Than time)
          xtsc_request::type_t type = p_request_info->m_request.get_type();
          sc_time req_delay         = ((type == xtsc_request::READ) ||
                                       (type == xtsc_request::BLOCK_READ) ||
                                       (type == xtsc_request::BURST_READ) ||
                                       (type == xtsc_request::SNOOP)) ? m_read_delay : m_write_delay;
          sc_time receipt_net       = p_request_info->m_time_stamp + req_delay;
          sc_time last_request_net  = m_last_request_time_stamp + (m_delay_from_receipt ? m_recovery_time : req_delay);
          sc_time latest_net        = (receipt_net > last_request_net) ? receipt_net : last_request_net;
          sc_time now               = sc_time_stamp();
          sc_time delay = (latest_net <= now) ? SC_ZERO_TIME : (latest_net - now);
          XTSC_DEBUG(m_text, "router_thread() doing wait for " << delay);
          wait(delay);
        
          if (m_use_wait_on_outstanding_write && check_outstanding_write(p_request_info)) {
            //Park waiting read into a seperate fifo
            XTSC_DEBUG(m_text, "Push read request: " << p_request_info->m_request << " into m_waiting_reads_fifo");
            m_waiting_reads_fifo.nb_write(p_request_info);
            m_waiting_reads_thread_event.notify(SC_ZERO_TIME);
          }
          else {
            bool delete_request_info_later = false;
            if (m_use_wait_on_outstanding_write      && 
                !p_request_info->m_request.is_read() && 
                p_request_info->m_request.get_transfer_number() == 1) {
              //bookkeep first write request
              delete_request_info_later = true;
              m_outstanding_writes_map[p_request_info->m_request.get_tag()] = p_request_info;
            }
            handle_request(p_request_info);
            if (!delete_request_info_later) {
              delete_request_info(p_request_info);
            }
          } 
        } //if (m_request_fifo.num_available()..)..else
      }
    } //while (true)
  }
  catch (const sc_unwind_exception& error) { throw; }
  catch (const exception& error) {
    ostringstream oss;
    oss << "std::exception caught in router_thread of " << kind() << " '" << name() << "'." << endl;
    oss << "what(): " << error.what() << endl;
    xtsc_log_multiline(m_text, log4xtensa::FATAL_LOG_LEVEL, oss.str(), 2);
    throw;
  }

}

void xtsc_component::xtsc_router::waiting_reads_thread() {

  try {
    // Reset internal fifos
    reset_fifos();

    while (true) {
      XTSC_DEBUG(m_text, "waiting_reads_thread going to sleep.");
      wait(m_waiting_reads_thread_event);
      XTSC_DEBUG(m_text, "waiting_reads_thread woke up.");

      while (m_waiting_reads_fifo.num_available()) {

        // Get our current transaction
        request_info *p_request_info = NULL;
        m_waiting_reads_fifo.nb_read(p_request_info);
        XTSC_DEBUG(m_text, "waiting_reads_thread got: " << p_request_info->m_request);

        xtsc_address address8 = p_request_info->m_request.get_byte_address();
        while(check_outstanding_write(p_request_info)) {
          XTSC_DEBUG(m_text, "Waiting Read: " << p_request_info->m_request);
          wait(m_outstanding_write_event);
        }

        m_ready_reads_fifo.nb_write(p_request_info);
        //Notify router_thread to handle this request
        XTSC_DEBUG(m_text, "Notify m_router_thread_event to handle waiting read");
        m_router_thread_event.notify(SC_ZERO_TIME); 
      }
    } //while (true)
  }
  catch (const sc_unwind_exception& error) { throw; }
  catch (const exception& error) {
    ostringstream oss;
    oss << "std::exception caught in waiting_reads_thread of " << kind() << " '" << name() << "'." << endl;
    oss << "what(): " << error.what() << endl;
    xtsc_log_multiline(m_text, log4xtensa::FATAL_LOG_LEVEL, oss.str(), 2);
    throw;
  }

}


bool xtsc_component::xtsc_router::check_outstanding_write(request_info *p_request_info) {

  if (!p_request_info->m_request.is_read())
    return false;

  string           type_name                    = (string)p_request_info->m_request.get_type_name();
  xtsc_address     address8                     = p_request_info->m_request.get_byte_address();
  u32              num_transfers                = p_request_info->m_request.get_num_transfers();
  u32              size8                        = p_request_info->m_request.get_byte_size();
  u32              total_bytes_to_transfer      = num_transfers*size8;
  xtsc_address     read_start_address8          = address8;

  if (type_name == "BLOCK_READ" ) { //handle CWF
    read_start_address8 = (address8 / total_bytes_to_transfer) * total_bytes_to_transfer;  //lower wrap boundary
  }
  xtsc_address     read_end_address8            = read_start_address8 + total_bytes_to_transfer - 1;

  for (auto it = m_outstanding_writes_map.begin(); it != m_outstanding_writes_map.end(); it++) {
    u32              write_num_transfers        = it->second->m_request.get_num_transfers();
    u32              write_size8                = it->second->m_request.get_byte_size();
    xtsc_address     write_start_address8       = it->second->m_request.get_byte_address();
    xtsc_address     write_end_address8         = write_start_address8 + write_num_transfers*write_size8 - 1;
    //Look for overlapping overlapping read and write blocks
    if ((read_start_address8 >= write_start_address8 && read_start_address8 <= write_end_address8) ||
        (read_end_address8   >= write_start_address8 && read_end_address8   <= write_end_address8) ||
        (read_start_address8 <= write_start_address8 && read_end_address8   >= write_end_address8)) {
      XTSC_DEBUG(m_text, "Found an Outstanding Write: " << it->second->m_request);
      m_waiting_reads_address_map[write_start_address8] = true;
      return true;
    }
  }

  XTSC_DEBUG(m_text, "No outstanding write for read: " << p_request_info->m_request);
  return false;
}



// When acting as PIF width converter (pwc)
void xtsc_component::xtsc_router::router_pwc_thread(void) {

  try {
    // Reset internal fifos
    reset_fifos();

    while (true) {
      wait(m_router_thread_event);
      XTSC_DEBUG(m_text, "router_pwc_thread woke up.");
      while (m_request_fifo.num_available()) {
        // Get our current transaction
        request_info *p_request_info = NULL;
        m_request_fifo.nb_read(p_request_info);
        XTSC_DEBUG(m_text, "router_pwc_thread() got: " << p_request_info->m_request);

        xtsc_address    dummy            = p_request_info->m_request.get_byte_address();
        u32             port_num         = get_port_and_apply_address_translation(dummy);
        u32             slave_byte_width = (port_num >= m_num_slaves) ? m_master_byte_width : m_slave_byte_widths[port_num];

        if ((m_master_byte_width == slave_byte_width) || (p_request_info->m_request.is_axi_protocol() && (m_master_byte_width < slave_byte_width))) {
          m_requests[0] = p_request_info;
        }
        else {
          convert_request(p_request_info, slave_byte_width);
        }

        for (u32 i=0; (i<8) && (m_requests[i] != NULL); ++i) {
          // Calculate delay (net => No Earlier Than time)
          xtsc_request::type_t type = m_requests[i]->m_request.get_type();
          sc_time req_delay         = ((type == xtsc_request::READ) ||
                                       (type == xtsc_request::BLOCK_READ) ||
                                       (type == xtsc_request::BURST_READ) ||
                                       (type == xtsc_request::SNOOP)) ? m_read_delay : m_write_delay;
          sc_time receipt_net       = m_requests[i]->m_time_stamp + req_delay;
          sc_time last_request_net  = m_last_request_time_stamp + (m_delay_from_receipt ? m_recovery_time : req_delay);
          sc_time latest_net        = (receipt_net > last_request_net) ? receipt_net : last_request_net;
          sc_time now               = sc_time_stamp();
          sc_time delay = (latest_net <= now) ? SC_ZERO_TIME : (latest_net - now);
          XTSC_DEBUG(m_text, "router_pwc_thread() doing wait for " << delay);
          wait(delay);
          handle_request(m_requests[i]);
          delete_request_info(m_requests[i]);
        }

      }
    }

  }
  catch (const sc_unwind_exception& error) { throw; }
  catch (const exception& error) {
    ostringstream oss;
    oss << "std::exception caught in router_pwc_thread of " << kind() << " '" << name() << "'." << endl;
    oss << "what(): " << error.what() << endl;
    xtsc_log_multiline(m_text, log4xtensa::FATAL_LOG_LEVEL, oss.str(), 2);
    throw;
  }

}



void xtsc_component::xtsc_router::convert_request(request_info*& p_request_info, u32 slave_byte_width) {
  req_rsp_info         *p_req_rsp_info  = NULL;
  bool                  first_transfer  = (m_pending_request_tag == 0);
  xtsc_request::type_t  type            = p_request_info->m_request.get_type();
  xtsc_request::burst_t burst_type      = p_request_info->m_request.get_burst_type();
  u32                   size            = p_request_info->m_request.get_byte_size();
  u32                   max_num_xfers   = (p_request_info->m_request.is_axi_protocol() && (burst_type==xtsc_request::INCR))? 256 : 16;

  bool                  wrap_possible   = ((type == xtsc_request::BLOCK_READ) || (burst_type == xtsc_request::WRAP));

  XTSC_DEBUG(m_text, "Converting to " << slave_byte_width << "-byte PIF: " << p_request_info->m_request);

  if ((type != xtsc_request::READ       ) &&
      (type != xtsc_request::BLOCK_READ ) &&
      (type != xtsc_request::WRITE      ) &&
      (type != xtsc_request::BLOCK_WRITE) &&
      (type != xtsc_request::RCW        ) &&
     !(type == xtsc_request::BURST_READ   && burst_type != xtsc_request::NON_AXI) &&
     !(type == xtsc_request::BURST_WRITE  && burst_type != xtsc_request::NON_AXI))
  {
    ostringstream oss;
    oss << kind() << " '" << name() << "' received a " << xtsc_request::get_type_name(type)
        << " request which is not supported for PIF width conversion: " << p_request_info->m_request;
    throw xtsc_exception(oss.str());
  }

  if ((type == xtsc_request::RCW) && (size > slave_byte_width)) {
    ostringstream oss;
    oss << kind() << " '" << name() << "' received a RCW request with a size greater than downstream PIF width ("
        << slave_byte_width << "): " << p_request_info->m_request;
    throw xtsc_exception(oss.str());
  }

  if (first_transfer) {
    p_req_rsp_info = new_req_rsp_info(p_request_info);
    m_req_rsp_table.insert(pair<xtsc::u64, req_rsp_info*>(p_request_info->m_request.get_tag(), p_req_rsp_info));
    XTSC_DEBUG(m_text, "convert_request() adding request to the m_req_rsp_table map!" << p_request_info->m_request);
    request_info *p_req_info = new_request_info(*p_request_info);

    p_req_rsp_info->m_num_last_xfer_rsp_expected = 1;   // Overrides below

    if (!p_request_info->m_request.get_last_transfer()) {
      m_pending_request_tag = p_request_info->m_request.get_tag();
    }
    if (m_master_byte_width > slave_byte_width) {
      // Master is wider than slave
      m_requests[0] = p_req_info;
      if (type == xtsc_request::READ || (type == xtsc_request::BURST_READ && (p_req_info->m_request.get_num_transfers() == 1))) {
        if (size > slave_byte_width) {
          p_req_info->m_request.set_byte_size(slave_byte_width);
          xtsc_byte_enables     mask    = ((size == 8) ? 0xFF : ((size == 16) ? 0xFFFF : 0xFFFFFFFF));
          xtsc_byte_enables     be      = p_request_info->m_request.get_byte_enables();
          u32                   reps    = size / slave_byte_width;
          // Optionally use BLOCK_READ if all bytes are enabled
          if (m_use_block_requests && ((be & mask) == mask)) {
            p_req_info->m_request.set_type((burst_type == xtsc_request::NON_AXI) ? xtsc_request::BLOCK_READ : xtsc_request::BURST_READ);
            p_req_info->m_request.set_num_transfers(reps);
            p_req_info->m_request.set_byte_enables((slave_byte_width == 4) ? 0xF : ((slave_byte_width == 8) ? 0xFF : 0xFFFF));
          }
          else {
            xtsc_byte_enables slave_mask = ((slave_byte_width == 4) ? 0xF : ((slave_byte_width == 8) ? 0xFF : 0xFFFF));
            p_req_info->m_request.set_byte_enables(be & slave_mask);
            xtsc_address address8 = p_req_info->m_request.get_byte_address();
            p_req_rsp_info->m_num_last_xfer_rsp_expected = reps;
            for (u32 i=1; i < reps; ++i) {
              be >>= slave_byte_width;
              address8 += slave_byte_width;
              
              m_requests[i] = new_request_info(*p_req_info);
              m_requests[i]->m_request.initialize(type,
                                                  address8,
                                                  slave_byte_width,
                                                  0,
                                                  1,
                                                  be & slave_mask,
                                                  true,
                                                  p_req_info->m_request.get_route_id(),
                                                  p_req_info->m_request.get_id(),
                                                  p_req_info->m_request.get_priority(),
                                                  p_req_info->m_request.get_pc(),
                                                  p_req_info->m_request.get_burst_type(),
                                                  p_req_info->m_request.is_apb_protocol());

              m_req_rsp_table.insert(pair<xtsc::u64, req_rsp_info*>(m_requests[i]->m_request.get_tag(), p_req_rsp_info));
              XTSC_DEBUG(m_text, "convert_request() adding request to the m_req_rsp_table map!" << m_requests[i]->m_request);
            }
          }
        }
      }
      else if (type == xtsc_request::BLOCK_READ || type == xtsc_request::BURST_READ) {
        u32 total_bytes   = m_master_byte_width * p_request_info->m_request.get_num_transfers();
        u32 num_transfers = total_bytes / slave_byte_width;
        u32 reps          = (num_transfers + max_num_xfers - 1) / max_num_xfers;
        p_req_info->m_request.set_byte_size(slave_byte_width);
        p_req_info->m_request.set_num_transfers(num_transfers < max_num_xfers ? num_transfers : max_num_xfers);
        p_req_info->m_request.set_byte_enables((slave_byte_width == 4) ? 0xF : ((slave_byte_width == 8) ? 0xFF : 0xFFFF));
        xtsc_address address8 = p_req_info->m_request.get_byte_address();
        confirm_alignment(total_bytes, address8, p_req_info->m_request);
        p_req_rsp_info->m_num_last_xfer_rsp_expected = reps;
        xtsc_address upper_boundary = (address8 % total_bytes == 0) ? (address8 + total_bytes) : ((address8 & -total_bytes) + total_bytes);

        for (u32 i=1; i < reps; ++i) {
          m_requests[i] = new_request_info(*p_req_info);
          address8 += slave_byte_width * max_num_xfers;
          if (wrap_possible) {
            address8 = address8 & -(slave_byte_width * max_num_xfers);
            if (address8 >= upper_boundary)
              address8-=total_bytes;
          }
          m_requests[i]->m_request.initialize(type,
                                              address8,
                                              slave_byte_width,
                                              0,
                                              max_num_xfers,
                                              p_req_info->m_request.get_byte_enables(),
                                              true,
                                              p_req_info->m_request.get_route_id(),
                                              p_req_info->m_request.get_id(),
                                              p_req_info->m_request.get_priority(),
                                              p_req_info->m_request.get_pc(),
                                              p_req_info->m_request.get_burst_type(),
                                              p_req_info->m_request.is_apb_protocol());

          m_req_rsp_table.insert(pair<xtsc::u64, req_rsp_info*>(m_requests[i]->m_request.get_tag(), p_req_rsp_info));
          XTSC_DEBUG(m_text, "convert_request() adding request to the m_req_rsp_table map!" << m_requests[i]->m_request);
        }

        //This information will be used to correctly reorder the memory resposnes before they are passed to the core.
        if (wrap_possible) {
          u64 tag = p_request_info->m_request.get_tag();
          if(m_issued_split_requests.find(tag) == m_issued_split_requests.end()) {
            xtsc::xtsc_address base_addr = p_req_info->m_request.get_byte_address()
                                           & ~((slave_byte_width * p_req_info->m_request.get_num_transfers()) - 1);
            xtsc::xtsc_address end_addr  = (base_addr + (slave_byte_width * (p_req_info->m_request.get_num_transfers()) - 1))
                                           & ~(m_master_byte_width - 1);
            u8 post_wrap_cnt = (u8)((p_req_info->m_request.get_byte_address() - base_addr) / m_master_byte_width);
            u8 pre_wrap_cnt  = post_wrap_cnt ? ((u8)((end_addr - p_req_info->m_request.get_byte_address()) / m_master_byte_width) + 1) : 0;
            split_request new_block_read = {p_req_info->m_request.get_byte_address(), pre_wrap_cnt, post_wrap_cnt};
            m_issued_split_requests.insert(pair<xtsc::u64, split_request>(tag, new_block_read));
          }
          else {
            ostringstream oss;
            oss << kind() << " '" << name() << "' PWC recieved duplicate tags in convert_request! " << p_request_info->m_request;
            throw xtsc_exception(oss.str());
          }
        }
      }
      else if (type == xtsc_request::WRITE || (type == xtsc_request::BURST_WRITE && (p_req_info->m_request.get_num_transfers() == 1))) {
        if (size > slave_byte_width) {
          p_req_info->m_request.set_byte_size(slave_byte_width);
          xtsc_byte_enables     mask    = ((size == 8) ? 0xFF : ((size == 16) ? 0xFFFF : 0xFFFFFFFF));
          xtsc_byte_enables     be      = p_request_info->m_request.get_byte_enables();
          const u8             *p_src   = p_request_info->m_request.get_buffer();
          u32                   reps    = size / slave_byte_width;
          // Optionally use BLOCK_WRITE if all bytes are enabled
          if (m_use_block_requests && ((be & mask) == mask)) {
            p_req_info->m_request.set_type((burst_type == xtsc_request::NON_AXI) ? xtsc_request::BLOCK_WRITE : xtsc_request::BURST_WRITE);
            p_req_info->m_request.set_last_transfer(false);
            p_req_info->m_request.set_num_transfers(reps);
            p_req_info->m_request.set_byte_enables((slave_byte_width == 4) ? 0xF : ((slave_byte_width == 8) ? 0xFF : 0xFFFF));
            xtsc_address address8 = p_req_info->m_request.get_byte_address();
            for (u32 i=1; i < reps; ++i) {
              m_requests[i] = new_request_info(*p_req_info);
              p_src += slave_byte_width;
              m_requests[i]->m_request.set_buffer(slave_byte_width, p_src);
              address8 += slave_byte_width;
              m_requests[i]->m_request.set_byte_address(address8);
            }
            m_requests[reps-1]->m_request.set_last_transfer(true);
          }
          else {
            xtsc_byte_enables slave_mask = ((slave_byte_width == 4) ? 0xF : ((slave_byte_width == 8) ? 0xFF : 0xFFFF));
            p_req_info->m_request.set_byte_enables(be & slave_mask);
            xtsc_address address8 = p_req_info->m_request.get_byte_address();
            p_req_rsp_info->m_num_last_xfer_rsp_expected = reps;
            for (u32 i=1; i < reps; ++i) {
              m_requests[i] = new_request_info(*p_req_info);
              be >>= slave_byte_width;
              address8 += slave_byte_width;
              p_src += slave_byte_width;
              m_requests[i]->m_request.initialize(type,
                                                  address8,
                                                  slave_byte_width,
                                                  0,
                                                  1,
                                                  be & slave_mask,
                                                  true,
                                                  p_req_info->m_request.get_route_id(),
                                                  p_req_info->m_request.get_id(),
                                                  p_req_info->m_request.get_priority(),
                                                  p_req_info->m_request.get_pc(),
                                                  p_req_info->m_request.get_burst_type(),
                                                  p_req_info->m_request.is_apb_protocol());

              m_requests[i]->m_request.set_buffer(slave_byte_width, p_src);

              m_req_rsp_table.insert(pair<xtsc::u64, req_rsp_info*>(m_requests[i]->m_request.get_tag(), p_req_rsp_info));
              XTSC_DEBUG(m_text, "convert_request() adding request to the m_req_rsp_table map!" << m_requests[i]->m_request);
            }
          }
        }
      }
      else if (type == xtsc_request::BLOCK_WRITE || type == xtsc_request::BURST_WRITE) {
        u32             total_bytes     = m_master_byte_width * p_request_info->m_request.get_num_transfers();
        u32             num_transfers   = total_bytes / slave_byte_width;
        u32             reps            = m_master_byte_width / slave_byte_width;
        const u8       *p_src           = p_request_info->m_request.get_buffer();
        p_req_info->m_request.set_byte_size(slave_byte_width);
        p_req_info->m_request.set_num_transfers(num_transfers < max_num_xfers ? num_transfers : max_num_xfers);
        p_req_info->m_request.set_byte_enables((slave_byte_width == 4) ? 0xF : ((slave_byte_width == 8) ? 0xFF : 0xFFFF));
        p_req_rsp_info->m_num_last_xfer_rsp_expected = (num_transfers <= max_num_xfers ? 1 : (num_transfers / max_num_xfers));
        p_req_rsp_info->m_block_write_address = p_req_info->m_request.get_byte_address() + slave_byte_width;
        for (u32 i=1; i < reps; ++i) {
          m_requests[i] = new_request_info(*p_req_info);
          p_src += slave_byte_width;
          m_requests[i]->m_request.set_buffer(slave_byte_width, p_src);
          m_requests[i]->m_request.set_byte_address(p_req_rsp_info->m_block_write_address);
          m_requests[i]->m_request.set_transfer_number(i + 1);
          p_req_rsp_info->m_block_write_address += slave_byte_width;
        }
        p_req_rsp_info->m_num_block_write_requests = reps;
      }
      else if (type == xtsc_request::RCW) {
        xtsc_byte_enables be         = p_request_info->m_request.get_byte_enables();
        xtsc_byte_enables slave_mask = ((slave_byte_width == 4) ? 0xF : ((slave_byte_width == 8) ? 0xFF : 0xFFFF));
        p_req_info->m_request.set_byte_enables(be & slave_mask);
      }
    }
    else {
      // Slave is wider than master
      // convert_request() is not called for BURST_READ and BURST_WRITE (i.e., AXI protocol) when slave is wider than master!
      if ((type == xtsc_request::READ) || (type == xtsc_request::WRITE) || (type == xtsc_request::RCW)) {
        m_requests[0] = p_req_info;
      }
      else if (type == xtsc_request::BLOCK_READ) {
        m_requests[0] = p_req_info;
        u32 total_bytes = m_master_byte_width * p_request_info->m_request.get_num_transfers();
        confirm_alignment(total_bytes, p_req_info->m_request.get_byte_address(), p_req_info->m_request);
        if (total_bytes <= slave_byte_width) {
          p_req_info->m_request.set_byte_size(total_bytes);
          p_req_info->m_request.set_type(xtsc_request::READ);
          p_req_info->m_request.set_num_transfers(1);
          p_req_info->m_request.set_byte_enables((total_bytes == 32) ? 0xFFFFFFFF : ((total_bytes == 16) ? 0xFFFF : 0xFF));
        }
        else {
          //Memory requests should be aligned to the slave_byte_width!
          p_req_info->m_request.set_byte_address((p_req_info->m_request.get_byte_address() & -slave_byte_width));
          p_req_info->m_request.set_byte_size(slave_byte_width);
          p_req_info->m_request.set_num_transfers(total_bytes / slave_byte_width);
          p_req_info->m_request.set_byte_enables((slave_byte_width == 32) ? 0xFFFFFFFF : ((slave_byte_width == 16) ? 0xFFFF : 0xFF));
        }
      }
      else if (type == xtsc_request::BLOCK_WRITE) {
        p_req_rsp_info->m_p_nascent_request = p_req_info;
        u32 total_bytes = m_master_byte_width * p_request_info->m_request.get_num_transfers();
        p_req_rsp_info->m_block_write_address = p_req_info->m_request.get_byte_address();
        if (total_bytes <= slave_byte_width) {
          p_req_info->m_request.set_byte_size(total_bytes);
          p_req_info->m_request.set_type(xtsc_request::WRITE);
          p_req_info->m_request.set_num_transfers(1);
          p_req_info->m_request.set_byte_enables((total_bytes == 32) ? 0xFFFFFFFF : ((total_bytes == 16) ? 0xFFFF : 0xFF));
        }
        else {
          p_req_info->m_request.set_byte_size(slave_byte_width);
          p_req_info->m_request.set_num_transfers(total_bytes / slave_byte_width);
          p_req_info->m_request.set_byte_enables((slave_byte_width == 32) ? 0xFFFFFFFF : ((slave_byte_width == 16) ? 0xFFFF : 0xFF));
        }
        p_req_rsp_info->m_num_block_write_requests = 1;
      }
    }
  }
  else {
    // Non-first transfer (BLOCK_WRITE or RCW)
    std::map<xtsc::u64, req_rsp_info*>::iterator itr = m_req_rsp_table.find(m_pending_request_tag);
    if (itr == m_req_rsp_table.end()) {
      ostringstream oss;
      oss << "Expected request tag = " << m_pending_request_tag << " was not found in m_pending_request_tag! ";
      throw xtsc_exception(oss.str());
    }
    else
      p_req_rsp_info = itr->second;

    xtsc_request::type_t original_type = p_req_rsp_info->m_p_first_request_info->m_request.get_type();
    if (type != original_type) {
      ostringstream oss;
      oss << "Expected " << xtsc_request::get_type_name(original_type) << " request but received: " << p_request_info->m_request;
      throw xtsc_exception(oss.str());
    }

    if (type == xtsc_request::RCW) {
      request_info *p_req_info = new_request_info(*p_request_info);
      m_requests[0] = p_req_info;
    }
    else if (type == xtsc_request::BLOCK_WRITE || type == xtsc_request::BURST_WRITE) {
      u32 total_bytes = m_master_byte_width * p_request_info->m_request.get_num_transfers();
      if (m_master_byte_width > slave_byte_width) {
        // Master is wider than slave
        request_info *p_req_info        = new_request_info(*p_request_info);
        m_requests[0]                   = p_req_info;
        u32             num_transfers   = total_bytes / slave_byte_width;
        u32             reps            = m_master_byte_width / slave_byte_width;
        const u8       *p_src           = p_request_info->m_request.get_buffer();
        u32             transfer_num    = p_request_info->m_request.get_transfer_number();
        u32             curr_num_trfs   = num_transfers < max_num_xfers ? num_transfers : max_num_xfers;
        xtsc_byte_enables     be        = ((slave_byte_width == 4) ? 0xF : ((slave_byte_width == 8) ? 0xFF : 0xFFFF));
        u32             curr_trf_num    = (transfer_num-1)*reps + 1;
        bool            new_tag_request = false;
        if (curr_trf_num%max_num_xfers == 1) {
          new_tag_request = true;
        }
        if (new_tag_request) {
          p_req_info->m_request.initialize(type,
                                           p_req_rsp_info->m_block_write_address,
                                           slave_byte_width,
                                           0,
                                           curr_num_trfs,
                                           be,
                                           false,
                                           p_req_info->m_request.get_route_id(),
                                           p_req_info->m_request.get_id(),
                                           p_req_info->m_request.get_priority(),
                                           p_req_info->m_request.get_pc(),
                                           p_req_info->m_request.get_burst_type(),
                                           p_req_info->m_request.is_apb_protocol());

          m_pending_request_tag = p_req_info->m_request.get_tag();

          m_req_rsp_table.insert(pair<xtsc::u64, req_rsp_info*>(p_req_info->m_request.get_tag(), p_req_rsp_info));
          XTSC_DEBUG(m_text, "convert_request() adding request to the m_req_rsp_table map!" << p_req_info->m_request);
        } else {
          if (type == xtsc_request::BLOCK_WRITE) {
            p_req_info->m_request.initialize(m_pending_request_tag,
                                             p_req_rsp_info->m_block_write_address,
                                             slave_byte_width,
                                             curr_num_trfs,
                                             false,
                                             p_req_info->m_request.get_route_id(),
                                             p_req_info->m_request.get_id(),
                                             p_req_info->m_request.get_priority(),
                                             p_req_info->m_request.get_pc());
          } else {
            p_req_info->m_request.initialize(p_req_info->m_request.get_hardware_address(),
                                             m_pending_request_tag,
                                             p_req_rsp_info->m_block_write_address,
                                             slave_byte_width,
                                             curr_num_trfs,
                                             curr_trf_num%max_num_xfers,
                                             be,
                                             p_req_info->m_request.get_route_id(),
                                             p_req_info->m_request.get_id(),
                                             p_req_info->m_request.get_priority(),
                                             p_req_info->m_request.get_pc(),
                                             p_req_info->m_request.get_burst_type());
          }
        }
        p_req_info->m_request.set_buffer(slave_byte_width, p_src);
        p_req_rsp_info->m_block_write_address += slave_byte_width;
        for (u32 i=1; i < reps; ++i) {
          m_requests[i] = new_request_info(*p_req_info);
          p_src += slave_byte_width;
          m_requests[i]->m_request.set_buffer(slave_byte_width, p_src);
          m_requests[i]->m_request.set_byte_address(p_req_rsp_info->m_block_write_address);
          m_requests[i]->m_request.set_transfer_number(((transfer_num-1)*reps + i)%max_num_xfers + 1);
          p_req_rsp_info->m_block_write_address += slave_byte_width;
        }
        p_req_rsp_info->m_num_block_write_requests += reps;
        if (p_request_info->m_request.get_last_transfer() || ((p_req_rsp_info->m_num_block_write_requests % max_num_xfers) == 0)) {
          m_requests[reps-1]->m_request.set_last_transfer(true);
        }
      }
      else {
        // Slave is wider than master
        request_info   *p_req_info      = p_req_rsp_info->m_p_nascent_request;
        u32             ratio           = slave_byte_width / m_master_byte_width ;
        u32             offset          = (p_req_rsp_info->m_num_block_write_requests % ratio) * m_master_byte_width;
        u32             next_offset     = offset + m_master_byte_width;
        u8             *p_dst           = p_req_info->m_request.get_buffer();
        const u8       *p_src           = p_request_info->m_request.get_buffer();
        bool            last            = p_request_info->m_request.get_last_transfer();
        memcpy(p_dst + offset, p_src, m_master_byte_width);
        if (last) {
          p_req_info->m_request.set_last_transfer(true);
        }
        p_req_rsp_info->m_num_block_write_requests += 1;
        if ((next_offset == slave_byte_width) || (next_offset == total_bytes)) {
          p_req_info->m_request.set_byte_address(p_req_rsp_info->m_block_write_address);
          p_req_rsp_info->m_block_write_address += slave_byte_width;
          m_requests[0] = p_req_rsp_info->m_p_nascent_request;
          p_req_rsp_info->m_p_nascent_request = (last ? NULL : new_request_info(*p_req_rsp_info->m_p_nascent_request));
          m_requests[0]->m_time_stamp = p_request_info->m_time_stamp;  // Base timing off this latest request which completes the bus
        }
      }
    }
    else {
      ostringstream oss;
      oss << "Program Bug: Only RCW|BLOCK_WRITE expected at line " << __LINE__ << " of " << __FILE__;
      throw xtsc_exception(oss.str());
    }

    if (p_request_info->m_request.get_last_transfer()) {
      m_pending_request_tag = 0;
    }

    // Note: When first_transfer is true p_request_info is deleted (as m_p_first_request_info) in delete_req_rsp_info()
    delete_request_info(p_request_info);
  }

}



void xtsc_component::xtsc_router::confirm_alignment(u32 total_bytes, xtsc_address address8, xtsc_request &request) {
  if (address8 % request.get_byte_size()){
    ostringstream oss;
    oss << kind() << " '" << name() << "' configured as PIF-width convertor received unaligned address: " << request;
    throw xtsc_exception(oss.str());
  }
}



void xtsc_component::xtsc_router::handle_response_filters(u32 port, const xtsc_response &response) {
  for (set<u32>::const_iterator i = m_response_watchfilters.begin(); i != m_response_watchfilters.end(); ++i) {
    u32 watchfilter = *i;
    map<u32, watchfilter_info*>::const_iterator j = m_watchfilters.find(watchfilter);
    if (j == m_watchfilters.end()) {
      ostringstream oss;
      oss << "Error: watchfilter #" << watchfilter << " missing from m_watchfilters at line " << __LINE__ << " of " << __FILE__;
      throw xtsc_exception(oss.str());
    }
    watchfilter_info *p_watchfilter_info = j->second;
    if (xtsc_filter_apply_xtsc_response(p_watchfilter_info->m_filter_name, port, response)) {
      m_filtered_response = response;
      p_watchfilter_info->m_event.notify(SC_ZERO_TIME);
      XTSC_INFO(m_text, response << " Watchfilter #" << p_watchfilter_info->m_watchfilter);
    }
  }
}



void xtsc_component::xtsc_router::handle_request(request_info *p_request_info) {
  xtsc_address address8 = p_request_info->m_request.get_byte_address();
  u32 port_num = 0;
  if (m_use_route_by_type) {
    u32 type = p_request_info->m_request.get_type();
    if (type == xtsc_request::RCW) {
      type = (p_request_info->m_request.get_last_transfer() ? RCW2 : RCW1);
    }
    port_num = get_port_by_type(type);
  }
  else if (m_use_route_by_priority) {
    port_num = m_priority_port_map[p_request_info->m_request.get_priority() & 0xF];
  }
  else {
    port_num = get_port_and_apply_address_translation(address8);
  }
  if (m_filter_requests) {
    for (set<u32>::const_iterator i = m_request_watchfilters.begin(); i != m_request_watchfilters.end(); ++i) {
      u32 watchfilter = *i;
      map<u32, watchfilter_info*>::const_iterator j = m_watchfilters.find(watchfilter);
      if (j == m_watchfilters.end()) {
        ostringstream oss;
        oss << "Error: watchfilter #" << watchfilter << " missing from m_watchfilters at line " << __LINE__ << " of " << __FILE__;
        throw xtsc_exception(oss.str());
      }
      watchfilter_info *p_watchfilter_info = j->second;
      if (xtsc_filter_apply_xtsc_request(p_watchfilter_info->m_filter_name, port_num, p_request_info->m_request)) {
        m_filtered_request = p_request_info->m_request;
        p_watchfilter_info->m_event.notify(SC_ZERO_TIME);
        XTSC_INFO(m_text, p_request_info->m_request << " Watchfilter #" << p_watchfilter_info->m_watchfilter);
      }
    }
  }
  if (port_num == DISCARD_REQUEST) {
    XTSC_INFO(m_text, p_request_info->m_request << " DISCARD_REQUEST");
  }
  else if (port_num == ADDRESS_ERROR) {
    xtsc_request& request = p_request_info->m_request;
    xtsc_response response(request, xtsc_response::RSP_ADDRESS_ERROR);
    u32 num_responses = (request.is_axi_protocol() && request.is_read()) ? request.get_num_transfers() : 1;
    for (u32 transfer_num = 1; transfer_num <= num_responses; ++transfer_num) {
      response.set_transfer_number(transfer_num);
      response.set_last_transfer(transfer_num == num_responses);
      u32 tries = 0;
      while (true) {
        tries += 1;
        XTSC_INFO(m_text, response << " Try #" << tries);
        xtsc_log_memory_response_event(m_binary, INFO_LOG_LEVEL, false, 0, m_log_data_binary, response);
        if (m_respond_port->nb_respond(response) || m_immediate_timing) {
          break;
        }
        wait(m_response_repeat);
      }
      if (!m_immediate_timing && (transfer_num < num_responses)) {
        wait(m_clock_period);
      }
    }
  }
  else if (port_num >= m_num_slaves) {
    ostringstream oss;
    oss << "xtsc_router '" << name() << "': Invalid port (0x" << hex << port_num << ") returned for address 0x" << hex << address8;
    throw xtsc_exception(oss.str());
  }
  else {
    p_request_info->m_request.set_byte_address(address8);
    u32 tries = 0;
    do {
      m_request_got_nacc = false;
      tries += 1;
      XTSC_INFO(m_text, p_request_info->m_request << " Port #" << port_num << " Try #" << tries);
      xtsc_log_memory_request_event(m_binary, INFO_LOG_LEVEL, false, port_num, m_log_data_binary,
                                    p_request_info->m_request);
      m_waiting_for_nacc = true;
      (*m_request_ports[port_num])->nb_request(p_request_info->m_request);
      if (!m_immediate_timing) {
        m_last_request_time_stamp = sc_time_stamp();
        wait(m_nacc_wait_time);
      }
      m_waiting_for_nacc = false;
    } while (m_request_got_nacc);
  }
}



void xtsc_component::xtsc_router::response_arbiter_thread(void) {
  try {

    while (true) {
      XTSC_DEBUG(m_text, "response_arbiter_thread going to sleep.  m_lock=" << m_lock << " m_token=" << m_token);
      wait(m_response_arbiter_thread_event);
      XTSC_DEBUG(m_text, "response_arbiter_thread woke up.");
      bool response_found;
      do {
        u32 next_token = m_token;
        response_found = false;
        do {
          if (!m_lock) {
            next_token = (next_token + 1) % m_num_slaves;
          }
          if (m_response_fifos[next_token]->num_available()) {
            response_found = true;
            response_info *p_response_info;
            m_response_fifos[next_token]->nb_read(p_response_info);
            XTSC_DEBUG(m_text, "response_arbiter_thread got: " << p_response_info->m_response);

            //Check if any read is waiting for this write
            if (m_use_wait_on_outstanding_write) {
              u64   tag  = p_response_info->m_response.get_tag();
              auto  it   = m_outstanding_writes_map.find(tag);
              if (it != m_outstanding_writes_map.end()) {
                //The response is for a write request
                XTSC_DEBUG(m_text, "Check if a read is waiting on this write");
                xtsc_address address8 = it->second->m_request.get_byte_address(); 
                if ((m_waiting_reads_address_map.find(address8) != m_waiting_reads_address_map.end()) && 
                    m_waiting_reads_address_map[address8]) {
                  //A read is waiting on this write
                  m_waiting_reads_address_map.erase(address8);
                  XTSC_DEBUG(m_text, "Notify the read waiting on write with address: 0x" << std::hex << address8);
                  m_outstanding_write_event.notify();
                }
                //Cleanup
                request_info *p_request_info = m_outstanding_writes_map[tag];
                delete_request_info(p_request_info);
                m_outstanding_writes_map.erase(tag);
              } 
            }

            if (!m_immediate_timing) {
              // Calculate delay (net => No Earlier Than time)
              sc_time receipt_net       = p_response_info->m_time_stamp + m_response_delay;
              sc_time last_response_net = m_last_response_time_stamp + (m_delay_from_receipt ? m_recovery_time : m_response_delay);
              sc_time latest_net        = (receipt_net > last_response_net) ? receipt_net : last_response_net;
              sc_time now               = sc_time_stamp();
              sc_time delay = (latest_net <= now) ? SC_ZERO_TIME : (latest_net - now);
              XTSC_DEBUG(m_text, "response_arbiter_thread() doing wait for " << delay);
              wait(delay);
            } else {
              u64 current_cycle = sc_time_stamp().value() / m_clock_period.value();
              u64 last_response_cycle = m_last_response_time_stamp.value() / m_clock_period.value();
              if (current_cycle == last_response_cycle) {
                wait(m_clock_period);
              }
            }
            m_lock = !p_response_info->m_response.get_last_transfer() && !m_interleave_responses;
            if (m_filter_responses) {
              handle_response_filters(next_token, p_response_info->m_response);
            }
            // Forward the response
            u32 tries = 0;
            while (true) {
              tries += 1;
              XTSC_INFO(m_text, p_response_info->m_response << " Port #" << next_token << " Try #" << tries);
              xtsc_log_memory_response_event(m_binary, INFO_LOG_LEVEL, false, 0, m_log_data_binary, p_response_info->m_response);
              if (m_respond_port->nb_respond(p_response_info->m_response)) {
                break;
              }
              wait(m_response_repeat);
            };
            m_last_response_time_stamp = sc_time_stamp();
            delete_response_info(p_response_info);
            m_token = next_token;
          }
        } while (next_token != m_token);
      } while (response_found);
    }

  }
  catch (const sc_unwind_exception& error) { throw; }
  catch (const exception& error) {
    ostringstream oss;
    oss << "std::exception caught in response_arbiter_thread of " << kind() << " '" << name() << "'." << endl;
    oss << "what(): " << error.what() << endl;
    xtsc_log_multiline(m_text, log4xtensa::FATAL_LOG_LEVEL, oss.str(), 2);
    throw;
  }

}




// When acting as PIF width converter (pwc)
void xtsc_component::xtsc_router::response_arbiter_pwc_thread(void) {
  //Only used when master_byte_width > slave_byte_width
  vector<xtsc::xtsc_response> buffered_xfers;
  //Only used when master_byte_width < slave_byte_width
  vector<xtsc::xtsc_response> buffered_first_xfer;
      u64 tag;
      u32 m_idx         = 1;
      u32 s_idx         = 1;
      u32 pre_wrap_cnt  = 0;
      u32 post_wrap_cnt = 0;
      bool last_xfer   = false;
      bool wrap_active = false;
      bool first_xfer  = true;
  try {
    while (true) {
      wait(m_response_arbiter_thread_event);
      XTSC_DEBUG(m_text, "response_arbiter_pwc_thread woke up.");
      bool response_found;

      do {
        u32 next_token = m_token;
        response_found = false;
        do {
          if (!m_lock) {
            next_token = (next_token + 1) % m_num_slaves;
          }
          if (m_response_fifos[next_token]->num_available()) {
            response_found = true;
            response_info *p_response_info = NULL;
            m_response_fifos[next_token]->nb_read(p_response_info);
            XTSC_DEBUG(m_text, "response_arbiter_pwc_thread got: " << p_response_info->m_response);

            req_rsp_info       *p_req_rsp_info   = NULL;
            u32                 slave_byte_width = m_slave_byte_widths[next_token];

            if (m_master_byte_width == slave_byte_width || (p_response_info->m_response.is_axi_protocol() && (m_master_byte_width < slave_byte_width))) {
              m_responses[0] = p_response_info;
              m_lock = (p_response_info->m_response.get_last_transfer() == false);
            }
            else
              m_lock = convert_response(p_response_info, slave_byte_width, p_req_rsp_info, last_xfer, wrap_active);

            map<xtsc::u64, split_request>::iterator itr;
            if (m_master_byte_width > slave_byte_width) {
              tag = p_response_info->m_response.get_tag();
              itr = m_issued_split_requests.find(tag);

              if (itr != m_issued_split_requests.end()) {
                pre_wrap_cnt = itr->second.pre_wrap_cnt;
                post_wrap_cnt = itr->second.post_wrap_cnt;

                if (pre_wrap_cnt + post_wrap_cnt == 0)
                  wrap_active = false;
                else if (m_idx == (pre_wrap_cnt + post_wrap_cnt)) {
                  last_xfer = true;
                  wrap_active = true;
                }
                else {
                  last_xfer = false;
                  wrap_active = true;
                }
              }
            }

            //Number of data transfers is determined by number of sub-reqeusts (after width conversion) as well as channel width!
            u32 num_reps  = (slave_byte_width == m_master_byte_width ||
                            (p_response_info->m_response.is_axi_protocol() && slave_byte_width > m_master_byte_width))
                            ? 1 : p_req_rsp_info->m_num_last_xfer_rsp_expected;
            u32 num_xfers = ceil((float)(p_response_info->m_response.get_num_transfers() * slave_byte_width) / m_master_byte_width) * num_reps;
            sc_time delay;

            for (u32 i=0; (i<8) && (m_responses[i] != NULL); ++i) {

              // Calculate delay (net => No Earlier Than time)
              sc_time receipt_net       = m_responses[i]->m_time_stamp + m_response_delay;
              sc_time last_response_net = m_last_response_time_stamp + (m_delay_from_receipt ? m_recovery_time : m_response_delay);
              sc_time latest_net        = (receipt_net > last_response_net) ? receipt_net : last_response_net;
              sc_time now               = sc_time_stamp();
              delay = (latest_net <= now) ? SC_ZERO_TIME : (latest_net - now);
              XTSC_DEBUG(m_text, "response_arbiter_pwc_thread() doing wait for " << delay);
              wait(delay);

              if (m_filter_responses) {
                handle_response_filters(next_token, p_response_info->m_response);
              }
              // Forward the response
              u32 tries = 0;
              while (true) {
                tries += 1;
                xtsc_address address = m_responses[i]->m_response.get_byte_address();

                if (m_master_byte_width > slave_byte_width &&
                    itr != m_issued_split_requests.end() &&
                    m_idx > pre_wrap_cnt &&
                    m_idx <= (pre_wrap_cnt + post_wrap_cnt)) {
                  buffered_xfers.push_back(m_responses[i]->m_response);
                  m_idx++;
                  break;
                }
                else if ((m_master_byte_width < slave_byte_width) &&
                    first_xfer &&
                    p_response_info->m_response.get_byte_size() > m_master_byte_width &&
                    (address % slave_byte_width) &&
                    ((address & -slave_byte_width) + (i * m_master_byte_width) < address)) {
                  buffered_first_xfer.push_back(m_responses[i]->m_response);
                  wrap_active = true;
                  s_idx++;
                  break;
                }
                else if (m_respond_port->nb_respond(m_responses[i]->m_response)) {
                  XTSC_INFO(m_text, m_responses[i]->m_response << " Port #" << next_token << " Try #" << tries);
                  xtsc_log_memory_response_event(m_binary, INFO_LOG_LEVEL, false, 0, m_log_data_binary, m_responses[i]->m_response);
                  first_xfer = (m_master_byte_width < slave_byte_width) ? false : true;
                  (m_master_byte_width < slave_byte_width)? s_idx++ : (m_master_byte_width >  slave_byte_width) ? m_idx++ : 0;
                  break;
                }
                wait(m_response_repeat);
              }
              m_last_response_time_stamp = sc_time_stamp();
              delete_response_info(m_responses[i]);
            }

            if (p_req_rsp_info) {
              wait(delay);
              //Once all the data trasfers are recieved (i.e., m_idx == num_xfers + 1) we should send the buffered responses!
              while (!buffered_xfers.empty() && m_idx == (num_xfers + 1)) {
                xtsc::xtsc_response buffered_rsp = buffered_xfers.front();
                buffered_xfers.erase(buffered_xfers.begin());

                u32 tries = 0;
                while (true) {
                  tries++;
                  if (m_respond_port->nb_respond(buffered_rsp)){
                    XTSC_INFO(m_text, buffered_rsp << " Port #" << next_token << " Try #" << tries << "  - (reorder-buffer)");
                    xtsc_log_memory_response_event(m_binary, INFO_LOG_LEVEL, false, 0, m_log_data_binary, buffered_rsp);
                    wait(delay);
                    break;
                  }
                }
              }

              if (!buffered_first_xfer.empty())
                buffered_first_xfer.back().set_last_transfer(true);

              while (!buffered_first_xfer.empty() && s_idx > buffered_first_xfer.front().get_num_transfers()) {
                xtsc::xtsc_response buffered_rsp = buffered_first_xfer.front();
                buffered_first_xfer.erase(buffered_first_xfer.begin());

                u32 tries = 0;
                while (true) {
                  tries++;
                  if (m_respond_port->nb_respond(buffered_rsp)){
                    XTSC_INFO(m_text, buffered_rsp << " Port #" << next_token << " Try #" << tries << "  - (reorder-buffer)");
                    xtsc_log_memory_response_event(m_binary, INFO_LOG_LEVEL, false, 0, m_log_data_binary, buffered_rsp);
                    wait(delay);
                    break;
                  }
                }
              }

              if (((m_master_byte_width > slave_byte_width) && m_idx == (num_xfers + 1)) || (buffered_xfers.empty() && !m_lock)) {
                m_req_rsp_table.erase(p_response_info->m_response.get_tag());
                delete_response_info(p_response_info);
                delete_req_rsp_info(p_req_rsp_info);
                m_issued_split_requests.erase(tag);
                wrap_active = false;
                first_xfer = true;
                m_idx = 1;
                s_idx = 1;
              }
            }
            m_token = next_token;
          }
        } while (next_token != m_token);
      } while (response_found);
    }
  }
  catch (const sc_unwind_exception& error) { throw; }
  catch (const exception& error) {
    ostringstream oss;
    oss << "std::exception caught in response_arbiter_pwc_thread of " << kind() << " '" << name() << "'." << endl;
    oss << "what(): " << error.what() << endl;
    xtsc_log_multiline(m_text, log4xtensa::FATAL_LOG_LEVEL, oss.str(), 2);
    throw;
  }
}



bool xtsc_component::xtsc_router::convert_response(response_info*&      p_response_info,
                                                   u32                  slave_byte_width,
                                                   req_rsp_info*&       p_req_rsp_info,
                                                   bool                 last_xfer,
                                                   bool                 wrap_active)
{
  u8 id   = p_response_info->m_response.get_id();
  u64 tag = p_response_info->m_response.get_tag();
  if (!m_interleave_responses && (m_active_block_read_tag != 0) && (m_active_block_read_tag != tag)) {
    ostringstream oss;
    oss << "While BLOCK_READ responses (tag=" << m_req_rsp_table.find(m_active_block_read_tag)->second->m_p_first_request_info->m_request.get_tag()
        << ") are in progress, received unexpected response: " << p_response_info->m_response;
    throw xtsc_exception(oss.str());
  }

  std::map<xtsc::u64, req_rsp_info*>::iterator itr = m_req_rsp_table.find(p_response_info->m_response.get_tag());
  if (itr == m_req_rsp_table.end()) {
    ostringstream oss;
    oss << "Expected request tag = " << p_response_info->m_response.get_tag() << " was not found in m_pending_request_tag! ";
    throw xtsc_exception(oss.str());
  }
  else
    p_req_rsp_info = itr->second;

  bool last_transfer = p_response_info->m_response.get_last_transfer();
  bool fini = false;
  if (last_transfer) {
    p_req_rsp_info->m_num_last_xfer_rsp_received += 1;
    fini = (p_req_rsp_info->m_num_last_xfer_rsp_received == p_req_rsp_info->m_num_last_xfer_rsp_expected);
  }

  response_info *p_rsp_info = p_req_rsp_info->m_p_nascent_response ?
                              p_req_rsp_info->m_p_nascent_response :
                              new_response_info(p_req_rsp_info->m_p_first_request_info->m_request);

  if (!fini) {
    p_req_rsp_info->m_p_nascent_response = p_rsp_info;
  }

  /*
   * Handle single-response error responses
   *   RSP_ADDRESS_ERROR           single response
   *   RSP_ADDRESS_DATA_ERROR:     single response
   *   RSP_DATA_ERROR              normal number of responses
   */
  xtsc_response::status_t status = p_response_info->m_response.get_status();
  if (p_req_rsp_info->m_single_rsp_error_received ||
      ((status != xtsc_response::RSP_OK) && (status != xtsc_response::RSP_DATA_ERROR)))
  {
    if (p_req_rsp_info->m_single_rsp_error_received ||
        ((status == xtsc_response::RSP_ADDRESS_ERROR) || (status == xtsc_response::RSP_ADDRESS_DATA_ERROR)))
    {
      if (p_req_rsp_info->m_responses_sent) {
        ostringstream oss;
        oss << "Received address error response after some responses have already been sent upstream: " << p_response_info->m_response;
        throw xtsc_exception(oss.str());
      }
      if (!p_req_rsp_info->m_single_rsp_error_received) {
        p_req_rsp_info->m_single_rsp_error_received = true;
        p_rsp_info->m_response.set_status(status);
        p_rsp_info->m_response.set_last_transfer(true);
      }
      if (fini) {
        m_responses[0] = p_rsp_info;
        m_responses[0]->m_time_stamp = p_response_info->m_time_stamp;
      }
    }
    else {
      ostringstream oss;
      oss << "Received response with unsupported status: " << p_response_info->m_response;
      throw xtsc_exception(oss.str());
    }
  }
  else {
    if ((status == xtsc_response::RSP_DATA_ERROR) && (p_rsp_info->m_response.get_status() == xtsc_response::RSP_OK)) {
      p_rsp_info->m_response.set_status(xtsc_response::RSP_DATA_ERROR);
    }
    xtsc_request::type_t type = p_req_rsp_info->m_p_first_request_info->m_request.get_type();
    if ((type == xtsc_request::WRITE) || (type == xtsc_request::BLOCK_WRITE) || (type == xtsc_request::RCW) || (type == xtsc_request::BURST_WRITE)) {
      if (type == xtsc_request::RCW) {
        p_rsp_info->m_response.set_buffer(p_response_info->m_response.get_buffer());
      }
      if (fini) {
        m_responses[0] = p_rsp_info;
        m_responses[0]->m_time_stamp = p_response_info->m_time_stamp;
        m_responses[0]->m_response.set_exclusive_ok(p_response_info->m_response.get_exclusive_ok());
      }
    }
    else if ((type == xtsc_request::READ) || (type == xtsc_request::BLOCK_READ) || (type == xtsc_request::BURST_READ)) {
      const u8 *p_src = p_response_info->m_response.get_buffer();
      u32       size  = p_response_info->m_response.get_byte_size();
      if (m_master_byte_width > slave_byte_width) {
        // Master is wider than slave
        u8 *p_dst = p_rsp_info->m_response.get_buffer();
        u32 offset = (p_req_rsp_info->m_num_rsp_received * slave_byte_width) % m_master_byte_width;
        memcpy(p_dst+offset, p_src, size);
        if (fini || ((offset + size) == m_master_byte_width)) {
          m_responses[0] = p_rsp_info;

          //If the memory responses need to be reorderd (i.e., split requests), we need to change the last_transfer flag as well!
          u64 tag = p_response_info->m_response.get_tag();
          (m_issued_split_requests.find(tag) == m_issued_split_requests.end() || !wrap_active) ? m_responses[0]->m_response.set_last_transfer(fini)
                                                                                                 : m_responses[0]->m_response.set_last_transfer(last_xfer);

          m_responses[0]->m_time_stamp = p_response_info->m_time_stamp; // Base timing off this latest response which completes the bus
        }
      }
      else {
        // Slave is wider than master
        p_rsp_info->m_response.set_buffer(p_src);
        m_responses[0] = p_rsp_info;
        if (type == xtsc_request::BLOCK_READ || type == xtsc_request::BURST_READ) {
          m_responses[0]->m_response.set_last_transfer(false);
          u32 reps = min(slave_byte_width, size) / m_master_byte_width;
          for (u32 i=1; i < reps; ++i) {
            m_responses[i] = new_response_info(p_rsp_info->m_response);
            m_responses[i]->m_response.set_buffer(p_src + m_master_byte_width*i);
            m_responses[i]->m_response.set_last_transfer(false);
          }
          if (fini && !wrap_active) {
            m_responses[reps-1]->m_response.set_last_transfer(true);
          }
        }
      }
      if (type == xtsc_request::BLOCK_READ || type == xtsc_request::BURST_READ) {
        m_active_block_read_tag = fini ? 0 : tag;
      }
    }
    else {
      ostringstream oss;
      oss << "Program Bug: " << xtsc_request::get_type_name(type) << " is not supported at line " << __LINE__ << " of " << __FILE__;
      throw xtsc_exception(oss.str());
    }
  }

  p_req_rsp_info->m_num_rsp_received += 1;
  if (m_responses[0] != NULL) {
    p_req_rsp_info->m_responses_sent     = true;
    p_req_rsp_info->m_p_nascent_response = NULL;
  }
  bool lock = !fini;
  return lock;
}



u32 xtsc_component::xtsc_router::get_port_and_apply_address_translation(xtsc_address& address8) {
  if (m_address_routing) {
    u32 port_num = 0;
    for (u32 i=0; i<m_num_bit_fields; ++i) {
      u32 bit_field = address8;
      bit_field >>= m_address_routing_info[i]->m_pre_shift;
      bit_field  &= m_address_routing_info[i]->m_mask;
      bit_field <<= m_address_routing_info[i]->m_post_shift;
      port_num |= bit_field;
    }
    return port_num;
  }
  vector<xtsc_address_range_entry>::iterator i_table = m_routing_table.begin();
  for (i_table=m_routing_table.begin(); i_table != m_routing_table.end(); ++i_table) {
    if ((address8 >= i_table->m_start_address8) && (address8 <= i_table->m_end_address8)) {
      address8 += i_table->m_delta;
      return i_table->m_port_num;
    }
  }
  if (m_lua_function) {
    ostringstream exp;
    exp << m_lua_port_function << "(0x" << hex << address8 << ")";
    string result = m_file->evaluate_lua_expression(exp.str());
    XTSC_VERBOSE(m_text, exp.str() << " => " << result);
    u32 port_num = 0;
    try { port_num = xtsc_strtou32(result); if (port_num >= m_num_slaves) throw port_num; } catch (...) {
      ostringstream oss;
      oss << "Call to Lua function " << exp.str() << " in \"routing_table\" file '" << m_file_name << "' returned '" << result
          << "' which is not u32 or is out-of-range.";
      throw xtsc_exception(oss.str());
    }
    if (m_lua_addr_function != "") {
      ostringstream exp;
      exp << m_lua_addr_function << "(0x" << hex << address8 << ")";
      string result = m_file->evaluate_lua_expression(exp.str());
      try { address8 = xtsc_strtou64(result); } catch (...) {
        ostringstream oss;
        oss << "Call to Lua function " << exp.str() << " in \"routing_table\" file '" << m_file_name << "' returned '" << result
            << "' which is not u64.";
        throw xtsc_exception(oss.str());
      }
      XTSC_VERBOSE(m_text, exp.str() << " => " << result << " = 0x" << hex << address8);
    }
    return port_num;
  }
  // Not in routing table
  address8 += m_default_delta;
  return m_default_port_num;
}



u32 xtsc_component::xtsc_router::get_port_by_type(u32 type) {
  map<u32,u32>::const_iterator i = m_type_port_map.find(type);
  if (i == m_type_port_map.end()) {
    ostringstream oss;
    oss << "ERROR: " << kind() << "::get_port_by_type() of '" << name() << "' called for unrecognized type=" << type;
    throw xtsc_exception(oss.str());
  }
  return i->second;
}



xtsc_component::xtsc_router::request_info *xtsc_component::xtsc_router::new_request_info(const xtsc_request& request) {
  if (m_request_pool.empty()) {
    request_info *p_request_info = new request_info(request);
    XTSC_DEBUG(m_text, "Creating a new request_info " << p_request_info << " for " << request);
    return p_request_info;
  }
  else {
    request_info *p_request_info = m_request_pool.back();
    XTSC_DEBUG(m_text, "Reusing request_info " << p_request_info << " for " << request);
    m_request_pool.pop_back();
    p_request_info->m_request = request;
    p_request_info->m_time_stamp = sc_time_stamp();
    return p_request_info;
  }
}



xtsc_component::xtsc_router::request_info *xtsc_component::xtsc_router::new_request_info(const request_info& info) {
  if (m_request_pool.empty()) {
    request_info *p_request_info = new request_info(info);
    XTSC_DEBUG(m_text, "Creating a new request_info " << p_request_info << " for " << info.m_request);
    return p_request_info;
  }
  else {
    request_info *p_request_info = m_request_pool.back();
    XTSC_DEBUG(m_text, "Reusing request_info " << p_request_info << " for " << info.m_request);
    m_request_pool.pop_back();
    *p_request_info = info;
    return p_request_info;
  }
}



void xtsc_component::xtsc_router::delete_request_info(request_info*& p_request_info) {
  XTSC_DEBUG(m_text, "Recycling request_info " << p_request_info);
  m_request_pool.push_back(p_request_info);
  p_request_info = 0;
}



xtsc_component::xtsc_router::response_info *xtsc_component::xtsc_router::new_response_info(const xtsc_response& response) {
  if (m_response_pool.empty()) {
    response_info *p_response_info = new response_info(response);
    XTSC_DEBUG(m_text, "Creating a new response_info " << p_response_info << " for " << response);
    return p_response_info;
  }
  else {
    response_info *p_response_info = m_response_pool.back();
    XTSC_DEBUG(m_text, "Reusing response_info " << p_response_info << " for " << response);
    m_response_pool.pop_back();
    p_response_info->m_response = response;
    p_response_info->m_response.set_exclusive_ok(response.get_exclusive_ok());
    p_response_info->m_time_stamp = sc_time_stamp();
    return p_response_info;
  }
}



xtsc_component::xtsc_router::response_info *xtsc_component::xtsc_router::new_response_info(const xtsc_request& request) {
  if (m_response_pool.empty()) {
    response_info *p_response_info = new response_info(request);
    XTSC_DEBUG(m_text, "Creating a new response_info " << p_response_info << " for " << request);
    return p_response_info;
  }
  else {
    response_info *p_response_info = m_response_pool.back();
    XTSC_DEBUG(m_text, "Reusing response_info " << p_response_info << " for " << request);
    m_response_pool.pop_back();
    p_response_info->m_response = request;
    p_response_info->m_response.set_exclusive_ok(request.get_exclusive());
    p_response_info->m_time_stamp = sc_time_stamp();
    return p_response_info;
  }
}



void xtsc_component::xtsc_router::delete_response_info(response_info*& p_response_info) {
  XTSC_DEBUG(m_text, "Recycling response_info " << p_response_info);
  m_response_pool.push_back(p_response_info);
  p_response_info = 0;
}



u32 xtsc_component::xtsc_router::get_u32(u32 index) {
  u32 value = 0;
  try {
    value = xtsc_strtou32(m_words[index]);
  }
  catch (const xtsc_exception&) {
    ostringstream oss;
    oss << "Cannot convert argument #" << index+1 << " '" << m_words[index] << "' to number:" << endl;
    oss << m_line;
    oss << m_file->info_for_exception();
    throw xtsc_exception(oss.str());
  }
  return value;
}



u64 xtsc_component::xtsc_router::get_u64(u32 index) {
  u64 value = 0;
  try {
    value = xtsc_strtou64(m_words[index]);
  }
  catch (const xtsc_exception&) {
    ostringstream oss;
    oss << "Cannot convert argument #" << index+1 << " '" << m_words[index] << "' to number:" << endl;
    oss << m_line;
    oss << m_file->info_for_exception();
    throw xtsc_exception(oss.str());
  }
  return value;
}



xtsc_component::xtsc_router::req_rsp_info *xtsc_component::xtsc_router::new_req_rsp_info(request_info  *p_first_request_info) {
  req_rsp_info *p_req_rsp_info;
  if (m_req_rsp_info_pool.empty()) {
    p_req_rsp_info = new req_rsp_info();
    XTSC_DEBUG(m_text, "Creating a new req_rsp_info " << p_req_rsp_info);
  }
  else {
    p_req_rsp_info = m_req_rsp_info_pool.back();
    XTSC_DEBUG(m_text, "Reusing req_rsp_info " << p_req_rsp_info);
    m_req_rsp_info_pool.pop_back();
  }
  p_req_rsp_info->m_p_first_request_info = p_first_request_info;
  return p_req_rsp_info;
}



void xtsc_component::xtsc_router::delete_req_rsp_info(req_rsp_info*& p_req_rsp_info) {
  XTSC_DEBUG(m_text, "Recycling req_rsp_info " << p_req_rsp_info);
  delete_request_info(p_req_rsp_info->m_p_first_request_info);
  memset(p_req_rsp_info, 0, sizeof(req_rsp_info));
  m_req_rsp_info_pool.push_back(p_req_rsp_info);
  p_req_rsp_info = 0;
}



void xtsc_component::xtsc_router::update_transaction_id_counts(u32 port_num, const xtsc_response& response) {
  if (response.get_last_transfer()) {
    u64 transaction_id = (((u64) response.get_route_id()) << 8) + response.get_id();
    map<u64, u32>& tid_cnt_map = m_transaction_id_counts[port_num];
    map<u64, u32>::const_iterator i = tid_cnt_map.find(transaction_id);
    if (i != tid_cnt_map.end()) {
      u32 count = i->second;
      if (count) {
        tid_cnt_map[transaction_id] = count - 1;
        map<u64, u64>& tid_ts_map = m_transaction_id_timestamps[port_num];
        tid_ts_map[transaction_id] = sc_time_stamp().value();
      }
      else {
        ostringstream oss;
        oss << response << ": " << kind() << " '" << name() << "': transaction ID=0x" << hex << transaction_id << " has outstanding count of 0.";
        throw xtsc_exception(oss.str());
      }
    }
    else {
      ostringstream oss;
      oss << response << ": " << kind() << " '" << name() << "': transaction ID=0x" << hex << transaction_id << " not found.";
      throw xtsc_exception(oss.str());
    }
  }
}



u32 xtsc_component::xtsc_router::dump_transaction_id_counts(ostream& os, bool verbose) {
  u32 total = 0;

  if (m_flexible_request_id) {
    // Save state of stream
    char c = os.fill('0');
    ios::fmtflags old_flags = os.flags();

    u64 max_tid = 0;
    for (u32 i=0; i<m_num_slaves; ++i) {
      map<u64, u32>& tid_cnt_map = m_transaction_id_counts[i];
      for (map<u64, u32>::const_iterator i = tid_cnt_map.begin(); i != tid_cnt_map.end(); ++i) {
        max_tid = max(max_tid, i->first);
      }
    }
    ostringstream oss;
    oss << hex << max_tid;
    u32 width = oss.str().length();
    for (u32 i=0; i<m_num_slaves; ++i) {
      map<u64, u32>& tid_cnt_map = m_transaction_id_counts[i];
      if (!tid_cnt_map.empty()) {
        for (map<u64, u32>::const_iterator j = tid_cnt_map.begin(); j != tid_cnt_map.end(); ++j) {
          if (j->second || verbose) {
            os << i << " 0x" << hex << setw(width) << j->first << " " << dec << j->second << endl;
            total += j->second;
          }
        }
      }
    }

    // Restore state of stream
    os.fill(c);
    os.flags(old_flags);
  }

  return total;
}



void xtsc_component::xtsc_router::xtsc_request_if_impl::nb_peek(xtsc_address address8, u32 size8, u8 *buffer) {
  xtsc_address original_addr = address8;
  u32 port_num = (m_router.m_use_route_by_type ? m_router.get_port_by_type(PEEK) : m_router.m_use_route_by_priority ? 0 :
                                                 m_router.get_port_and_apply_address_translation(address8));
  if (port_num == ADDRESS_ERROR) {
    ostringstream oss;
    oss << "xtsc_router '" << m_router.name() << "': nb_peek() called with invalid address: 0x" << hex << address8;
    throw xtsc_exception(oss.str());
  }
  if (port_num == DISCARD_REQUEST) {
    memset(buffer, 0xba, size8);
    XTSC_INFO(m_router.m_text, "Discarding nb_peek() called with invalid address: 0x" << hex << address8);
    return;
  }
  if (port_num >= m_router.m_num_slaves) {
    ostringstream oss;
    oss << "xtsc_router '" << m_router.name() << "' in nb_peek: Invalid port (0x" << hex << port_num << ") returned for address 0x"
        << hex << address8;
    throw xtsc_exception(oss.str());
  }
  (*m_router.m_request_ports[port_num])->nb_peek(address8, size8, buffer);
  if (m_router.m_log_peek_poke && xtsc_is_text_logging_enabled() && m_router.m_text.isEnabledFor(VERBOSE_LOG_LEVEL)) {
    u8 *buf = buffer;
    u32 buf_offset = 0;
    ostringstream oss;
    oss << hex << setfill('0');
    for (u32 i = 0; i<size8; ++i) {
      oss << setw(2) << (u32) buf[buf_offset] << " ";
      buf_offset += 1;
    }
    XTSC_VERBOSE(m_router.m_text, "peek: " << " [0x" << hex << original_addr << "/" << dec << size8 << "] = " << oss.str() <<
                                  " Port #" << port_num);
  }
  if (m_router.m_filter_peeks) {
    for (set<u32>::const_iterator i = m_router.m_peek_watchfilters.begin(); i != m_router.m_peek_watchfilters.end(); ++i) {
      u32 watchfilter = *i;
      map<u32, watchfilter_info*>::const_iterator j = m_router.m_watchfilters.find(watchfilter);
      if (j == m_router.m_watchfilters.end()) {
        ostringstream oss;
        oss << "Error: watchfilter #" << watchfilter << " missing from m_watchfilters at line " << __LINE__ << " of " << __FILE__;
        throw xtsc_exception(oss.str());
      }
      watchfilter_info *p_watchfilter_info = j->second;
      if (xtsc_filter_apply_xtsc_peek(p_watchfilter_info->m_filter_name, port_num, address8, size8, buffer)) {
        p_watchfilter_info->m_event.notify(SC_ZERO_TIME);
        XTSC_INFO(m_router.m_text, "nb_peek(0x" << hex << address8 << ", " << dec << size8 << ") Watchfilter #" <<
                                   p_watchfilter_info->m_watchfilter);
      }
    }
  }
}



void xtsc_component::xtsc_router::xtsc_request_if_impl::nb_poke(xtsc_address address8, u32 size8, const u8 *buffer) {
  xtsc_address original_addr = address8;
  u32 port_num = (m_router.m_use_route_by_type ? m_router.get_port_by_type(POKE) : m_router.m_use_route_by_priority ? 0 :
                                                 m_router.get_port_and_apply_address_translation(address8));
  if (m_router.m_filter_pokes) {
    for (set<u32>::const_iterator i = m_router.m_poke_watchfilters.begin(); i != m_router.m_poke_watchfilters.end(); ++i) {
      u32 watchfilter = *i;
      map<u32, watchfilter_info*>::const_iterator j = m_router.m_watchfilters.find(watchfilter);
      if (j == m_router.m_watchfilters.end()) {
        ostringstream oss;
        oss << "Error: watchfilter #" << watchfilter << " missing from m_watchfilters at line " << __LINE__ << " of " << __FILE__;
        throw xtsc_exception(oss.str());
      }
      watchfilter_info *p_watchfilter_info = j->second;
      if (xtsc_filter_apply_xtsc_poke(p_watchfilter_info->m_filter_name, port_num, address8, size8, buffer)) {
        p_watchfilter_info->m_event.notify(SC_ZERO_TIME);
        XTSC_INFO(m_router.m_text, "nb_poke(0x" << hex << address8 << ", " << dec << size8 << ") Watchfilter #" <<
                                   p_watchfilter_info->m_watchfilter);
      }
    }
  }
  if (port_num == ADDRESS_ERROR) {
    ostringstream oss;
    oss << "xtsc_router '" << m_router.name() << "': nb_poke() called with invalid address: 0x" << hex << address8;
    throw xtsc_exception(oss.str());
  }
  if (port_num == DISCARD_REQUEST) {
    XTSC_INFO(m_router.m_text, "Discarding nb_poke() called with invalid address: 0x" << hex << address8);
    return;
  }
  if (port_num >= m_router.m_num_slaves) {
    ostringstream oss;
    oss << "xtsc_router '" << m_router.name() << "' in nb_poke: Invalid port (0x" << hex << port_num << ") returned for address 0x"
        << hex << address8;
    throw xtsc_exception(oss.str());
  }
  if (m_router.m_log_peek_poke && xtsc_is_text_logging_enabled() && m_router.m_text.isEnabledFor(VERBOSE_LOG_LEVEL)) {
    const u8 *buf = buffer;
    u32 buf_offset = 0;
    ostringstream oss;
    oss << hex << setfill('0');
    for (u32 i = 0; i<size8; ++i) {
      oss << setw(2) << (u32) buf[buf_offset] << " ";
      buf_offset += 1;
    }
    XTSC_VERBOSE(m_router.m_text, "poke: " << " [0x" << hex << original_addr << "/" << dec << size8 << "] = " << oss.str() <<
                                  " Port #" << port_num);
  }
  (*m_router.m_request_ports[port_num])->nb_poke(address8, size8, buffer);
}



bool xtsc_component::xtsc_router::xtsc_request_if_impl::nb_peek_coherent(xtsc_address   virtual_address8,
                                                                         xtsc_address   physical_address8,
                                                                         u32            size8,
                                                                         u8            *buffer)
{
  xtsc_address original_addr = physical_address8;
  xtsc_address paddr = physical_address8;
  u32 port_num = (m_router.m_use_route_by_type ? m_router.get_port_by_type(PEEK) : m_router.m_use_route_by_priority ? 0 :
                                                 m_router.get_port_and_apply_address_translation(paddr));
  if (port_num == ADDRESS_ERROR) {
    ostringstream oss;
    oss << "xtsc_router '" << m_router.name() << "': nb_peek_coherent() called with invalid address: 0x" << hex << paddr;
    throw xtsc_exception(oss.str());
  }
  if (port_num == DISCARD_REQUEST) {
    memset(buffer, 0xba, size8);
    XTSC_INFO(m_router.m_text, "Discarding nb_peek_coherent() called with invalid address: 0x" << hex << paddr);
    return false;
  }
  if (port_num >= m_router.m_num_slaves) {
    ostringstream oss;
    oss << "xtsc_router '" << m_router.name() << "' in nb_peek_coherent: Invalid port (0x" << hex << port_num
        << ") returned for address 0x" << hex << paddr;
    throw xtsc_exception(oss.str());
  }
  xtsc_address vaddr = virtual_address8 + (paddr - physical_address8);
  bool return_value = (*m_router.m_request_ports[port_num])->nb_peek_coherent(vaddr, paddr, size8, buffer);
  if (m_router.m_log_peek_poke && xtsc_is_text_logging_enabled() && m_router.m_text.isEnabledFor(VERBOSE_LOG_LEVEL)) {
    u8 *buf = buffer;
    u32 buf_offset = 0;
    ostringstream oss;
    oss << hex << setfill('0');
    for (u32 i = 0; i<size8; ++i) {
      oss << setw(2) << (u32) buf[buf_offset] << " ";
      buf_offset += 1;
    }
    XTSC_VERBOSE(m_router.m_text, "cpeek:" << " [0x" << hex << original_addr << "/" << dec << size8 << "] = " << oss.str() <<
                                  " Port #" << port_num);
  }
  return return_value;
}



bool xtsc_component::xtsc_router::xtsc_request_if_impl::nb_poke_coherent(xtsc_address   virtual_address8,
                                                                         xtsc_address   physical_address8,
                                                                         u32            size8,
                                                                         const u8      *buffer)
{
  xtsc_address original_addr = physical_address8;
  xtsc_address paddr = physical_address8;
  u32 port_num = (m_router.m_use_route_by_type ? m_router.get_port_by_type(POKE) : m_router.m_use_route_by_priority ? 0 :
                                                 m_router.get_port_and_apply_address_translation(paddr));
  if (port_num == ADDRESS_ERROR) {
    ostringstream oss;
    oss << "xtsc_router '" << m_router.name() << "': nb_poke_coherent() called with invalid address: 0x" << hex << paddr;
    throw xtsc_exception(oss.str());
  }
  if (port_num == DISCARD_REQUEST) {
    XTSC_INFO(m_router.m_text, "Discarding nb_poke_coherent() called with invalid address: 0x" << hex << paddr);
    return false;
  }
  if (port_num >= m_router.m_num_slaves) {
    ostringstream oss;
    oss << "xtsc_router '" << m_router.name() << "' in nb_poke_coherent: Invalid port (0x" << hex << port_num
        << ") returned for address 0x" << hex << paddr;
    throw xtsc_exception(oss.str());
  }
  xtsc_address vaddr = virtual_address8 + (paddr - physical_address8);
  if (m_router.m_log_peek_poke && xtsc_is_text_logging_enabled() && m_router.m_text.isEnabledFor(VERBOSE_LOG_LEVEL)) {
    const u8 *buf = buffer;
    u32 buf_offset = 0;
    ostringstream oss;
    oss << hex << setfill('0');
    for (u32 i = 0; i<size8; ++i) {
      oss << setw(2) << (u32) buf[buf_offset] << " ";
      buf_offset += 1;
    }
    XTSC_VERBOSE(m_router.m_text, "cpoke:" << " [0x" << hex << original_addr << "/" << dec << size8 << "] = " << oss.str() <<
                                  " Port #" << port_num);
  }
  return (*m_router.m_request_ports[port_num])->nb_poke_coherent(vaddr, paddr, size8, buffer);
}



bool xtsc_component::xtsc_router::xtsc_request_if_impl::nb_fast_access(xtsc_fast_access_request &request) {
  xtsc_address address8      = request.get_translated_request_address();
  xtsc_address orig_address8 = address8;
  u32 port_num = (m_router.m_use_route_by_type ? m_router.get_port_by_type(FAST_ACCESS) : m_router.m_use_route_by_priority ? 0 :
                                                 m_router.get_port_and_apply_address_translation(address8));
  request.translate_request_address(address8);
  
  if ((port_num == ADDRESS_ERROR) || (port_num == DISCARD_REQUEST) || (port_num >= m_router.m_num_slaves)) {
    request.deny_access();
    for (unsigned i = 0; i < m_router.m_num_slaves; i++) {
      xtsc_address block_start = m_router.m_routing_table[i].m_start_address8;
      xtsc_address block_end = m_router.m_routing_table[i].m_end_address8;
      request.remove_address_range(orig_address8, block_start, block_end);
    }
    return true;
  }

  if (!(*m_router.m_request_ports[port_num])->nb_fast_access(request)) { return false; }

  if (m_router.m_address_routing) {
    xtsc_address start_address8 = orig_address8  & m_router.m_address_routing_turbo_mask;
    xtsc_address end_address8   = start_address8 + m_router.m_address_routing_turbo_size - 1;
    xtsc_fast_access_block min_block(orig_address8, start_address8, end_address8);
    if (!request.restrict_to_block(min_block)) { return false; }   // TODO: Why check call to restrict_to_block and return false?
  }
  else {
    // Remove anything mapped before this address hits. When the address hits, remove anything outside of its range.
    for (unsigned i = 0; i < m_router.m_routing_table.size(); ++i) {
      xtsc_address end_address8   = m_router.m_routing_table[i].m_end_address8;
      xtsc_address start_address8 = m_router.m_routing_table[i].m_start_address8;
      if (start_address8 <= orig_address8 && orig_address8 <= end_address8) {
        xtsc_fast_access_block min_block(orig_address8, start_address8, end_address8);
        if (!request.restrict_to_block(min_block)) { return false; }
        break;
      }
      if (!request.remove_address_range(orig_address8, start_address8, end_address8)) { return false; }
    }
  }

  if (xtsc_is_text_logging_enabled() && m_router.m_text.isEnabledFor(INFO_LOG_LEVEL)) {
    u32 n = xtsc_address_nibbles();
    xtsc_fast_access_block block = request.get_local_block(address8);
    XTSC_INFO(m_router.m_text, hex << setfill('0') << "nb_fast_access: addr=0x" << hex << setfill('0') << setw(n) <<
                               request.get_request_address() << " trans=0x" << setw(n) << address8 << " [0x" << setw(n) <<
                               block.get_block_beg_address() << "-0x" << setw(n) << block.get_block_end_address() << "] ");
  }

  return true;
}



void xtsc_component::xtsc_router::xtsc_request_if_impl::nb_request(const xtsc_request& request) {
  XTSC_VERBOSE(m_router.m_text, request);
  xtsc_log_memory_request_event(m_router.m_binary, VERBOSE_LOG_LEVEL, true, 0, m_router.m_log_data_binary, request);
  if (m_router.m_read_only) {
    xtsc_request::type_t type = request.get_type();
    if ((type == xtsc_request::WRITE)       ||
        (type == xtsc_request::BLOCK_WRITE) ||
        (type == xtsc_request::BURST_WRITE) ||
        (type == xtsc_request::RCW))
    {
      ostringstream oss;
      oss << "read_only xtsc_router '" << m_router.name() << "' received request: " << request; 
      throw xtsc_exception(oss.str());
    }
  }
  if (m_router.m_write_only) {
    xtsc_request::type_t type = request.get_type();
    if ((type == xtsc_request::READ)       ||
        (type == xtsc_request::BLOCK_READ) ||
        (type == xtsc_request::BURST_READ) ||
        (type == xtsc_request::RCW))
    {
      ostringstream oss;
      oss << "write_only xtsc_router '" << m_router.name() << "' received request: " << request; 
      throw xtsc_exception(oss.str());
    }
  }

  //lambda to check request fifo size
  auto is_request_fifo_full = [&]() { 
      return ((u32)(m_router.m_request_fifo.num_free()       + 
                    m_router.m_waiting_reads_fifo.num_free() + 
                    m_router.m_ready_reads_fifo.num_free()) 
              > 2*m_router.m_request_fifo_depth ? false : true);
  };

  XTSC_TRACE(m_router.m_text, "m_router.m_request_fifo.num_free(): " << m_router.m_request_fifo.num_free() << 
                              ", m_router.m_waiting_reads_fifo.num_free(): " << m_router.m_waiting_reads_fifo.num_free()  << 
                              ", m_router.m_ready_reads_fifo.num_free(): " << m_router.m_ready_reads_fifo.num_free()  << 
                              ", is_request_fifo_full: " << is_request_fifo_full());
  // Check if we've got room for this request
  if (!m_router.m_immediate_timing && is_request_fifo_full() ) {
    xtsc_response response(request, xtsc_response::RSP_NACC);
    XTSC_VERBOSE(m_router.m_text, response << " (Request fifo full)");
    xtsc_log_memory_response_event(m_router.m_binary, VERBOSE_LOG_LEVEL, false, 0, false, response);
    m_router.m_respond_port->nb_respond(response);
    return;
  }
  // Optionally check for PIF 4 Flexible Request ID / AXI4 read ordering 
  if (m_router.m_flexible_request_id) {
    u64          transaction_id = (((u64) request.get_route_id()) << 8) + request.get_id();
    xtsc_address address8       = request.get_byte_address();
    u32          port_num       = m_router.get_port_and_apply_address_translation(address8);
    bool         match_found    = false;
    for (u32 i=0; i<m_router.m_num_slaves; ++i) {
      if (i != port_num) {
        map<u64, u32>& tid_cnt_map = m_router.m_transaction_id_counts[i];
        map<u64, u32>::const_iterator j = tid_cnt_map.find(transaction_id);
        if (j != tid_cnt_map.end()) {
          if (j->second != 0) {
            match_found = true;
            break;
          }
          if (j->second == 0) {
            map<u64, u64>&                tid_ts_map    = m_router.m_transaction_id_timestamps[i];
            map<u64, u64>::const_iterator ts            = tid_ts_map.find(transaction_id);
            u64                           update_cycle  = (ts == tid_ts_map.end()) ? (u64)-1 : (ts->second / m_router.m_clock_period.value());
            u64                           current_cycle = sc_time_stamp().value() / m_router.m_clock_period.value();
            if (update_cycle == current_cycle) {
              XTSC_VERBOSE(m_router.m_text, request << " (flexible_request_id counter is cleared in the current cycle)");
              match_found = true;
              break;
            }
          }
        }
      }
    }
    if (match_found) {
      // Reject request
      xtsc_response response(request, xtsc_response::RSP_NACC);
      XTSC_VERBOSE(m_router.m_text, response << " (flexible_request_id)");
      xtsc_log_memory_response_event(m_router.m_binary, VERBOSE_LOG_LEVEL, false, 0, false, response);
      m_router.m_respond_port->nb_respond(response);
      return;
    }
    else if (request.get_transfer_number() == 1) {
      // Increment count because this is a first transfer
      if ((port_num != m_router.DISCARD_REQUEST) && (port_num != m_router.ADDRESS_ERROR) && 
          (port_num < m_router.m_num_slaves)) {
        map<u64, u32>& tid_cnt_map = m_router.m_transaction_id_counts[port_num];
        map<u64, u32>::const_iterator j = tid_cnt_map.find(transaction_id);
        u32 count = (j == tid_cnt_map.end()) ? 0 : j->second;
        tid_cnt_map[transaction_id] = count + 1;
      }
      else {
        XTSC_WARN(m_router.m_text, "Transaction id not stored as port_num (0x" << hex << port_num << ") is invalid");
      }
    }
  }
  m_router.m_first_transfer     = (request.get_transfer_number() == 1);
  // Create our copy of the request
  request_info *p_request_info = m_router.new_request_info(request);
  if (m_router.m_immediate_timing) {
    // Handle this one as our current request
    m_router.handle_request(p_request_info);
    m_router.delete_request_info(p_request_info);
  }
  else {
    // Profile the request fifo
    if (m_router.m_profile_buffers) {
      u32 fifo_size = (u32) ( m_router.m_request_fifo.num_available()       + 
                              m_router.m_waiting_reads_fifo.num_available() +
                              m_router.m_ready_reads_fifo.num_available()    );
      if (fifo_size >= m_router.m_max_num_requests) {
        m_router.m_max_num_requests = fifo_size + 1;
        m_router.m_max_num_requests_timestamp = sc_time_stamp();  
        m_router.m_max_num_requests_tag = request.get_tag();
      }
    }
    // Add request to fifo
    m_router.m_request_fifo.nb_write(p_request_info);
    m_router.m_router_thread_event.notify(SC_ZERO_TIME);
  }
}



void xtsc_component::xtsc_router::xtsc_request_if_impl::nb_load_retired(xtsc_address address8) {
  u32 port_num = (m_router.m_use_route_by_type ? m_router.get_port_by_type(LOAD_RETIRED) : m_router.m_use_route_by_priority ? 0 :
                                                 m_router.get_port_and_apply_address_translation(address8));
  if ((port_num != m_router.DISCARD_REQUEST) && (port_num != m_router.ADDRESS_ERROR)) {
    if (port_num >= m_router.m_num_slaves) {
      ostringstream oss;
      oss << "xtsc_router '" << m_router.name() << "': Invalid port (0x" << hex << port_num << ") returned for address 0x" << hex
          << address8;
      throw xtsc_exception(oss.str());
    }
    else {
      (*m_router.m_request_ports[port_num])->nb_load_retired(address8);
    }
  }
}



void xtsc_component::xtsc_router::xtsc_request_if_impl::nb_retire_flush() {
  // Broadcast to all slaves
  for (u32 i=0; i<m_router.m_num_slaves; ++i) {
    (*m_router.m_request_ports[i])->nb_retire_flush();
  }
}



void xtsc_component::xtsc_router::xtsc_request_if_impl::nb_lock(bool lock) {
  // Broadcast to all slaves
  for (u32 i=0; i<m_router.m_num_slaves; ++i) {
    (*m_router.m_request_ports[i])->nb_lock(lock);
  }
}



void xtsc_component::xtsc_router::xtsc_request_if_impl::register_port(sc_port_base& port, const char *if_typename) {
  if (m_p_port) {
    ostringstream oss;
    oss << "Illegal multiple binding detected to xtsc_router '" << m_router.name() << "' m_request_export: " << endl;
    oss << "  " << port.name() << endl;
    oss << "  " << m_p_port->name();
    throw xtsc_exception(oss.str());
  }
  XTSC_INFO(m_router.m_text, "Binding '" << port.name() << "' to xtsc_router::m_request_export");
  m_p_port = &port;
}



bool xtsc_component::xtsc_router::xtsc_respond_if_impl::nb_respond(const xtsc_response& response) {
  XTSC_VERBOSE(m_router.m_text, response << " Port #" << m_port_num);
  xtsc_log_memory_response_event(m_router.m_binary, VERBOSE_LOG_LEVEL, true, m_port_num, m_router.m_log_data_binary, response);
  if (m_router.m_immediate_timing) {
    bool nacc_response = (response.get_status() == xtsc_response::RSP_NACC);
    if (nacc_response) {
      if (m_router.m_filter_responses) {
        m_router.handle_response_filters(m_port_num, response);
      }
      bool response_accepted =  m_router.m_respond_port->nb_respond(response);
      if (m_router.m_flexible_request_id && response_accepted && m_router.m_first_transfer) {
        m_router.update_transaction_id_counts(m_port_num, response);
      }
      return response_accepted;
    }
    if (!m_router.m_response_fifos[m_port_num]->num_free()) {
      XTSC_VERBOSE(m_router.m_text, response << " Port #" << m_port_num << " (Rejected: Response fifo full)");
      return false;
    }
    if (m_router.m_flexible_request_id) {
      m_router.update_transaction_id_counts(m_port_num, response);
    }
    response_info *p_response_info = m_router.new_response_info(response);
    m_router.m_response_fifos[m_port_num]->nb_write(p_response_info);
    m_router.m_response_arbiter_thread_event.notify(SC_ZERO_TIME);
    return true;
  }
  else {
    if (response.get_status() == xtsc_response::RSP_NACC) {
      if (m_router.m_waiting_for_nacc) {
        m_router.m_request_got_nacc = true;
        return true;
      }
      else {
        ostringstream oss;
        oss << "xtsc_router '" << m_router.name() << "' received nacc too late: " << response << endl;
        oss << " - Possibly something is wrong with the downstream device" << endl;
        oss << " - Possibly this router's \"nacc_wait_time\" needs to be adjusted";
        throw xtsc_exception(oss.str());
      }
    }
    if (!m_router.m_response_fifos[m_port_num]->num_free()) {
      XTSC_VERBOSE(m_router.m_text, response << " Port #" << m_port_num << " (Rejected: Response fifo full)");
      return false;
    }
    if (m_router.m_flexible_request_id) {
      m_router.update_transaction_id_counts(m_port_num, response);
    }
    if (m_router.m_profile_buffers) {
      u32 fifo_size = (u32) m_router.m_response_fifos[m_port_num]->num_available();
      if (fifo_size >= m_router.m_max_num_responses[m_port_num]) {
        m_router.m_max_num_responses[m_port_num] = fifo_size + 1;
        m_router.m_max_num_responses_timestamp[m_port_num] = sc_time_stamp();
        m_router.m_max_num_responses_tag[m_port_num] = response.get_tag();
      }
    }    
    response_info *p_response_info = m_router.new_response_info(response);
    m_router.m_response_fifos[m_port_num]->nb_write(p_response_info);
    m_router.m_response_arbiter_thread_event.notify(SC_ZERO_TIME);
    return true;
  }
}



void xtsc_component::xtsc_router::xtsc_respond_if_impl::register_port(sc_port_base& port, const char *if_typename) {
  if (m_p_port) {
    ostringstream oss;
    oss << "Illegal multiple binding detected to xtsc_router '" << m_router.name() << "' m_respond_export[" << m_port_num
        << "]: " << endl;
    oss << "  " << port.name() << endl;
    oss << "  " << m_p_port->name();
    throw xtsc_exception(oss.str());
  }
  XTSC_INFO(m_router.m_text, "Binding '" << port.name() << "' to xtsc_router::m_respond_export[" << m_port_num << "]");
  m_p_port = &port;
}






