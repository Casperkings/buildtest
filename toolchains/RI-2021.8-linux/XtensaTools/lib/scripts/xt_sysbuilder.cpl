# Copyright (c) 2005-2020 by Cadence Design Systems, Inc.  ALL RIGHTS RESERVED.
# These coded instructions, statements, and computer programs are the
# copyrighted works and confidential proprietary information of 
# Cadence Design Systems, Inc. They may not be modified, copied, reproduced, 
# distributed, or disclosed to third parties in any manner, medium, or form, 
# in whole or in part, without the prior written consent of Cadence Design 
# Systems, Inc.

use strict;
use warnings;

use Cwd;
use Env;
use Getopt::Long;
use Data::Dumper;
use Class::Struct;
use File::Path;
use File::Spec;
use File::Basename;
use YAML::XS qw(LoadFile);
use List::Util qw(first);

# Structure that defines essential fields from the processor params
struct (ProcParams => {
  NX              => '$',
  DataMasterWidth => '$',
  InstMasterWidth => '$',
  DataSlaveWidth  => '$',
  InstSlaveWidth  => '$',
  iDMAWidth       => '$',
  APBMaster       => '$',
  }
);

# Structure that defines an interrupt register.
struct (InterruptReg => {
  globalAddr     => '$',  # Global address of this interrupt register
  bIntrMap       => '%',  # Map from bit offset -> BInterrupt number
  pIntrMap       => '%',  # Map from bit offset -> Proc Interrupt number
  intrTypeMap    => '$',  # Map from bit offset -> Edge or Level; default Edge
  xipcIntrOffset => '$',  # Bit offset of the interrupt used by XIPC components
  xrpIntrOffset  => '$',  # Bit offset of the interrupt used by XRP
  }
);

# Structure that defines a SubSystemMMIO interrupt register.
struct (SubSystemMMIOInterruptReg => {
  globalAddr     => '$',  # Global address of this interrupt register
  localAddr      => '$',  # Local address of this interrupt register
  bIntrMap       => '%',  # Map from bit offset -> BInterrupt number
  pIntrMap       => '%',  # Map from bit offset -> Proc Interrupt number
  procMap        => '%',  # Map from bit offset -> Proc
  xipcIntrMap    => '%',  # Is this bit used for xipc interrupt
  xrpIntrMap     => '%',  # Is this bit used for xrp interrupt
  }
);

# Structure to define a MMIO device
struct (MMIO => {
  globalAddr => '$',             # Global address of the base of the MMIO region
  size       => '$',             # Size in bytes of the MMIO region
  intrReg    => 'InterruptReg',  # Interrupt register, if present
  gpioRegs   => '@',             # List of global addresses of 32b GPIO regs
  controls   => '@',             # List of Controls
  }
);


# Structure that defines control sub register
struct (ControlSubReg => {
  name        => '$',  # Name of the control on cores it is connected to
  comp        => '$',  # Name of the target core / L2
  bitStart    => '$',  # Start of bit offset in register
  bitEnd      => '$',  # End of bit offset in register
  dir         => '$'   # To/from the target core
  }
);
  
# Structure that defines control register
struct (ControlReg => {
  globalAddr  => '$',     # Global address of this control register
  localAddr   => '$',     # Local address of this control register
  subRegs     => '@',     # List of ControlSubReg mapped to this register 
  initValue   => '$',     # Initial value at time of reset
  width       => '$',     # Width of register. 
  readOnly    => '$',     # Is it read only?
  }
);

# Structure to define the SubSystemMMIO
struct (SubSystemMMIO => {
  globalAddr  => '$',    # Global address of the base of the SubSystemMMIO
  size        => '$',    # Size of SubSystemMMIO register space
  intrRegs    => '@',    # List of SubSystemMMIO interrupt registers
  controlRegs => '@',    # List of SubSystemMMIO control registers
  apb         => '$',    # Is it on APB?
  id          => '$',    # Unique id
  name        => '$'     # Name
  }
);

# Strucutre to define the SubSystemIO
struct (SubSystemIO => {
  name      => '$',      # Name of pin
  width     => '$',      # Width of pin
  initValue => '$',      # Initial value at time of reset
  subPins   => '@',      # List of ControlSubRegs
  }
);

# Structure to define an external uDMA attached to the core
struct (UDMA => {
  syncBIntr     => '$',
  syncProcIntr  => '$',
  errorBIntr    => '$',
  errorProcIntr => '$',
  lookupPort    => '$',
  }
);

# Structure to define an external SDMA attached to the core
struct (SDMA => {
  numRequests => '$',
  size        => '$',
  globalAddr  => '$',
  shared      => '$',
  width       => '$'
  }
);

# Structure to define an iDMA
struct (IDMA => {
  shared => '$',
  width  => '$'
  }
);

# Structure to define an XNNE
struct (XNNE => {
  name          => '@', # Name of the XNNE 
  id            => '@', # Id of the XNNE 
  intrMap       => '%', # Map from XNNE interrupt num to BInterrupt num
  intrProcMap   => '%', # Map from XNNE interrupt num to proc name
  interface     => '%', # Map from interface name to proc name
  masterWidths  => '@', # List of master interface widths
  slaveWidth    => '$', # Slave interface width
  size          => '$', # Memory mapped space size
  globalAddr    => '$', # Global address of memory mapped space
  extIntfId     => '$', # External interface this XNNE is connected to
  vpu           => '$', # VPU config
  ubufSize      => '$', # Size of UBUF in bytes
  numMBLKS      => '$', # Number of MBLKS
  masterPortMap => '%', # Map from master port to list of connected components
  masterCompMap => '%', # Map from component to list of connected master ports
  }
);

# Structure to define an ROB
struct (ROB => {
  numEntries => '$' # Number of entries in the ROB
  }
);

# Structure to represent a subsystem external interface
struct (SubSystemExternalInterface => {
  numPorts => '$', # Number of external ports
  rob      => '$', # Defines ROB per port
  procs    => '@', # Processors connected to this interface
  xnnes    => '@', # XNNE connected to this interface
  id       => '$'  # Id for interface
  }
);

# Structure to define a local memory of a processor (instram or dataram)
struct (LocalMem => {
  localAddr   => '$',
  size        => '$',
  globalAddr  => '$',
  numBanks    => '$',
  numSubBanks => '$',
  }
);  

# Stucture to define an icache/dcache of a processor
struct (Cache => {
  lineSize => '$',
  }
);

# Structure to define a processor in the subsystem
struct (Proc => {
  name               => '$',
  config             => '$',
  pipeline           => '$',
  id                 => '$',
  prid               => '$',
  staticVectorSel    => '$',
  altResetVec        => '$',
  dataRamFetchWidth  => '$',
  instRamFetchWidth  => '$',
  pifWidth           => '$',
  dmaWidth           => '$',
  masterWidth        => '$',
  mergedMasterWidth  => '$',
  slaveWidth         => '$',
  masterDataWidth    => '$',
  masterInstWidth    => '$',
  slaveDataWidth     => '$',
  slaveInstWidth     => '$',
  instRam0           => 'LocalMem',
  instRam1           => 'LocalMem',
  dataRam0           => 'LocalMem',
  dataRam1           => 'LocalMem',
  udma               => 'UDMA',
  idma               => 'IDMA',
  sdma               => 'SDMA',
  mmio               => 'MMIO',
  icache             => 'Cache',
  dcache             => 'Cache',
  inBound            => '$',
  apb                => '$',
  isBigEndian        => '$',
  axi                => '$',
  sharedLmemCid      => '$',
  xipcSubSystemMMIO  => '@',
  xrpSubSystemMMIO   => '@',
  extIntfId          => '$',
  isXNNECtrl         => '$',
  masterDataInstMerged => '$',
  slaveDataInstMerged  => '$',
  }
);

# Structure to define a system memories line system RAM, ROM, and
# device memories
struct (SystemMem => {
 name               => '$',
 size               => '$',
 globalAddr         => '$',
 read_delay         => '$',
 read_repeat        => '$',
 write_delay        => '$',
 write_repeat       => '$',
 write_response     => '$',
 request_fifo_depth => '$',
 host_shared        => '$',
 host_name          => '$',
 }
);

# Structure to represent an address range
struct (AddressRange => {
  startAddr => '$',
  size      => '$',
  }
);

# Structure to represent the device tree spec
struct (XRPDeviceTreeSpec => {
  'shared_mem' => '$',
  'queues'     => '@'  # Map of proc name to list of queue priorities
  }
);

# Structure to represent the L2
struct (L2 => {
  name           => '$',
  id             => '$',
  isL2CC         => '$',
  globalAddr     => '$',
  localAddr      => '$',
  size           => '$',
  numPorts       => '$',
  numCorePorts   => '$',
  # For modeling L2CC
  controlRegAddr => '$',
  dataWidth      => '$',
  instWidth      => '$',
  masterWidth    => '$',
  slaveWidth     => '$',
  dmaWidth       => '$',
  lineSize       => '$',
  numWays        => '$',
  latency        => '$',
  coherent       => '$',
  ramOnly        => '$',
  numExclusives  => '$',
  cacheLineSize  => '$',
  # For modeling banked/multi-ported L2 RAM only
  numBanks       => '$',
  interleave     => '$',
  read_delay     => '$',
  read_repeat    => '$',
  write_delay    => '$',
  write_repeat   => '$',
  write_response => '$',
  host_shared    => '$',
  request_fifo_depth => '$',
  }
);

# Structure to represent the system DMA
struct (SystemDMA => {
  baseAddr => '$',
  size => '$',
  numRequests => '$',
  numChannels => '$',
  }
);

# Logging levels
my $logOff         = 0;
my $logNote        = 1;
my $logDebugLevel1 = 2;
my $logDebugLevel2 = 3;
my @logLevelStack  = ($logOff);
my %funcLogLevel;

# XTSC simulator constants
my $INBOUND_ARB_PHASE  = 400;
my $OUTBOUND_PIF_ARB_PHASE = 600;
my $OUTBOUND_SUBSYSTEM_PIF_ARB_PHASE = 550;
my $SDMA_IDMA_ARB_PHASE = 600;
my $SDMA_RDWR_ARB_PHASE = 300;
my $INBOUND_RDWR_ARB_PHASE = 300;
my $XNNE_ARB_PHASE = 400;
my $SYSTEM_DMA_CH_ARB_PHASE = 600;
my $SUB_SYSTEM_MMIO_ARB_PHASE = 400;
my $SYSTEM_DMA_BUS_ARB_PHASE = 400;
my $L2_ARB_PHASE = 400;

# Constants for describing the route id bit fields on XTSC arbiters
# Arbitrate between proc and uDMA, inst/data/dma (for AXI), and idma sharing
# for L2.
# Reserve 0, 1, 2, 3, 4 bits. Supports upto 32 inputs to this arbiter
my $OUTBOUND_PROC_ARB_ROUTE_ID_LSB = 0;

# Reserve 5, 6, 7, 8, 9 for arbitrating from procs to interface
my $OUTBOUND_SUBSYS_ARB_ROUTE_ID_LSB = 5;

# Reserve 10, 11, 12, 13, 14, 15 bits. Support upto 64-inputs on the common bus
my $BUS_ARB_ROUTE_ID_LSB = 10; 

# Reserve 16, 17, 18, 19, 20. Support upto 32-inputs to inbound of a proc
my $INBOUND_ARB_ROUTE_ID_LSB = 16;

my $SYSTEM_DMA_BUS_RDWR_ARB_ROUTE_ID_LSB = 16;
my $SUBSYSTEM_MMIO_ARB_ROUTE_ID_LSB = 16;
my $L2_ARB_ROUTE_ID_LSB = 16;
my $SYSTEM_DMA_CH_ARB_ROUTE_ID_LSB = 17;
my $AXI_DATAINST_ARB_ROUTE_ID_LSB = 21;
my $AXI_MMIO_ARB_ROUTE_ID_LSB = 21;
my $DATARAM_ARB_ROUTE_ID_LSB  = 22;
my $INSTRAM_ARB_ROUTE_ID_LSB  = 22;

# For L2 arbiter nacc wait time. Assuming 1/2 of system clock period of 1000
my $L2_ARB_NACC_WAIT_TIME = 500;

# Variables for option processing
# thisScript   : name of this script
# subSysFile   : subsystem specification file in YAML
# swtools      : path to software tools
# buildDir     : where to generate the xtsc include files, HAL definition etc.
# xtensaSystem : core params registry
# cvsRoot      : FIXME. Path to perforce repository. Temporary HACK 
# inferConfigParams : Infer specification fields from config's param
my ($thisScript, $help, $subSysFile, $swtools, $xtensaSystem, 
    $buildDir, $cvsRoot, $inferConfigParams);

# Misc constants
my $DRAM0 = 0;
my $DRAM1 = 1;
my $IRAM0 = 0;
my $IRAM1 = 1;

# List of supported components
my @knownSubsysComponents = ('SubSystemName', 'Processors', 'SystemRAM',
                             'SystemROM', 'SubSystemInterconnect',
                             'CommonBusWidth', 'InterruptMap', 
                             'SubSystemSoftware', 'DeviceMemories', 'L2', 
                             'SubSystemMMIO', 'SystemDMA', 'Metadata',
                             'SubSystemExternalInterfaces', 'XNNE',
                             'SubSystemIO');

my $COMMON_BUS_ID = -999;

# Any new components - L2, SubSystemMMIOs are assigned ids starting from
# -1.
my $currComponentID = 0;

# Ids 0..127 are reserved for processors
my $LAST_PROC_ID = 127;

# Ids 0..255 are reserved for XNNE
my $LAST_XNNE_ID = 255;

# Counter to generate unique XNNE id
my $currXNNEId = $LAST_PROC_ID;

# Variables that define all the components subsystem

# Subsystem name
my $subSystemName;

# Version. Defaults to 1
my $specVersion = 1;

# Master proc in the subsystem
my $subSysMasterProc;

# Host proc in the subssytem
my $subSysHostProc;

# Map from proc name to Proc structure
my $procNameMap = {};

# Map from proc name to ProcParams structure
my $procParamsNameMap = {};

# Map from proc id to Proc structure
my $procIdMap = {};

# Map from prid to Proc structure
my $pridMap = {};

# Map from XNNE id to XNNE structure
my $xnneIdMap = {};

# Map from XNNE names to XNNE structure
my $xnneNameMap = {};

# Map from shared local mem cluster id to list of Proc structures
my $sharedLocalMemClusterMap = {};

# Map representing subsystem software specific components
# 'xipcSharedDataBuffer' - can be a symbol or a hex address
# 'xrpDeviceTreeSpec'
my $subSystemSoftware = {};

# System ROM
my $systemROM;

# System RAM
my $systemRAM;

# Optional list representing DeviceMemories
my @DeviceMemories = ();

# Optional system DMA
my $SystemDMA;

# Stores the common Bus width which is the max width of all processors
my $subSysBusWidth = 0;

# Map to store processor id to a list of other processors to which it 
# may be connected. The common bus could be in this list and uses an id 
# COMMON_BUS_ID
my $subSysInterconnectTo;

# Map to store processor id to a list of other processors from which it 
# may be connected. The common bus could be in this list and uses an id 
# COMMON_BUS_ID
my $subSysInterconnectFrom;

# Device tree spec XRP
my $xrpDTS;

# Map from name to SubSystemMMIO
my $subSystemMMIOs = {};

# List of name to SubSystemIO
my @subSystemIOs;

# Map from id to SubSystemMMIO
my $subSystemMMIOIds = {};

# Map from name to L2
my $subSystemL2s = {};

# Map from id to L2
my $subSystemL2Ids = {};

# List of subsystem external interfaces
my @subSystemExternalInterfaces;

# Map from proc to list of binterrupts for verification
# across all components that use a Proc's BInterrupt
my $gProcBIntrMap = {};

# Map from proc to list of controls for verification
# across all SubSystemMMIOs/IOs
my $gProcControlMap = {};

$funcLogLevel{"processConfig"}  = $logDebugLevel1;
$funcLogLevel{"createProc"}     = $logDebugLevel1;
$funcLogLevel{"createLocalMem"} = $logDebugLevel1;

# Maintain sorted list of global address ranges 
my @sortedAddrRanges = ();

# List of supported verions
my @supportedVesions = (1, 2);

# Returns a unique id for components. Note, the ids are negative.
# The +-ive ids are reserved for the processor and XNNE ids.
sub getNewComponentID {
  $currComponentID--;
  return $currComponentID;
}

# Return unique id for XNNEs.
sub getNewXNNEId {
  $currXNNEId++;
  return $currXNNEId;
}

# Checks if a given id is a proc
sub isProcId {
  my $id = shift;
  if ($id >= 0 and $id <= $LAST_PROC_ID) {
    return 1;
  }
  return 0;
}

# Checks if a given id is a XNNE
sub isXNNEId {
  my $id = shift;
  if ($id > $LAST_PROC_ID and $id <= $LAST_XNNE_ID) {
    return 1;
  }
  return 0;
}
  
sub usage {
  print <<END_OF_MESSAGE;
Usage : $thisScript -subsys <yaml config file> -swtools dir -build dir

Generates XTSC files from the system description in YAML.

    Option summary:

        -help           - print this message
        -subsys  <soc>  - name of YAML subsystem configuration file to use.
        -swtools <dir>  - where to find the software tools (or customer's
                          Xtensa Tools). 
        -xtensa-system  - optional Xtensa registry where the all of 
                          subsystem's core's params file are defined. Defaults
                          to <swtools>/config.
        -build   <dir>  - optional path to where the xtsc-run include files and 
                          the system HAL files are be generated. If unspecified,
                          the current working directory is assumed.

END_OF_MESSAGE
}

sub pushCurrentLogLevel {
  my $newLogLevel = shift;
  push @logLevelStack, $newLogLevel;
}

sub popCurrentLogLevel {
  pop @logLevelStack;
}

sub printLog {
  my ($msgLogLevel, $msg) = @_;
  my $curLogLevel = $logLevelStack[$#logLevelStack];
  if ($curLogLevel >= $msgLogLevel) {
    print $msg;
  }
}

sub sysBuildError {
  my $msg = shift;
  die "Error at line ".(caller(0))[2]." in func ".(caller(1))[3].". $msg";
}

sub isValidHex {
  my $h = shift;
  return $h =~ /^0x[0-9a-f]+$/i;
}

sub isValidSize {
  my $s = shift;
  return $s =~ /^[1-9][0-9]*(b|Kb|Mb|Gb)?$/;
}

sub isValidNum {
  my $s = shift;
  return $s =~ /^[1-9][0-9]*$/;
}

# Validate if global address ranges of different components
#  do not overlap 
sub verifyAddressRange {
  my ($start_addr, $size) = @_;

  printLog($logDebugLevel2, "   In verifyAddressRange()\n");

  (hex($start_addr)+computeSize($size)-1 <= 0xffffffff) or
    die "verifyAddressRange: $start_addr + $size has to be <= 0xffffffff\n";
  
  my $i = 0;
  foreach my $addr_range (@sortedAddrRanges) {
    if (hex($addr_range->{'startAddr'}) > hex($start_addr)) {
      last;
    }
    $i++;
  }
  my $ar = new AddressRange;
  $ar->{'startAddr'} = $start_addr;
  $ar->{'size'} = computeSize($size);
  if ($i > 0 &&
      hex($start_addr) < (hex($sortedAddrRanges[$i-1]->{'startAddr'}) + 
                          $sortedAddrRanges[$i-1]->{'size'})) {
    die "Error: [$start_addr,".(computeSize($size)-1)."] ".
        "within range of previous address range ".
        "[$sortedAddrRanges[$i-1]->{'startAddr'},".
        ($sortedAddrRanges[$i-1]->{'size'}-1)."]\n";
  }
  if ($i < $#sortedAddrRanges) {
    if ((hex($start_addr)+computeSize($size)-1) >= 
        hex($sortedAddrRanges[$i]->{'startAddr'})) {
      printLog($logDebugLevel1, 
               join(", ", map("{".$_->{'startAddr'}.",".$_->{'size'}."}", 
                              @sortedAddrRanges))."\n");
      die "Error: [$start_addr,".(computeSize($size)-1)."] ".
          "within range of next address range ".
          "[$sortedAddrRanges[$i]->{'startAddr'},".
          ($sortedAddrRanges[$i]->{'size'}-1)."]\n";
    }
  }
  splice @sortedAddrRanges, $i, 0, $ar;

  printLog($logDebugLevel2, "   Leaving verifyAddressRange()\n");
}

# Verify local memory specification
sub verifyLocalMem {
  my ($proc, $mem) = @_;

  ref($proc->{$mem}) eq 'HASH' or 
    die "Error: $mem specification needs to be a map\n";

  # LocalAddr is required on the InstRams/DataRams
  defined $proc->{$mem}->{'LocalAddr'} or 
    die "Error: LocalAddr undefined for $mem for proc $proc->{'Name'}\n";

  # Size is required on the InstRams/DataRams
  defined $proc->{$mem}->{'Size'} or 
    die "Error: Size undefined for $mem for proc $proc->{'Name'}\n";

  # Number of banks is required only for the DataRams. Should not be specified
  # for the InstRam
  if ($mem eq 'InstRam0' or $mem eq 'InstRam1') {
   !defined $proc->{$mem}->{'NumBanks'} or
     die "Error: NumBanks should not be defined for $mem for ".
         "proc $proc->{'Name'}\n";
  } else {
    defined $proc->{$mem}->{'NumBanks'} or
     die "Error: NumBanks not defined for $mem for proc $proc->{'Name'}\n";
  }

  !defined $proc->{$mem}->{'NumBanks'} or
  isValidNum($proc->{$mem}->{'NumBanks'}) or
    die "Error: NumBanks not a valid integer for $mem for ".
        "proc $proc->{'Name'}\n";

  !defined $proc->{$mem}->{'NumSubBanks'} or
  isValidNum($proc->{$mem}->{'NumSubBanks'}) or
    die "Error: NumSubBanks not a valid integer for $mem for ".
        "proc $proc->{'Name'}\n";

  # Global and local addresses should be in hex
  if (defined $proc->{$mem}->{'GlobalAddr'}) {
    isValidHex($proc->{$mem}->{'GlobalAddr'}) or
      die "Error: $proc->{'Name'}'s $mem GlobalAddr has to be in hex\n";
  }

  isValidHex($proc->{$mem}->{'LocalAddr'}) or
    die "Error: $proc->{'Name'}'s $mem LocalAddr has to be in hex\n";

  isValidSize($proc->{$mem}->{'Size'}) or
    die "Error: $proc->{'Name'}'s $mem Size has to be <num>(|b|Kb|Mb)\n";

  if (defined $proc->{$mem}->{'GlobalAddr'}) {
    verifyAddressRange($proc->{$mem}->{'GlobalAddr'}, 
                       $proc->{$mem}->{'Size'});
  }
}

# Verify the processor specification in the subsystem spec file
sub verifyProc {
  my $proc = shift;

  printLog($logDebugLevel2, "   In verifyProc()\n");

  defined $proc->{'Name'} or die "Error: Processor name undefined\n";
  ($proc->{'Name'} =~ /^[a-zA-Z][a-zA-Z0-9_]+$/) or 
    die "Error: Processor name has to be a alpha numerical ".
        "(underscores allowed) beginning with a letter \n";

  defined $proc->{'Config'} or 
    die "Error: Processor config undefined for proc $proc->{'Name'}\n";

  defined $proc->{'ProcId'} or 
    die "Error: Processor id undefined for proc $proc->{'Name'}\n";

  ($proc->{'ProcId'} =~ /^\d+$/) or 
    die "Error: Processor ID for $proc->{'Name'} has to be an integer\n";

  ($proc->{'ProcId'} >= 0 and $proc->{'ProcId'} <= $LAST_PROC_ID) or
    die "Error: Processor ID for $proc->{'Name'} ($proc->{'ProcId'}) ".
        "has to be between 0..$LAST_PROC_ID\n";

  if (defined $proc->{'PRID'}) {
    ($proc->{'PRID'} =~ /^\d+$/) or 
      die "Error: Processor PRID for $proc->{'Name'} has to be an integer\n";
  } else {
    $proc->{'PRID'} = $proc->{'ProcId'};
  }
  ($proc->{'PRID'} >= 0 and $proc->{'PRID'} < 64) or
    die "Processor PRID For $proc->{'Name'}, $proc->{'PRID'}, has to be ".
        "between 0..63\n";

  # Optional pipeline - NX/LX. Defaults to LX.
  if (!defined $proc->{'Pipeline'}) {
    $proc->{'Pipeline'} = 'LX';
  }
  $proc->{'Pipeline'} eq 'LX' or $proc->{'Pipeline'} eq 'NX' or
    die "Pipeline has to be LX/NX for proc $proc->{'Name'}\n";

  # Optional AXI. 
  if (!defined $proc->{'AXI'}) {
    $proc->{'AXI'} = $proc->{'Pipeline'} eq 'NX' ? 1 : 0;
  } else {
    ($proc->{'AXI'} == 0 || $proc->{'AXI'} == 1) or 
      die "Error: AXI flag on $proc->{'Name'} needs to be true/false\n";
  }

  # Optional XNNE Cntrl. 
  if (defined $proc->{'XNNECtrl'}) {
    ($proc->{'XNNECtrl'} == 0 || $proc->{'XNNECtrl'} == 1) or 
      die "Error: XNNECtrl flag on $proc->{'Name'} needs to be true/false\n";
  }

  if ($proc->{'AXI'} == 0 and $proc->{'Pipeline'} eq 'NX') {
    die "Error: Proc $proc->{'Name'} has a NX pipeline but is not on AXI\n";
  }

  if (defined $proc->{'APBMaster'}) {
    $proc->{'APBMaster'} == 1 or
      die "Error: APBMaster flag on $proc->{'Name'} needs to be true\n";
  }
    
  if (defined $proc->{'Master'}) {
    ($proc->{'Master'} == 0 || $proc->{'Master'} == 1) or 
      die "Error: Master flag on $proc->{'Name'} needs to be true/false\n";
  }

  if (defined $proc->{'Host'}) {
    ($proc->{'Host'} == 0 || $proc->{'Host'} == 1) or 
      die "Error: Master flag on $proc->{'Name'} needs to be true/false\n";
  }

  if (defined $proc->{'BigEndian'}) {
    $proc->{'BigEndian'} == 1 or
      die "Error: BigEndian flag on $proc->{'Name'} needs to be true\n";
  }

  # If Static vector sel is not specified, assume boot from primary location
  if (defined $proc->{'StaticVectorSel'}) {
    ($proc->{'StaticVectorSel'} == 0 || $proc->{'StaticVectorSel'} == 1) or
       die "Error: StaticVectorSel flag on $proc->{'Name'} ".
           "needs to be 1 or 0\n";
  } else {
    $proc->{'StaticVectorSel'} = 0;
  }

  if (defined $proc->{'AltResetVecAddr'}) {
    isValidHex($proc->{'AltResetVecAddr'}) or 
      die "AltResetVecAddr for $proc->{'Name'} has to be a hex number\n";
  }

  # DataRamFetchWidth is optional - assumes no local data memories
  if (defined $proc->{'DataRamFetchWidth'}) {
    defined $proc->{'DataRam0'} or 
      die "DataRamFetchWidth specification for $proc->{'Name'} ".
          "requires DataRam0 also to be specified\n";
    isValidSize($proc->{'DataRamFetchWidth'}) or
      die "Error: $proc->{'Name'}'s DataRamFetchWidth ".
          "has to be <num>(b|Kb|Mb)\n";
  }

  # InstRamFetchWidth is optional - assumes no local inst memories
  if (defined $proc->{'InstRamFetchWidth'}) {
    defined $proc->{'InstRam0'} or 
      die "InstRamFetchWidth specification for $proc->{'Name'} ".
          "requires InstRam0 also to be specified\n";
    isValidSize($proc->{'InstRamFetchWidth'}) or
      die "Error: $proc->{'Name'}'s InstRamFetchWidth ".
          "has to be <num>(b|Kb|Mb)\n";
  }

  # PifWidth required
  if ($proc->{'Pipeline'} eq 'LX') {
    defined $proc->{'PifWidth'} or 
      die "Error : PIF width undefined for  proc $proc->{'Name'}\n";
    isValidSize($proc->{'PifWidth'}) or
      die "Error: $proc->{'Name'}'s PifWidth has to be <num>(b|Kb|Mb)\n";
  } else {
    if (defined $proc->{'MasterDataInstMerged'}) {
      # If DataInstMerged is set, MasterWidth needs to be specified
      $proc->{'MasterDataInstMerged'} == 1 or
        die "Error: MasterDataInstMerged flag on $proc->{'Name'} ".
            "needs to be true\n";
      defined $proc->{'MasterWidth'} or 
        die "Error : Master data/inst is merged, but master width ".
            "is undefined for proc $proc->{'Name'}\n";
      (!defined $proc->{'MasterDataWidth'} and 
       !defined $proc->{'MasterInstWidth'}) or
        die "Error : MasterWidth and MasterDataWidth/MasterInstWidth ".
            "cannot both be defined\n";
    } else {
      # Else, needs MasterDataWidth and MasterInstWidth
      defined $proc->{'MasterDataWidth'} or 
        die "Error : Data master width undefined for proc $proc->{'Name'}\n";

      isValidSize($proc->{'MasterDataWidth'}) or
        die "Error: $proc->{'Name'}'s MasterDataWidth has to be ".
            "<num>(b|Kb|Mb)\n";

      defined $proc->{'MasterInstWidth'} or
        die "Error : Inst master width undefined for proc $proc->{'Name'}\n";

      isValidSize($proc->{'MasterInstWidth'}) or
        die "Error: $proc->{'Name'}'s MasterInstWidth has to be ".
            "<num>(b|Kb|Mb)\n";

      !defined $proc->{'MasterWidth'} or
        die "Error : $proc->{'Name'}'s MasterWidth and ".
            "MasterDataWidth/MasterInstWidth cannot both be defined\n";
    }
    if (defined $proc->{'SlaveDataInstMerged'}) {
      $proc->{'SlaveDataInstMerged'} == 1 or
        die "Error: SlaveDataInstMerged flag on $proc->{'Name'} ".
            "needs to be true\n";
      defined $proc->{'SlaveWidth'} or 
        die "Error : Slave data/inst is merged, but ".
            "slave width is undefined for proc $proc->{'Name'}\n";
      (!defined $proc->{'SlaveDataWidth'} and 
       !defined $proc->{'SlaveInstWidth'}) or
        die "Error : $proc->{'Name'}'s ".
            "SlaveDataWidth/SlaveInstWidth only valid if ".
            "SlaveDataInstMerged is not set\n";
    } else {
      !defined $proc->{'SlaveWidth'} or
        die "Error : $proc->{'Name'}'s SlaveWidth only valid if ".
            "SlaveDataInstMerged is set\n";
    }
  }

  if (defined $proc->{'IDMA'}) {
    if (ref($proc->{'IDMA'}) ne 'HASH') {
      $specVersion == 1 or 
        die "Spec version mismatch for IDMA for proc $proc->{'Name'}. ".
            "Expected version 1\n";
      ($proc->{'IDMA'} eq 'Shared' || $proc->{'IDMA'} eq 'Excl') or
        die "Error: IDMA flag on $proc->{'Name'} needs to be Shared/Excl\n";
    } else {
      $specVersion == 2 or 
        die "Spec version mismatch for IDMA for proc $proc->{'Name'}. ".
            "Expected version 2\n";
      defined $proc->{'IDMA'}->{'Shared'} or 
        die "Shared attribute not defined for IDMA on $proc->{'Name'}\n";
      $proc->{'IDMA'}->{'Shared'} == 1 or $proc->{'IDMA'}->{'Shared'} == 0 or
        die "Error: Shared flag for IDMA on proc $proc->{'Name'} ".
            "needs to be true/false\n";
    }
  }

  if (defined $proc->{'iDMAWidth'}) {
    $specVersion == 1 or die "iDMAWidth supported only for spec version == 1\n";
    defined $proc->{'IDMA'} or
      die "iDMAWidth defined, but IDMA not defined for $proc->{'Name'}\n";
  }

  # InstRam0 is optional
  if (defined $proc->{'InstRam0'}) {
    defined $proc->{'InstRamFetchWidth'} or 
      die "InstRam0 specification for $proc->{'Name'} ".
          "requires InstRamFetchWidth also to be specified\n";
    verifyLocalMem($proc, 'InstRam0');
  }

  # InstRam1 can be defined only if InstRam0 is also defined
  if (defined $proc->{'InstRam1'}) {
    defined $proc->{'InstRam0'} or 
      die "InstRam1 specification for $proc->{'Name'} ".
          "requires InstRam0 also to be specified\n";
    verifyLocalMem($proc, 'InstRam1');
  }

  if (defined $proc->{'DataRam0'}) {
    defined $proc->{'DataRamFetchWidth'} or 
     die "DataRam0 specification for $proc->{'Name'} ".
         "requires DataRamFetchWidth also to be specified\n";
    verifyLocalMem($proc, 'DataRam0');
  }

  if (defined $proc->{'DataRam1'}) {
    defined $proc->{'DataRam0'} or 
      die "DataRam1 specification for $proc->{'Name'} ".
          "requires DataRam0 also to be specified\n";
    verifyLocalMem($proc, 'DataRam1');
  }

  # Validate uDMA
  if (defined $proc->{'UDMA'}) {
    ref ($proc->{'UDMA'}) eq 'HASH' or 
      die "Error: UDMA specification for $proc->{'Name'} has to be a map\n";

    defined $proc->{'UDMA'}->{'SyncInterrupt'} or 
      die "Error: SyncInterrupt undefined for uDMA for proc $proc->{'Name'}\n";
    ref ($proc->{'UDMA'}->{'SyncInterrupt'}) eq 'HASH' or 
      die "Error: UDMA SyncInterrupt specification for ".
          "$proc->{'Name'} has to be a map\n";

    defined $proc->{'UDMA'}->{'ErrorInterrupt'} or 
      die "Error: ErrorInterrupt undefined for uDMA for proc ".
          "$proc->{'Name'}\n";
    ref ($proc->{'UDMA'}->{'ErrorInterrupt'}) eq 'HASH' or 
      die "Error: UDMA ErrorInterrupt specification for ".
          "$proc->{'Name'} has to be a map\n";

    defined $proc->{'UDMA'}->{'SyncInterrupt'}->{'BInterrupt'} or 
      die "Error: BInterrupt undefined for SyncInterrupt in uDMA for ".
          "proc $proc->{'Name'}\n";
    defined $proc->{'UDMA'}->{'ErrorInterrupt'}->{'BInterrupt'} or 
      die "Error: BInterrupt undefined for ErrorInterrupt in uDMA for ".
          "proc $proc->{'Name'}\n";

    defined $proc->{'UDMA'}->{'SyncInterrupt'}->{'ProcInterrupt'} or 
      die "Error: ProcInterrupt undefined for SyncInterrupt in uDMA for ".
          "proc $proc->{'Name'}\n";
    defined $proc->{'UDMA'}->{'ErrorInterrupt'}->{'ProcInterrupt'} or 
      die "Error: ProcInterrupt undefined for ErrorInterrupt in uDMA for ".
          "proc $proc->{'Name'}\n";

    ($proc->{'UDMA'}->{'SyncInterrupt'}->{'BInterrupt'} =~ /^\d+$/) or 
      die "Error: BInterrupt id for UDMA SyncInterrupt has to be an integer\n";
    ($proc->{'UDMA'}->{'ErrorInterrupt'}->{'BInterrupt'} =~ /^\d+$/) or 
      die "Error: BInterrupt id for UDMA ErrorInterrupt has to be an integer\n";

    ($proc->{'UDMA'}->{'SyncInterrupt'}->{'ProcInterrupt'} =~ /^\d+$/) or 
      die "Error: ProcInterrupt id for UDMA SyncInterrupt ".
          "has to be an integer\n";
    ($proc->{'UDMA'}->{'ErrorInterrupt'}->{'ProcInterrupt'} =~ /^\d+$/) or 
      die "Error: ProcInterrupt id for UDMA ErrorInterrupt ".
          "has to be an integer\n";

    defined $proc->{'UDMA'}->{'LookupPort'} or 
    die "Error: LookupPort name undefined for uDMA for proc $proc->{'Name'}\n";

    ($proc->{'UDMA'}->{'LookupPort'} =~ /^[a-zA-Z][a-zA-Z0-9_]+$/) or 
      die "Error: Invalid lookup port name $proc->{'UDMA'}->{'LookupPort'}\n";

    defined $proc->{'DataRam0'} or
      die "UDMA for $proc->{'Name'} requires DataRam0 to be specified\n";

    defined $proc->{'DataRam1'} or
      die "UDMA for $proc->{'Name'} requires DataRam1 to be specified\n";

    !defined $proc->{'IDMA'} or
      die "IDMA and UDMA cannot co-exist for $proc->{'Name'}\n";

    (!defined $proc->{'DataRam0'}->{'NumSubBanks'} ||
     $proc->{'DataRam0'}->{'NumSubBanks'} == 1) or
      die "uDMA requires no sub-banks defined or have just 1 sub-bank\n";
  }

  # Validate SDMA
  if (defined $proc->{'SDMA'}) {
    ref ($proc->{'SDMA'}) eq 'HASH' or 
      die "Error: SDMA specification for $proc->{'Name'} has to be a map\n";

    !defined $proc->{'SDMA'}->{'NumRequests'} or
    ($proc->{'SDMA'}->{'NumRequests'} =~ /^\d+$/) or 
      die "Error: NumRequests for SDMA has to be an integer\n";

    if (!defined $proc->{'SDMA'}->{'NumRequests'}) {
      $proc->{'SDMA'}->{'NumRequests'} = 16;
    }

    defined $proc->{'SDMA'}->{'GlobalAddr'} or 
      die "Error: GlobalAddr undefined for SDMA for proc $proc->{'Name'}\n";
    isValidHex($proc->{'SDMA'}->{'GlobalAddr'}) or
     die "Error: GlobalAddr for SDMA for proc $proc->{'Name'} ".
         "has to be in hex\n";

    verifyAddressRange($proc->{'SDMA'}->{'GlobalAddr'}, 256*256);
  }

  # Validate LocalMMIO specification
  if (defined $proc->{'LocalMMIO'}) {
    ref ($proc->{'LocalMMIO'}) eq 'HASH' or
      die "Error. LocalMMIO specification for proc $proc->{'Name'} ".
          "has to be a map\n";

    defined $proc->{'LocalMMIO'}->{'GlobalAddr'} or 
    die "Error: GlobalAddr undefined for LocalMMIO for proc $proc->{'Name'}\n";

    isValidHex($proc->{'LocalMMIO'}->{'GlobalAddr'}) or
      die "Error: GlobalAddr for LocalMMIO for proc $proc->{'Name'} ".
          "has to be in hex\n";

    defined $proc->{'LocalMMIO'}->{'Size'} or 
      die "Error: Size undefined for LocalMMIO for proc $proc->{'Name'}\n";
    isValidSize($proc->{'LocalMMIO'}->{'Size'}) or
      die "Error: $proc->{'Name'}'s LocalMMIO Size has to be <num>(b|Kb|Mb)\n";
    computeSize($proc->{'LocalMMIO'}->{'Size'}) >= 4 or
      die "Error: $proc->{'Name'}'s LocalMMIO Size has to be >= 4b\n";

    defined $proc->{'LocalMMIO'}->{'InterruptRegister'} or 
      die "Error: InterruptRegister undefined for LocalMMIO for ".
          "proc $proc->{'Name'}\n";
    ref ($proc->{'LocalMMIO'}->{'InterruptRegister'}) eq 'HASH' or
      die "Error. LocalMMIO InterruptRegister specification for ".
          "proc $proc->{'Name'} has to be a map\n";

    defined $proc->{'LocalMMIO'}->{'InterruptRegister'}->{'GlobalAddr'} or
      die "Error: GlobalAddr undefined for interrupt register in ".
          "LocalMMIO for proc $proc->{'Name'}\n";
    isValidHex($proc->{'LocalMMIO'}->{'InterruptRegister'}->{'GlobalAddr'}) or
      die "Error: InterruptRegister GlobalAddr in LocalMMIO for proc ".
          "$proc->{'Name'} has to be in hex\n";

    defined $proc->{'LocalMMIO'}->{'InterruptRegister'}->{'InterruptMap'} or
      die "Error: InterruptMap undefined for interrupt register in ".
          "LocalMMIO for proc $proc->{'Name'}\n";
    ref ($proc->{'LocalMMIO'}->{'InterruptRegister'}->{'InterruptMap'}) 
      eq 'ARRAY' or
        die "Error. LocalMMIO InterruptMap specification for ".
            "interrupt register in proc $proc->{'Name'} has to be a list\n";
    scalar @{$proc->{'LocalMMIO'}->{'InterruptRegister'}->{'InterruptMap'}} > 0 
      or die "Error: No interrupts mapped in interrupt register in ".
             "LocalMMIO for proc $proc->{'Name'}\n";

    if (defined $proc->{'LocalMMIO'}->{'GPIORegisters'}) {
      ref($proc->{'LocalMMIO'}->{'GPIORegisters'}) eq 'ARRAY' or
        die "Error: GPIORegisters specification for ".
            "LocalMMIO for proc $proc->{'Name'} has to be a list\n";
      foreach my $gpio_reg (@{$proc->{'LocalMMIO'}->{'GPIORegisters'}}) {
        isValidHex($gpio_reg) or 
          die "Error: GPIORegisters in LocalMMIO for ".
              "proc $proc->{'Name'} has to be in hex\n";
      }
    }
    verifyAddressRange($proc->{'LocalMMIO'}->{'GlobalAddr'}, 
                       $proc->{'LocalMMIO'}->{'Size'});
  }

  if (defined $proc->{'Dcache'}) {
    defined $proc->{'Dcache'}->{'LineSize'} or 
      die "Error: LineSize undefined for Dcache on proc $proc->{'Name'}\n";
    isValidNum($proc->{'Dcache'}->{'LineSize'}) or 
      die "Error: LineSize for Dcache on proc $proc->{'Name'} not an integer\n";
  }

  if (defined $proc->{'SharedLocalMemClusterId'}) {
    !defined $proc->{'UDMA'} or 
      die "Error: UDMA not supported for shared local memories\n";
    my $cid = $proc->{'SharedLocalMemClusterId'};
    if (defined $sharedLocalMemClusterMap->{$cid}) {
      my $cluster_proc = ${$sharedLocalMemClusterMap->{$cid}}[0];
      !defined $proc->{'DataRam0'} or 
        die "Error: Duplicate dataram0 defined for proc $proc->{'Name'} ".
            "in shared local mem cluster $cid. Proc $cluster_proc->{'name'} ".
            "has local dataram0 already defined\n";
    } else {
      defined $proc->{'DataRam0'} or 
        die "SharedLocalMemClusterId defined but proc $proc->{'Name'} ".
            "has no DataRam0\n";
    }
  }

  printLog($logDebugLevel2, "   Leaving verifyProc()\n");
}

# XTSC master 
sub generateXTSCTestBenchMasterVecAndRoutingTable {
  my $xtsc_run_gen_dir = shift;

  my $xtsc_testbench_master_vec = "$xtsc_run_gen_dir/TestBenchMaster.vec";
  open(xtsc_testbench_master_vec, ">$xtsc_testbench_master_vec") or 
    sysBuildError("Could not open $xtsc_testbench_master_vec\n");
  close xtsc_testbench_master_vec;

  my $xtsc_testbench_master_rte_tab = 
     "$xtsc_run_gen_dir/TestBenchMaster_rte.tab";

  open(xtsc_testbench_master_rte_tab, ">$xtsc_testbench_master_rte_tab") or 
    sysBuildError("Could not open $xtsc_testbench_master_rte_tab\n");

  print xtsc_testbench_master_rte_tab 
        "/* <Port>  <LowAddr>   <HighAddr>  <NewBaseAddr>  */\n\n";
  close xtsc_testbench_master_rte_tab;
}

# Lua process to terminate simulation when host exits
sub generateSimCntrlLua {
  my $xtsc_run_gen_dir = shift;

  # Check for core that is an XNNE controller
  my $xnneCtrlProc;
  foreach my $proc (values %$procIdMap) {
    if ($proc->{'isXNNECtrl'}) {
      $xnneCtrlProc = $proc;
      last;
    }
  }
     
  if (!defined $subSysHostProc and !defined $xnneCtrlProc) {
    return;
  }

  my $ctrl = defined $subSysHostProc ? $subSysHostProc : $xnneCtrlProc;

  # Lua script to terminate simulation
  my $lua_scr = "$xtsc_run_gen_dir/sim_cntrl.lua";
  open(lua_scr, ">$lua_scr") or sysBuildError("Could not open $lua_scr\n");
 
  print lua_scr "xtsc.cmd(\"sc wait " . $ctrl->{'name'} . 
                ".core_exited_event\")\n";
  print lua_scr "xtsc.cmd(\"sc wait 1000\")\n";
  print lua_scr "rc = xtsc.cmd(\"" . $ctrl->{'name'} . 
                " get_exit_code\")\n";
  print lua_scr "if rc == \"0\" then\n";
  print lua_scr " xtsc.cmd(\"xtsc note 0 exit code\")\n";
  print lua_scr "else\n";
  print lua_scr " xtsc.cmd(\"xtsc note exit code is \" .. rc)\n";
  print lua_scr "end\n";
  print lua_scr "xtsc.cmd(\"xtsc note " . $ctrl->{'name'} . 
                " exited, now calling sc_stop\")\n";
  print lua_scr "xtsc.cmd(\"sc sc_stop\")\n";
  close lua_scr;
}

# Add script for ISS profiliing
sub generateXTSCProfileCmds {
  my $xtsc_run_gen_dir = shift;

  my $profile_cmds = "$xtsc_run_gen_dir/profile.cmds";

  open(profile_cmds, ">$profile_cmds") or 
    sysBuildError("Could not open $profile_cmds\n");

  print profile_cmds <<EOF;
profile --disable --all --no-inclusive gmon.out
EOF
  close xtsc_logger;
}

# Add firmware control for XNNE
sub generateXTSCXNNEFirmware {
  my $xtsc_run_gen_dir = shift;

  if (! scalar keys %$xnneIdMap) {
    return;
  }

  my $xtsc_firmware = "$xtsc_run_gen_dir/XNNE_firmware_simcall.vec";

  open(xtsc_firmware, ">$xtsc_firmware") or 
    sysBuildError("Could not open $xtsc_firmware\n");

  print xtsc_firmware <<EOF;
/*
 * Copyright 2020 Cadence Design Systems. All rights reserved.
 * 
 * These coded instructions, statements, and computer programs are the
 * copyrighted works and confidential proprietary information of
 * Tensilica Inc.  They may be adapted and modified by bona fide
 * purchasers for internal use, but neither the original nor any adapted
 * or modified version may be disclosed or distributed to third parties
 * in any manner, medium, or form, in whole or in part, without the prior
 * written consent of Tensilica Inc.
 */

#lua_beg
--                              arg1 arg2 arg3   arg4 arg5  arg6
function firmware_simcall(core, cnt, hdr, slice, msg, arg5, arg6)
  note  = false
  stop  = (slice == 0xdeadbeef)
  cnt   = ((cnt < 0) and 0x100000000 or 0) + cnt
  slice = stop and 0 or slice
  text  = string.format("%4d", cnt)           .. " " ..
          string.format("0x%08x", hdr)        .. " " ..
          string.format("[%2d]", slice)       .. " " ..
          string.format("msg=0x%08x", msg)
  xtsc.cmd("xtsc " .. (note and "note" or "info") .. " XNNE_firmware_simcall.vec: " .. text);
  if (stop) then
    xtsc.cmd("xtsc warn XNNE_firmware_simcall.vec: VPU firmware reported error for FNTYPE (" .. string.format("0x%x", hdr) .. ").  Stopping simulation.")
    xtsc.cmd("sc sc_stop")
  end
  return tonumber(xtsc.cmd("sc sc_delta_count"))
end
#lua_end

lua_function simcall firmware_simcall
EOF
}

# Add XTSC logger
sub generateXTSCLogger {
  my $xtsc_run_gen_dir = shift;

  # XNNE log setting
  my $xnne_log = "";
  foreach my $xnne (values %$xnneIdMap) {
    $xnne_log .= "log4xtensa.logger.$xnne->{'name'}.sblk0=NOTE, file\n";
    $xnne_log .= "log4xtensa.additivity.$xnne->{'name'}.sblk0=false\n";
    $xnne_log .= "log4xtensa.logger.$xnne->{'name'}.sblk1=NOTE, file\n";
    $xnne_log .= "log4xtensa.additivity.$xnne->{'name'}.sblk1=false\n";
    $xnne_log .= "\n";
  }

  my $xtsc_logger = "$xtsc_run_gen_dir/$subSystemName.logger.txt";

  open(xtsc_logger, ">$xtsc_logger") or 
    sysBuildError("Could not open $xtsc_logger\n");

  print xtsc_logger <<EOF;
# Copyright 2020 Cadence Design Systems. All rights reserved.
# 
# These coded instructions, statements, and computer programs are the
# copyrighted works and confidential proprietary information of
# Tensilica Inc.  They may be adapted and modified by bona fide
# purchasers for internal use, but neither the original nor any adapted
# or modified version may be disclosed or distributed to third parties
# in any manner, medium, or form, in whole or in part, without the prior
# written consent of Tensilica Inc.

# See the logging chapter in the "XTSC User's Guide" for information about this file.

# Configure all loggers at INFO_LOG_LEVEL and to use two appenders named "file" and "console".
# Change "INFO" to "NOTE" to reduce log file size and speed up simulation.
# Change "INFO" to "VERBOSE" or "DEBUG" to increase log file size and slow down simulation.
log4xtensa.rootLogger=NOTE, file, console

# Uncomment the following lines and change LOGGERNAME to desired logger name to cause
# that logger to log at DEBUG_LOG_LEVEL.
#log4xtensa.logger.LOGGERNAME=DEBUG, file, console
#log4xtensa.additivity.LOGGERNAME=false

$xnne_log

# Configure appender "file" to be a FileAppender that sends its output to file "xtsc.log".
log4xtensa.appender.file=log4xtensa::FileAppender
log4xtensa.appender.file.File=xtsc.log
log4xtensa.appender.file.Append=false
log4xtensa.appender.file.layout=log4xtensa::PatternLayout
log4xtensa.appender.file.layout.ConversionPattern=%-7p %-26c - %m%n

# Configure appender "consoleINFO" to be a ConsoleAppender that
# accepts messages at INFO_LOG_LEVEL or higher.
log4xtensa.appender.consoleINFO=log4xtensa::ConsoleAppender
log4xtensa.appender.consoleINFO.Threshold=INFO
log4xtensa.appender.consoleINFO.layout=log4xtensa::PatternLayout
log4xtensa.appender.consoleINFO.layout.ConversionPattern=%-7p %-37c - %m%n

# Configure appender "console" to be a ConsoleAppender that only
# accepts messages at WARN_LOG_LEVEL or higher.
log4xtensa.appender.console=log4xtensa::ConsoleAppender
log4xtensa.appender.console.Threshold=WARN
log4xtensa.appender.console.layout=log4xtensa::PatternLayout
log4xtensa.appender.console.layout.ConversionPattern=%-7p %-37c - %m%n

#
# Conversion characters in ConversionPattern:
# p             = log level
# c             = logger name
# m             = message
# n             = newline
# l             = File:Line
# L             = Line
# F             = File
# D             = Date and time

#
# Format Modifiers in ConversionPattern:
# <Number>      = Number of characters
# -             = left justify
# .<Number>     = <Number> is a maximum
# %D{<Format>}  = Display date/time using <Format>

# Example fields in ConversionPattern:
# %10c          = Print logger name right-justified with min width of 10 
# %-10c         = Print logger name left-justified with min width of 10 
# %.20c         = Print logger name right-justified with max width of 20 
# %-.20c        = Print logger name left-justified with max width of 20 
# %10.20c       = Print logger name right-justified with min width of 10 and max width of 20 
# %-10.20c      = Print logger name left-justified with min width of 10 and max width of 20 
# %D %D{%q}     = Print full local date and time followed by millisecond
EOF
  close xtsc_logger;
}

# Process cache spec
sub createCache {
  my ($cache_spec, $proc) = @_;

  printLog($logDebugLevel2, "   In createCache()\n");

  ref ($cache_spec) eq 'HASH' or 
    die "Error: Cache specification for $proc->{'Name'} has to be a map\n";

  ($cache_spec->{'LineSize'} =~ /^\d+$/) or 
    die "Error: LineSize of cache spec for $proc->{'Name'} ".
        "has to be an integer\n";

  my $cache = new Cache;
  $cache->{'lineSize'} = $cache_spec->{'LineSize'};
  $cache->{'lineSize'} > 0 and 
    (($cache->{'lineSize'} & ($cache->{'lineSize'}-1)) == 0) or
    sysBuildError("Linesize of cache of proc $proc->{'name'}'s ".
                  "has to be a power of 2 number\n");

  printLog($logDebugLevel2, "   Leaving createCache()\n");

  return $cache;
}

# Process local mem spec
sub createLocalMem {
  my ($lmem_spec, $proc) = @_;

  printLog($logDebugLevel2, "   In createLocalMem()\n");

  my $lmem = new LocalMem ;
  $lmem->{'localAddr'} = $lmem_spec->{'LocalAddr'};
  if (defined $lmem_spec->{'GlobalAddr'}) {
    $lmem->{'globalAddr'} = $lmem_spec->{'GlobalAddr'};
  } 
  $lmem->{'size'} = computeSize($lmem_spec->{'Size'});
  if (defined $lmem_spec->{'NumBanks'}) {
    $lmem->{'numBanks'} = $lmem_spec->{'NumBanks'};
  } else {
    $lmem->{'numBanks'} = 1;
  }
  if (defined $lmem_spec->{'NumSubBanks'}) {
    $lmem->{'numSubBanks'} = $lmem_spec->{'NumSubBanks'};
  } else {
    $lmem->{'numSubBanks'} = 1;
  }

  # numBanks if defined has to be a power of 2
  if (defined $lmem->{'numBanks'}) {
    $lmem->{'numBanks'} > 0 and 
      (($lmem->{'numBanks'} & ($lmem->{'numBanks'}-1)) == 0) or
      sysBuildError("Number of banks of proc $proc->{'name'}'s local memory ".
                    "@ $lmem->{'localAddr'} has to be a power of 2 number\n");
  }

  # numSubBanks if defined has to be a power of 2
  if (defined $lmem->{'numSubBanks'}) {
    $lmem->{'numSubBanks'} > 0 and 
      (($lmem->{'numSubBanks'} & ($lmem->{'numSubBanks'}-1)) == 0) or
      sysBuildError("Number of sub-banks of proc $proc->{'name'}'s ".
                    "local memory @ $lmem->{'localAddr'} has to be a ".
                    "power of 2 number\n");
  }

  printLog($logDebugLevel2, "   Leaving createLocalMem()\n");

  return $lmem;
}

# External uDMA
sub createUDMA {
  my $udma_spec = shift;

  printLog($logDebugLevel2, "   In createUDMA()\n");

  my $udma = new UDMA;
  $udma->{'syncBIntr'} = $udma_spec->{'SyncInterrupt'}->{'BInterrupt'};
  $udma->{'errorBIntr'} = $udma_spec->{'ErrorInterrupt'}->{'BInterrupt'};
  $udma->{'syncProcIntr'} = $udma_spec->{'SyncInterrupt'}->{'ProcInterrupt'};
  $udma->{'errorProcIntr'} = $udma_spec->{'ErrorInterrupt'}->{'ProcInterrupt'};
  $udma->{'lookupPort'} = $udma_spec->{'LookupPort'};

  printLog($logDebugLevel2, "   Leaving createUDMA()\n");
  
  return $udma;
}

# External xtsc dma
sub createSDMA {
  my $proc = shift;
  my $sdma_spec = $proc->{'SDMA'};
  my $sdma = new SDMA;
  $sdma->{'numRequests'} = $sdma_spec->{'NumRequests'};
  $sdma->{'globalAddr'} = $sdma_spec->{'GlobalAddr'};
  $sdma->{'size'} = 256*256;
  if (defined $sdma_spec->{'Shared'}) {
    $sdma->{'shared'} = $sdma_spec->{'Shared'};
  }
  if (defined $proc->{'SDMA'}->{'Width'}) {
    $sdma->{'width'} = computeSize($proc->{'SDMA'}->{'Width'});
  }
  return $sdma;
}

# Internal iDMA
sub createIDMA {
  my $proc = shift;
  my $idma = new IDMA;
  if ($specVersion == 1) {
    $idma->{'shared'} = $proc->{'IDMA'} eq 'Shared' ? 1 : 0;
    if (defined $proc->{'iDMAWidth'}) {
      $idma->{'width'} = computeSize($proc->{'iDMAWidth'});
    }
  } else {
    $idma->{'shared'} = $proc->{'IDMA'}->{'Shared'};
    if (defined $proc->{'IDMA'}->{'Width'}) {
      $idma->{'width'} = computeSize($proc->{'IDMA'}->{'Width'});
    }
  }
  return $idma;
}

# XNNE
sub createXNNE {
  my ($xnneDef, $procToIntfMap) = @_;

  my $xnne = new XNNE;

  defined $xnneDef->{'Name'} or die "Error: XNNE requires a name\n";
  $xnne->{'name'} = $xnneDef->{'Name'};
  $xnne->{'id'} = getNewXNNEId();
  $xnne->{'extIntfId'} = -1;

  $xnneIdMap->{$xnne->{'id'}} = $xnne;
  $xnneNameMap->{$xnne->{'name'}} = $xnne;

  # Needs an array of interfaces
  defined $xnneDef->{'Interfaces'} or
    die "Error: XNNE $xnneDef->{'Name'} requires interfaces\n";

  ref ($xnneDef->{'Interfaces'}) eq 'ARRAY' or
    die "Error: XNNE $xnneDef->{'Name'} interfaces has to be an array\n";

  # Needs an interrupt map
  defined $xnneDef->{'InterruptMap'} or
    die "Error: XNNE $xnneDef->{'Name'} needs an interrupt map\n";

  ref ($xnneDef->{'InterruptMap'}) eq 'ARRAY' or
    die "Error: XNNE $xnneDef->{'Name'} interfaces has to be an array\n";

  # Needs Master/Slave widths
  defined $xnneDef->{'MasterWidths'} or
    die "Error: XNNE $xnneDef->{'Name'} needs MasterWidth\n";

  ref ($xnneDef->{'MasterWidths'}) eq 'ARRAY' or
    die "Error: XNNE $xnneDef->{'Name'} MasterWidth has to be an array\n";

  # Needs Master/Slave widths
  defined $xnneDef->{'SlaveWidth'} or
    die "Error: XNNE $xnneDef->{'Name'} needs SlaveWidth\n";

  foreach my $w (@{$xnneDef->{'MasterWidths'}}) {
    push @{$xnne->{'masterWidths'}}, computeSize($w);
  }

  $xnne->{'slaveWidth'} = computeSize($xnneDef->{'SlaveWidth'});

  # Needs size
  defined $xnneDef->{'Size'} or
    die "Error: XNNE for $xnneDef->{'Name'} needs size of address space\n";
  $xnne->{'size'} = computeSize($xnneDef->{'Size'});

  # Needs GlobalAddr
  defined $xnneDef->{'GlobalAddr'} or
    die "Error: XNNE $xnneDef->{'Name'} needs a global address\n";

  isValidHex($xnneDef->{'GlobalAddr'}) or
    die "Error: GlobalAddr XNNE $xnneDef->{'Name'} has to be in hex\n";
  verifyAddressRange($xnneDef->{'GlobalAddr'}, 
                     $xnneDef->{'Size'});
  $xnne->{'globalAddr'} = $xnneDef->{'GlobalAddr'};

  defined $xnneDef->{'VPUConfig'} or
    die "Error: VPUConfig undefined for XNNE $xnneDef->{'Name'}\n";

  $xnne->{'vpu'} = $xnneDef->{'VPUConfig'};

  # Optional ubuf size
  if (defined $xnneDef->{'UBUFSize'}) {
    $xnne->{'ubufSize'} = computeSize($xnneDef->{'UBUFSize'});
  } else {
    $xnne->{'ubufSize'} = 1048576;
  }

  # Optional number of mblks
  if (defined $xnneDef->{'NumMBLKS'}) {
    ($xnneDef->{'NumMBLKS'} =~ /^\d+$/) or 
      die "Error: NumMBLKS for XNNE $xnneDef->{'Name'} has to be an integer\n";
    $xnne->{'numMBLKS'} = $xnneDef->{'NumMBLKS'};
  } else {
    $xnne->{'numMBLKS'} = 1;
  }

  # Check if config is a valid config
  -f "$xtensaSystem/$xnne->{'vpu'}-params" or 
    die "Error: Unknown config $xnne->{'vpu'}\n";

  # Map from proc to list of binterrupts for verification
  my $procBIntrMap = {};

  # Validate and process the interrupt map definition
  foreach my $imap (@{$xnneDef->{'InterruptMap'}}) {
    ref ($imap) eq 'HASH' or 
      die "InterruptMap for XNNE $xnneDef->{'Name'} has to be a map\n";

    defined $imap->{'Num'} or 
      die "Error: Interrupt num not defined for XNNE $xnneDef->{'Name'}\n";

    ($imap->{'Num'} =~ /^\d+$/) or 
      die "Error: XNNE interrupt for XNNE $xnneDef->{'Name'} ".
          "has to be an integer\n";

    defined $imap->{'Proc'} or 
      die "Error: Target proc not defined for XNNE $xnneDef->{'Name'} ".
          "interrupt $imap->{'Num'}\n";

    defined $procNameMap->{$imap->{'Proc'}} or
      die "Error: Proc $imap->{'Proc'} for XNNE $xnneDef->{'Name'} ".
          "not defined\n";

    ($imap->{'BInterrupt'} =~ /^\d+$/) or 
      die "Error: BInterrupt in XNNE for $xnneDef->{'Name'} ".
          "has to be an integer\n";

    defined $imap->{'BInterrupt'} or 
      die "Error: BInterrupt num not defined for XNNE $xnneDef->{'Name'}\n";

    # Check for unique processor BInterrupt to proc mapping
    !defined $procBIntrMap->{$imap->{'Proc'}} or
    !grep { $imap->{'BInterrupt'} eq $_ } 
          @{$procBIntrMap->{$imap->{'Proc'}}} or 
      die "Duplicate BInterrupt $imap->{'BInterrupt'} for Proc ".
          "$imap->{'Proc'} in XNNE $xnneDef->{'Name'}\n";

    push @{$procBIntrMap->{$imap->{'Proc'}}}, $imap->{'BInterrupt'};

    # Check for unique processor BInterrupt to proc
    # in the global map (across all SubSystemMMIOs and SubSystemIOs)
    !defined $gProcBIntrMap->{$imap->{'Proc'}} or
    !grep { $imap->{'BInterrupt'} eq $_ } 
          @{$gProcBIntrMap->{$imap->{'Proc'}}} or 
      die "Duplicate BInterrupt $imap->{'BInterrupt'} for Proc ".
          "$imap->{'Proc'} in XNNE $xnneDef->{'Name'}\n";

    push @{$gProcBIntrMap->{$imap->{'Proc'}}}, $imap->{'BInterrupt'};

    $xnne->{'intrMap'}{$imap->{'Num'}} = $imap->{'BInterrupt'};
    $xnne->{'intrProcMap'}{$imap->{'Num'}} = $imap->{'Proc'};
  }

  # Add the interfaces

  foreach my $intfmap (@{$xnneDef->{'Interfaces'}}) {
    ref ($intfmap) eq 'HASH' or 
      die "Interface for XNNE $xnneDef->{'Name'} has to be a map\n";

    defined $intfmap->{'Name'} or
      die "Interface for XNNE $xnneDef->{'Name'} needs a name\n";

    ($intfmap->{'Name'} =~ /^[a-zA-Z][a-zA-Z0-9_]+$/) or 
      die "Error: Interface name $intfmap->{'Name'} for ".
          "XNNE $xnneDef->{'Name'} has to be a alpha numerical ".

    defined $intfmap->{'Proc'} or 
      die "Error: Target proc not defined for XNNE $xnneDef->{'Name'} ".
          "interface $intfmap->{'Name'}\n";

    defined $procNameMap->{$intfmap->{'Proc'}} or
      die "Error: Proc $intfmap->{'Proc'} for XNNE $xnneDef->{'Name'} ".
          " not defined\n";

    $xnne->{'interface'}{$intfmap->{'Name'}} = $intfmap->{'Proc'};

    !defined $procToIntfMap->{$intfmap->{'Proc'}} or
    ! grep { $_ eq $intfmap->{'Name'} }
           @{$procToIntfMap->{$intfmap->{'Proc'}}} or
      die "Error: Proc $intfmap->{'Proc'}'s interface has $intfmap->{'Name'} ".
          "already mapped\n";
    push @{$procToIntfMap->{$intfmap->{'Proc'}}}, $intfmap->{'Name'};
  }

  return $xnne;
}

# Verify DMA spec
sub validateDMA {
  my $proc = shift;

  my $sdma = $proc->{'sdma'};
  my $idma = $proc->{'idma'};

  if (!defined $sdma) {
    return;
  }

  !defined $idma or !defined $sdma->{'width'} or 
    die "SDMA width not allowed if IDMA present for proc $proc->{'name'}\n";

  !defined $idma or !defined $sdma->{'shared'} or
    die "SDMA shared not allowed if IDMA present for proc $proc->{'name'}\n";

  if (!defined $sdma->{'shared'}) {
    $sdma->{'shared'} = (defined $idma) ? $idma->{'shared'} : 0;
  }
}

# Local MMIO
sub createMMIO {
  my $mmio_spec = shift;

  printLog($logDebugLevel2, "   In createMMIO()\n");
  
  my $mmio = new MMIO;
  $mmio->{'globalAddr'} = $mmio_spec->{'GlobalAddr'};
  $mmio->{'size'} = computeSize($mmio_spec->{'Size'});

  my $intr_reg = new InterruptReg;
  $intr_reg->{'globalAddr'} = $mmio_spec->{'InterruptRegister'}->{'GlobalAddr'};

  (hex($intr_reg->{'globalAddr'}) >= hex($mmio->{'globalAddr'}) and
    hex($intr_reg->{'globalAddr'}) < (hex($mmio->{'globalAddr'}) + 
                                      $mmio->{'size'})) or
    die "Interrupt register $intr_reg->{'globalAddr'} not within ".
        "MMIO range $mmio->{'globalAddr'}..".
        sprintf("0x%x", (hex($mmio->{'globalAddr'}) + $mmio->{'size'}-1))."\n";

  my $interrupt_map = $mmio_spec->{'InterruptRegister'}->{'InterruptMap'};

  # Temporary map to verify if BInterrupts are unique 
  my $bIntrToOffsetMap = {};

  # Temporary map to verify if ProcInterrupts are unique 
  my $pIntrToOffsetMap = {};

  # Validate and process the interrupt map definition
  foreach my $imap (@$interrupt_map) {
    ref($imap) eq 'HASH' or 
      die "Error: InterruptMap entry for interrupt register at GlobalAddr ".
          "$intr_reg->{'globalAddr'} expected to be a map\n";

    defined $imap->{'BitOffset'} or 
      die "Error: Bit offset not defined for interrupt register at GlobalAddr ".
          "$intr_reg->{'globalAddr'}\n";
    ($imap->{'BitOffset'} =~ /^\d+$/) or 
      die "Error: Bit offset in interrupt register at GlobalAddr ".
          "$intr_reg->{'globalAddr'} has to be an integer\n";

      ($imap->{'BitOffset'} >= 0 and $imap->{'BitOffset'} < 32) or
        die "Bit offset for interrupt register at GlobalAddr ".
            "$intr_reg->{'globalAddr'} has to be between 0..31\n";

    # Check for unique bit offset to interrupt mapping
    !defined $intr_reg->{'bIntrMap'}{$imap->{'BitOffset'}} or 
      die "Duplicate mapping for bitoffset $imap->{'BitOffset'} in ".
          "interrupt register at GlobalAddr $intr_reg->{'globalAddr'}\n";

    defined $imap->{'BInterrupt'} or 
      die "Error: BInterrupt not defined for interrupt register at ".
          "GlobalAddr $intr_reg->{'globalAddr'}\n";
    ($imap->{'BInterrupt'} =~ /^\d+$/) or 
      die "Error: BInterrupt in interrupt register at GlobalAddr ".
          "$intr_reg->{'globalAddr'} has to be an integer\n";

    defined $imap->{'ProcInterrupt'} or 
      die "Error: ProcInterrupt not defined for interrupt register at ".
          "GlobalAddr $intr_reg->{'globalAddr'}\n";
    ($imap->{'ProcInterrupt'} =~ /^\d+$/) or 
      die "Error: ProcInterrupt in interrupt register at ".
          "GlobalAddr $intr_reg->{'globalAddr'} has to be an integer\n";

    $intr_reg->{'intrTypeMap'}{$imap->{'BitOffset'}} = 'Edge';
    if (defined $imap->{'Type'}) {
      $imap->{'Type'} eq 'Edge' or $imap->{'Type'} eq 'Level' or
        die "Error: Type of interrupt has to Edge or Level for ".
            "interrupt register at GlobalAddr $intr_reg->{'globalAddr'}\n";
      $intr_reg->{'intrTypeMap'}{$imap->{'BitOffset'}} = $imap->{'Type'};
    }
      
    # Check for unique BInterrupt to bit offset mapping
    !defined $bIntrToOffsetMap->{$imap->{'BInterrupt'}} or 
      die "Duplicate mapping for BInterrupt $imap->{'BInterrupt'} ".
          "in interrupt register at GlobalAddr $intr_reg->{'globalAddr'}\n";
    $bIntrToOffsetMap->{$imap->{'BInterrupt'}} = $imap->{'BitOffset'};

    # Check for unique processor interrupt to bit offset mapping
    !defined $pIntrToOffsetMap->{$imap->{'ProcInterrupt'}} or 
      die "Duplicate mapping for ProcInterrupt $imap->{'ProcInterrupt'} ".
          "in interrupt register at GlobalAddr $intr_reg->{'globalAddr'}\n";
    $pIntrToOffsetMap->{$imap->{'ProcInterrupt'}} = $imap->{'BitOffset'};
      
    $intr_reg->{'bIntrMap'}{$imap->{'BitOffset'}} = $imap->{'BInterrupt'};
    $intr_reg->{'pIntrMap'}{$imap->{'BitOffset'}} = $imap->{'ProcInterrupt'};

    if (defined $imap->{'xipcNotify'}) {
      $imap->{'xipcNotify'} == 1 or 
        die "Error: xipcNotify flag on interrupt register at ".
            "GlobalAddr $intr_reg->{'globalAddr'} needs to be true\n";
    }
    # xipcNotify should only defined for one of the interrupts
    if (defined $imap->{'xipcNotify'}) {
      if (defined $imap->{'Type'}) {
        $imap->{'Type'} eq 'Edge' or 
          die "xipcNotify interrupt in interrupt register at ".
              "GlobalAddr $intr_reg->{'globalAddr'} has to be edge-triggered\n";
      }
      !defined $intr_reg->{'xipcIntrOffset'} or 
        die "Duplicate xipcNotify flag set on interrupt in register ".
            "at GlobalAddr $intr_reg->{'globalAddr'}\n";
      $intr_reg->{'xipcIntrOffset'} = $imap->{'BitOffset'};
    }
    # xrpNotify should only defined for one of the interrupts
    if (defined $imap->{'xrpNotify'}) {
      !defined $intr_reg->{'xrpIntrOffset'} or 
        die "Duplicate xrpNotify flag set on interrupt in register ".
            "at GlobalAddr $intr_reg->{'globalAddr'}\n";
      $intr_reg->{'xrpIntrOffset'} = $imap->{'BitOffset'};
    }
  }

  $mmio->{'intrReg'} = $intr_reg;

  # Add the GPIO registers
  foreach my $gpio_reg (@{$mmio_spec->{'GPIORegisters'}}) {
    (hex($gpio_reg) >= hex($mmio->{'globalAddr'}) and
      hex($gpio_reg) < (hex($mmio->{'globalAddr'}) + $mmio->{'size'})) or
      die "GPIO register $gpio_reg not within MMIO range ".
          "$mmio->{'globalAddr'}..".
          sprintf("0x%x", (hex($mmio->{'globalAddr'}) + $mmio->{'size'}-1)).
          "\n";
    push @{$mmio->{'gpioRegs'}}, $gpio_reg;
  }

  # Add the controls
  if (defined $mmio_spec->{'Controls'}) {
    ref ($mmio_spec->{'Controls'}) eq 'ARRAY' or
      die "Error. LocalMMIO controls specification in MMIO ".
          "at $mmio->{'globalAddr'} has to be a list\n";
    my $controls = $mmio_spec->{'Controls'};
    foreach my $ctrlSpec (@$controls) {
      ref ($ctrlSpec) eq 'HASH' or
        die "Error. LocalMMIO control specification in MMIO at ".
            "$mmio->{'globalAddr'} has to be a list of maps\n";
      my $ctrl = new ControlReg;
      (hex($ctrlSpec->{'GlobalAddr'}) >= hex($mmio->{'globalAddr'}) and
       hex($ctrlSpec->{'GlobalAddr'}) < (hex($mmio->{'globalAddr'}) + 
                                         $mmio->{'size'})) or
        die "Control $ctrlSpec->{'GlobalAddr'} not within ".
            "MMIO range $mmio->{'globalAddr'}..".
            sprintf("0x%x", (hex($mmio->{'globalAddr'}) + $mmio->{'size'}-1)).
            "\n";

      if (defined $ctrlSpec->{'Width'}) {
        $ctrl->{'width'} = $ctrlSpec->{'Width'};
      } else {
        $ctrl->{'width'} = 1;
      }

      if (defined $ctrlSpec->{'InitValue'}) {
        $ctrl->{'initValue'} = $ctrlSpec->{'InitValue'};
      } else {
        $ctrl->{'initValue'} = 0;
      }

      $ctrl->{'globalAddr'} = $ctrlSpec->{'GlobalAddr'};
      
      if (defined $ctrlSpec->{'ControlMap'}) {
        ref ($ctrlSpec->{'ControlMap'}) eq 'ARRAY' or
          die "Error. ControlMap specification for control register at ".
              "$ctrlSpec->{'GlobalAddr'} has to be a list\n";
        scalar @{$ctrlSpec->{'ControlMap'}} > 0 
          or die "Error: No controls mapped in control register at ".
                 "$ctrlSpec->{'GlobalAddr'}\n";
      } else {
        push @{$mmio->{'controls'}}, $ctrl;
        next;
      }

      my $ctrl_map = $ctrlSpec->{'ControlMap'};

      foreach my $cmap (@$ctrl_map) {
        my $ctrl_sreg = new ControlSubReg;

        ref($cmap) eq 'HASH' or 
          die "Error: ControlMap entry for MMIO register at ".
              "GlobalAddr $ctrl->{'globalAddr'} expected to be a map\n";

        if (defined $cmap->{'BitOffsetStart'}) {
          ($cmap->{'BitOffsetStart'} =~ /^\d+$/) or 
            die "Error: Bit start offset in MMIO register at ".
                "GlobalAddr $ctrl->{'globalAddr'} has to be an integer\n";
        } else {
          $cmap->{'BitOffsetStart'} = 0;
        }

        if (defined $cmap->{'BitOffsetEnd'}) {
          ($cmap->{'BitOffsetEnd'} =~ /^\d+$/) or 
            die "Error: Bit end offset in MMIO register at ".
                "GlobalAddr $ctrl->{'globalAddr'} has to be an integer\n";
        } else {
          $cmap->{'BitOffsetEnd'} = 0;
        }

        $cmap->{'BitOffsetStart'} <= $cmap->{'BitOffsetEnd'} or
          die "Bit offset start of control $cmap->{'Name'} ".
              "should be less than bit offset end of the control register at ".
              "GlobalAddr $ctrl->{'globalAddr'}\n";
      
        $cmap->{'BitOffsetEnd'} < $ctrl->{'width'} or
          die "Bit offset end of control $cmap->{'Name'} should be ".
              "less than width ($ctrl->{'width'}) of the control register ".
              "at GlobalAddr $ctrl->{'globalAddr'}\n";
        $ctrl_sreg->{'name'} = $cmap->{'Name'};
        $ctrl_sreg->{'bitStart'} = $cmap->{'BitOffsetStart'};
        $ctrl_sreg->{'bitEnd'} = $cmap->{'BitOffsetEnd'};
        push @{$ctrl->{'subRegs'}}, $ctrl_sreg;
      }
      push @{$mmio->{'controls'}}, $ctrl;
    }
  }

  printLog($logDebugLevel2, "   Leaving createMMIO()\n");

  return $mmio;
}
  
# Processor spec
sub createProc {
  my ($name, $config, $pipeline, $on_axi, $proc_id, $prid, $is_master, 
      $is_host, $is_xnne_ctrl, $staticVectorSel, $altResetVecAddr) = @_;

  printLog($logDebugLevel2, "   In createProc()\n");

  # Check for duplicate proc names
  !defined $procNameMap->{$name} or 
    die "Error: Duplicate definition of proc name $name\n";

  # Check for duplicate proc ids
  !defined $procIdMap->{$proc_id} or 
    die "Error: Duplicate definition of proc id $proc_id\n";

  # Check for duplicate prid
  !defined $pridMap->{$prid} or 
    die "Error: Duplicate definition of proc prid $prid\n";

  # Check if config is a valid config
  -f "$xtensaSystem/$config-params" or die "Error: Unknown config $config\n";

  my $proc = new Proc;
  $proc->{'name'} = $name;
  $proc->{'config'} = $config;
  $proc->{'pipeline'} = $pipeline;
  $proc->{'axi'} = $on_axi;
  $proc->{'id'} = $proc_id;
  $proc->{'prid'} = $prid;
  $proc->{'staticVectorSel'} = $staticVectorSel;
  $proc->{'altResetVecAddr'} = $altResetVecAddr;
  $proc->{'inBound'} = 0;
  $proc->{'extIntfId'} = -1;
  $proc->{'isXNNECtrl'} = $is_xnne_ctrl;

  # Add to maps
  $procNameMap->{$name} = $proc;
  $procIdMap->{$proc_id} = $proc;
  $pridMap->{$prid} = $proc;

  # Only one proc can be the master
  if ($is_master) {
    !defined $subSysMasterProc or 
    die "$subSysMasterProc->{'name'} proc already defined as the master core\n";
    $subSysMasterProc = $proc;
  }

  # Only one proc can be the host
  if ($is_host) {
    !defined $subSysHostProc or 
    die "$subSysHostProc->{'name'} proc already defined as the host core\n";
    $subSysHostProc = $proc;
  }

  printLog($logDebugLevel2, "   Leaving createProc()\n");

  return $proc;
}

# Print processor spec
sub printProc {
  my $proc = shift;
  printLog($logDebugLevel1, 
           "  - Proc: $proc->{'name'}, Id: $proc->{'id'}, Config: ".
           "$proc->{'config'}, ");
  if (defined $proc->{'dataRamFetchWidth'}) {
    printLog($logDebugLevel1, 
             "DataRamFetchWidth: $proc->{'dataRamFetchWidth'},\n");
  }

  if (defined $proc->{'instRamFetchWidth'}) {
    printLog($logDebugLevel1, 
             " InstRamFetchWidth: $proc->{'instRamFetchWidth'},")
  }
  printLog($logDebugLevel1, 
           " Master/PifWidth: " . ($proc->{'pipeline'} eq 'NX' 
                                     ? $proc->{'masterWidth'} 
                                     : $proc->{'pifWidth'}). "\n");
  if ($proc->{'pipeline'} eq 'NX' and defined $proc->{'slaveWidth'}) {
    printLog($logDebugLevel1, " SlaveWidth: $proc->{'slaveWidth'}\n");
  }
  
  if (defined $proc->{'instRam0'}) {
    printLog($logDebugLevel1, 
             "          InstRam0: {LocalAddr: ".
             "$proc->{'instRam0'}->{'localAddr'}, GlobalAddr: ".
             (defined $proc->{'instRam0'}->{'globalAddr'} 
                ? $proc->{'instRam0'}->{'globalAddr'} 
                : "0").
             ", Size: $proc->{'instRam0'}->{'size'}}\n");
  }

  if (defined $proc->{'instRam1'}) {
    printLog($logDebugLevel1, 
             "          InstRam1: {LocalAddr: ".
             "$proc->{'instRam1'}->{'localAddr'}, GlobalAddr: ".
             (defined $proc->{'instRam1'}->{'globalAddr'} 
                ? $proc->{'instRam1'}->{'globalAddr'} 
                : "0").
             ", Size: $proc->{'instRam1'}->{'size'}}\n");
  }

  if (defined $proc->{'dataRam0'}) {
    printLog($logDebugLevel1, "          DataRam0: {LocalAddr: ".
             "$proc->{'dataRam0'}->{'localAddr'}, GlobalAddr: ".
             (defined $proc->{'dataRam0'}->{'globalAddr'} 
               ? $proc->{'dataRam0'}->{'globalAddr'} 
               : "0").
             ",\n");
    printLog($logDebugLevel1, "                     Size: ".
             "$proc->{'dataRam0'}->{'size'}, ".
             "NumBanks: $proc->{'dataRam0'}->{'numBanks'}}, ".
             "NumSubBanks: $proc->{'dataRam0'}->{'numSubBanks'}}\n");
  }

  if (defined $proc->{'dataRam1'}) {
    printLog($logDebugLevel1, "          DataRam1: {LocalAddr: ".
             "$proc->{'dataRam1'}->{'localAddr'}, GlobalAddr: ".
             (defined $proc->{'dataRam1'}->{'globalAddr'} 
               ? $proc->{'dataRam1'}->{'globalAddr'} 
               : "0").
             ",\n");
    printLog($logDebugLevel1, "                     Size: ".
             "$proc->{'dataRam1'}->{'size'}, ".
             "NumBanks: $proc->{'dataRam1'}->{'numBanks'}}, ".
             "NumSubBanks: $proc->{'dataRam1'}->{'numSubBanks'}}\n");
  }

  if (defined $proc->{'udma'}) {
    printLog($logDebugLevel1, 
             "          uDMA: {syncIntr:  [".
             "BInterrupt:$proc->{'udma'}->{'syncBIntr'}, ".
             "ProcInterrupt:$proc->{'udma'}->{'syncProcIntr'}],\n");
    printLog($logDebugLevel1, "                 errorIntr: [".
             "BInterrupt:$proc->{'udma'}->{'errorBIntr'}, ".
             "ProcInterrupt:$proc->{'udma'}->{'errorProcIntr'}]}\n");
  }

  if (defined $proc->{'mmio'}) {
    printLog($logDebugLevel1, 
             "          MMIO: {GlobalAddr: $proc->{'mmio'}->{'globalAddr'}, ".
             "size: $proc->{'mmio'}->{'size'},\n");
    my $h = $proc->{'mmio'}->{'intrReg'}->{'bIntrMap'};
    printLog($logDebugLevel1, "                 InterruptRegister: ".
             "$proc->{'mmio'}->{'intrReg'}->{'globalAddr'},\n");
    printLog($logDebugLevel1, "                 InterruptMap: [".
             join(", ", map("(off:$_, intr:".$h->{$_}.")", keys %$h))."],\n");
    if (defined $proc->{'mmio'}->{'intrReg'}->{'xipcIntrOffset'}) {
      printLog($logDebugLevel1, 
               "                 XIPCInterruptOffset: ".
               "$proc->{'mmio'}->{'intrReg'}->{'xipcIntrOffset'},\n"); 
    }
    if (defined $proc->{'mmio'}->{'gpioRegs'}) {
      printLog($logDebugLevel1, 
               "                 GPIORegs:  [".
               "@{$proc->{'mmio'}->{'gpioRegs'}}]\n");
    }
    printLog($logDebugLevel1, "                }\n");
  }

  if (defined $proc->{'dcache'}) {
    printLog($logDebugLevel1, 
             "           Dcache Linesize: $proc->{'dcache'}->{'lineSize'}\n");
  }
}
  
# Process the memory size spec suffix
sub computeSize {
  my $w = shift;
  isValidSize($w) or 
    die "computeSize: Unknown size specifier in size '$w', ".
        "expecting <num>(b|Kb|Mb)'\n";
  $w =~ m/(\d+)(b|Kb|Mb|Gb)?/;
  my $cw;
  if (!defined $2) {
    # Assume bytes if no suffix
    $cw = $1;
  } elsif ($2 eq "b") {
    $cw = $1;
  } elsif ($2 eq "Kb") {
    $cw = $1 * 1024;
  } elsif ($2 eq "Mb") {
    $cw = $1 * 1024 * 1024;
  } elsif ($2 eq "Gb") {
    $cw = $1 * 1024 * 1024 * 1024;
  }
  return $cw;
}

# Min. dcache line size is 4 (if no dcache), else is the max. across
# all procs in the subsystem
sub computeMaxDCacheLineSize {
  my $max_dcache_line_size = 4;
  foreach my $proc (values %$procNameMap) {
    if ($proc->{'dcache'}) {
      if ($proc->{'dcache'}->{'lineSize'} > $max_dcache_line_size) {
        $max_dcache_line_size = $proc->{'dcache'}->{'lineSize'};
      }
    }
  }
  return $max_dcache_line_size;
}

# Generate the XTSC defintion for a processor
sub generateXTSCproc {
  my ($body, $proc) = @_;
  push @$body, "// Create proc $proc->{'name'}\n";
  push @$body, "--xtensa_core=\$($proc->{'name'}_CONFIG)\n";
  push @$body, "--xtensa_params=\$($proc->{'name'}_XTENSA_PARAMS)\n";
  push @$body, "--set_core_parm=ProcessorID=$proc->{'prid'}\n";
  push @$body, "--set_core_parm=SimStaticVectorSelect=".
               "\$($proc->{'name'}_SIM_STATIC_VECTOR_SEL)\n";
  if (defined $proc->{'altResetVecAddr'}) {
    push @$body, 
         "--set_core_parm=AltResetVec=\$($proc->{'name'}_ALT_RESET_VEC)\n";
  }
  push @$body, 
       "--set_core_parm=SimClientFile=\$($proc->{'name'}_SIM_CLIENT_FILE)\n";
  push @$body, "--set_core_parm=SimPrefetch=\$($proc->{'name'}_SIM_PREFETCH)\n";
  push @$body, "// Uncomment below for setting exit location for diag tests\n";
  push @$body, "// --set_core_parm=SimExitLocation=0x0\n";
  push @$body, "// Uncomment below for instruction tracing\n";
  push @$body, "// --set_core_parm=SimClients=trace --level=6 ".
               "$proc->{'name'}.insn.trace\n";
  push @$body, "// Uncomment below for loading dat files \n";
  push @$body, "// --set_core_parm=ISSArgs=--dat\n";
  push @$body, "// Uncomment below for dtrace\n";
  push @$body, "// --set_core_parm=ISSArgs=--dtrace=10,--dstart=10\n";
  if ($proc->{'isXNNECtrl'}) {
    push @$body, "--set_core_parm=SimLogDisassembly=true\n";
    push @$body, "#ifdef ".$proc->{'name'}."_CONTROLLER_SIMCALL\n";
    push @$body, "--set_core_parm=SimScriptFile=".
                 "\$($proc->{'name'}_CONTROLLER_SIMCALL)\n";
    push @$body, "#endif\n";
    push @$body, "#ifdef ".$proc->{'name'}."_DEBUG_CTRL\n";
    push @$body, "--core_debug=sync\n";
    push @$body, "#endif\n";
  }
  push @$body, "--core_args=\$($proc->{'name'}_BINARY_ARGS)\n";
  push @$body, "--core_program=\$($proc->{'name'}_BINARY)\n";
  push @$body, "--create_core=$proc->{'name'}\n";
  push @$body, "\n";
}

# Generate the XTSC master
sub generateTestBenchMaster {
  my ($body) = @_;
  push @$body, "// Create TestBenchMaster xtsc_master\n";
  push @$body, "--set_master_parm=script_file=".
               "\$(XTSC_SCRIPT_FILE_PATH)/TestBenchMaster.vec\n";
  push @$body, "--create_master=TestBenchMaster\n";
  push @$body, "\n";
  push @$body, "// Create router for the xtsc_master\n";
  if ($subSysMasterProc->{'axi'}) {
    push @$body, "--set_router_parm=num_slaves=2\n";
    push @$body, "--set_router_parm=route_by_type=read;write\n";
  } else {
    push @$body, "--set_router_parm=routing_table=".
                 "\$(XTSC_SCRIPT_FILE_PATH)/TestBenchMaster_rte.tab\n";
    push @$body, "--set_router_parm=default_port_num=0\n";
    push @$body, "--set_router_parm=num_slaves=1\n";
  }
  push @$body, "--create_router=TestBenchMaster_rte\n";
  push @$body, "\n";
  push @$body, "// Connect the TestBenchMaster to the router\n";
  push @$body, 
       "--connect=TestBenchMaster,master_port,slave_port,TestBenchMaster_rte\n";
  push @$body, "\n";
}

# Generate connection from the bus to the SubSystemMMIO arbiter
sub generateSubSystemMMIOInterconnect {
  my ($xtsc_run_gen_dir, $body, $smmio, $idx) = @_;

#  if (defined $SubSystemMMIO->{'apb'}) {
#    push @$body, "// Create ExternalAPBMaster xtsc_master\n";
#    push @$body, "--set_master_parm=script_file=".
#                 "\$(XTSC_SCRIPT_FILE_PATH)/ExternalAPBMaster.vec\n";
#    push @$body, "--create_master=ExternalAPBMaster\n";
#    push @$body, "\n";
#    push @$body, "// Connect the ExternalAPBMaster to the APB arbiter\n";
#    push @$body, "--connect=ExternalAPBMaster,master_port,".
#                 "slave_port[$port],SubSystemMMIO_arb\n";
#    push @$body, "\n";
#
#    my $xtsc_external_apb_master_vec = 
#      "$xtsc_run_gen_dir/ExternalAPBMaster.vec";
#    open(xtsc_external_apb_master_vec, ">$xtsc_external_apb_master_vec") or 
#      sysBuildError("Could not open $xtsc_external_apb_master_vec\n");
#    close xtsc_external_apb_master_vec;
#  }

  # Add AXI2APB transactors for bus to connect to the APB SubSystemMMIO
  if (defined $smmio->{'apb'}) {
    if ($subSysMasterProc->{'axi'}) {
      push @$body, "// Connect the bus to the SubSystemMMIO\n";
      push @$body, "--set_xttlm2tlm2_parm=num_ports=1\n";
      push @$body, "--set_xttlm2tlm2_parm=use_nb_transport=true\n";
      push @$body, "--set_xttlm2tlm2_parm=byte_width=4\n";
      push @$body, "--create_xttlm2tlm2=$smmio->{'name'}_Bus_AXI2APB_X2T\n";

      push @$body, "\n";
      push @$body, "--set_tlm22xttlm_parm=num_ports=1\n";
      push @$body, "--set_tlm22xttlm_parm=apb=true\n";
      push @$body, "--set_tlm22xttlm_parm=byte_width=4\n";
      push @$body, "--create_tlm22xttlm=$smmio->{'name'}_Bus_AXI2APB_T2X\n";

      push @$body, "\n";
      push @$body, "// Create arbiter for combining bus read/write\n";
      push @$body, "--set_arbiter_parm=num_masters=2\n";
      push @$body, "--set_arbiter_parm=immediate_timing=true\n";
      push @$body, "--create_arbiter=$smmio->{'name'}_BusRdWrArb\n";
      push @$body, "\n";
      push @$body, "--connect=$smmio->{'name'}_BusRdWrArb,master_port,".
                   "slave_port,$smmio->{'name'}_Bus_AXI2APB_X2T\n";
      push @$body, "--connect=$smmio->{'name'}_Bus_AXI2APB_X2T,".
                   "initiator_socket,target_socket,".
                   "$smmio->{'name'}_Bus_AXI2APB_T2X\n";
    }
  }

  my $port = 0;

  # Add Bus to APB interface
  if (defined $smmio->{'apb'}) {
    push @$body, "// Connect the bus to SubSystemMMIO arb\n";
    push @$body, "--connect=$smmio->{'name'}_Bus_AXI2APB_T2X,".
                 "master_port,slave_port[$port],$smmio->{'name'}_arb\n";
    push @$body, "\n";
  }

  $port++;

  # Add SystemDMA 
  if (defined $SystemDMA->{'baseAddr'}) {
    push @$body, "// Connect the SystemDMA to SubSystemMMIO arb\n";
    if (defined $smmio->{'apb'}) {
      push @$body, "--connect=SystemDMA_$smmio->{'name'}_PIF2APB_T2X,".
                   "master_port,slave_port[$port],$smmio->{'name'}_arb\n";
    } elsif ($subSysMasterProc->{'axi'}) {
      # Account for the AXI rd/wr ports
      push @$body, "--connect=SystemDMA_$smmio->{'name'}_PIF2AXI_xtor,".
                   "aximaster_rd,slave_port[".($port+1)."],".
                   "$smmio->{'name'}_arb\n";
      push @$body, "--connect=SystemDMA_$smmio->{'name'}_PIF2AXI_xtor,".
                   "aximaster_wr,slave_port[".($port+2)."],".
                   "$smmio->{'name'}_arb\n";
    } else {
      # First port of SystemDMA_out_rte is to the bus.
      push @$body, "--connect=SystemDMAOutRte,master_port[".($idx+1)."],".
                   "slave_port[$port],$smmio->{'name'}_arb\n";
    }
    $port++;
    push @$body, "\n";
  }
}

# Generate the XTSC definition for a XNNE
sub generateXTSCXNNE {
  my ($body, $xnne, $xtsc_run_gen_dir) = @_;
  push @$body, "// Create XNNE $xnne->{'name'}\n";
  push @$body, "#ifdef XNNE_HW_VERSION\n";
  push @$body, "--set_xtsc_xnne_parm=hw_version=\$(XNNE_HW_VERSION)\n";
  push @$body, "#endif\n";
  push @$body, "#ifdef LOG_LEVEL_FIELDS\n";
  push @$body, "--set_xtsc_xnne_parm=log_level_fields=\$(LOG_LEVEL_FIELDS)\n";
  push @$body, "#endif\n";
  push @$body, "#ifdef LOG_LEVEL_TENSORS\n";
  push @$body, "--set_xtsc_xnne_parm=log_level_tensors=\$(LOG_LEVEL_TENSORS)\n";
  push @$body, "#endif\n";
  push @$body, "#ifdef LOG_LEVEL_TRACE\n";
  push @$body, "--set_xtsc_xnne_parm=log_level_trace=\$(LOG_LEVEL_TRACE)\n";
  push @$body, "#endif\n";
  push @$body, "#ifdef TRACE_OFMAP\n";
  push @$body, "--set_xtsc_xnne_parm=trace_ofmap=\$(TRACE_OFMAP)\n";
  push @$body, "#endif\n";
  push @$body, "--set_xtsc_xnne_parm=base_address=\$(".
               uc($xnne->{'name'})."_BASE_ADDRESS)\n";
  push @$body, "--set_xtsc_xnne_parm=axim_byte_width=".
               "@{$xnne->{'masterWidths'}}[0]\n";
  push @$body, "--set_xtsc_xnne_parm=load_file=\$(".uc($xnne->{'name'}).
               "_LOAD_FILE)\n";
  push @$body, "--set_xtsc_xnne_parm=turbo=0\n";
  push @$body, "--set_xtsc_xnne_parm=num_sblks=\$(".uc($xnne->{'name'}).
               "_NUM_SBLKS)\n";
  push @$body, "--set_xtsc_xnne_parm=num_mblks=\$(".uc($xnne->{'name'}).
               "_NUM_MBLKS)\n";
  push @$body, "--set_xtsc_xnne_parm=ibuf_byte_size=\$(".
               uc($xnne->{'name'})."_IBUF_SIZE)\n";
  push @$body, "--set_xtsc_xnne_parm=obuf_byte_size=\$(".
               uc($xnne->{'name'})."_OBUF_SIZE)\n";
  push @$body, "--set_xtsc_xnne_parm=cbuf_byte_size=\$(".
               uc($xnne->{'name'})."_CBUF_SIZE)\n";
  push @$body, "--set_xtsc_xnne_parm=ubuf_byte_size=\$(".uc($xnne->{'name'}).
               "_UBUF_SIZE)\n";
  push @$body, "--set_xtsc_xnne_parm=vpu_config=\$(".uc($xnne->{'name'}).
               "_VPU_CONFIG)\n";
  push @$body, "--set_xtsc_xnne_parm=vpu_core_parms= \\\n";
  push @$body, "  SimScriptFile=\$(".uc($xnne->{'name'}).
               "_FIRMWARE_SIMCALL)+ \\\n";
  push @$body, "  SimDebug=\$(".uc($xnne->{'name'})."_DEBUG_VPU)+ \\\n";
  push @$body, "  SimDebugSynchronized=true+ \\\n";
  push @$body, "  SimLogDisassembly=false+ \\\n";
  push @$body, "  SimRunStall=1+ \\\n";
  push @$body, "  SimTurbo=0+ \\\n";
  push @$body, "  SimTurboMaxRelaxedCycles=0+ \\\n";
  push @$body, "  SimClients=isa_profile vpu.isaProfile\n";
  push @$body, "--set_xtsc_xnne_parm=sblk_compare=\$(".uc($xnne->{'name'}).
               "_SBLK_COMPARE)\n";

  push @$body, "#ifdef PROFILE_AXI\n";
  push @$body, "--set_xtsc_xnne_parm=profile_axi_traffic=\$(PROFILE_AXI)\n";
  push @$body, "#endif\n";
  push @$body, "--create_xtsc_xnne=$xnne->{'name'}\n";
  push @$body, "\n";

  my $hp = $xnne->{'intrProcMap'};
  my $h = $xnne->{'intrMap'};

  my $xnne_int_dist_file = 
     "$xtsc_run_gen_dir/$xnne->{'name'}_Interrupt_Distributor.def";
  open(xnne_int_dist_file, ">$xnne_int_dist_file") or 
    sysBuildError("Could not open $xnne_int_dist_file\n");
  print xnne_int_dist_file 
      "/* input <Name> <BitWidth>  */\n";
  print xnne_int_dist_file "\n";
  print xnne_int_dist_file "input XNNEInterrupts ".scalar (keys %$h)."\n";
  print xnne_int_dist_file "\n";
  print xnne_int_dist_file 
        "/* output <Name> <BitWidth>  */\n\n";
  print xnne_int_dist_file join("\n", map("output BInterrupt$_ 1", 
                                (sort {$a<=>$b} keys %$h)))."\n";
  print xnne_int_dist_file "\n";
  print xnne_int_dist_file join("\n", map("assign BInterrupt$_ = ".
                                "XNNEInterrupts[$_]", 
                                (sort {$a<=>$b} keys %$h)));
  close xnne_int_dist_file;

  # Interrupts
  push @$body, "// Connect XNNE's interrupts\n";
  push @$body, "--set_logic_parm=definition_file=\$(XTSC_SCRIPT_FILE_PATH)/".
               "$xnne->{'name'}_Interrupt_Distributor.def\n";
  push @$body, "--create_logic=$xnne->{'name'}_Interrupt_Distributor\n";
  push @$body, "\n";
  push @$body, "--connect=$xnne->{'name'},XnneXtensa_Interrupts,".
               "XNNEInterrupts,$xnne->{'name'}_Interrupt_Distributor\n";
  push @$body, "\n";
  foreach my $intr (sort {$a<=>$b} keys %$hp) {
    my $bInterrupt = $h->{$intr};
    my $proc = $procNameMap->{$hp->{$intr}};
    my $bIntrPrefix = "";
    if ($bInterrupt < 10) {
      $bIntrPrefix = ($proc->{'pipeline'} eq 'LX') ? "0" : "00";
    } elsif ($bInterrupt < 100) {
      if ($proc->{'pipeline'} eq 'NX') {
        $bIntrPrefix = "0";
      }
    }
    push @$body, "--connect=$xnne->{'name'}_Interrupt_Distributor,".
                 "BInterrupt$intr,BInterrupt$bIntrPrefix$bInterrupt,".
                 "$proc->{'name'}\n";
  }

  # Interfaces
  push @$body, "\n";
  push @$body, "// Connect XNNE's interfaces\n";
  my $intfMap = $xnne->{'interface'};
  foreach my $intf (keys %$intfMap) {
    push @$body, "--connect=$intfMap->{$intf},$intf,$intf,$xnne->{'name'}\n";
  }
  push @$body, "\n";
}

# Generate the XTSC defintion for a udma
sub generateXTSCudma {
  my ($body, $proc) = @_;
  push @$body, "// Create proc $proc->{'name'}'s uDMA\n";
  push @$body, 
       "--set_xtsc_udma_parm=ram_byte_width=$proc->{'dataRamFetchWidth'}\n";
  push @$body, "--set_xtsc_udma_parm=pif_byte_width=$proc->{'pifWidth'}\n";
  push @$body, "--set_xtsc_udma_parm=ram_byte_sizes=".
               "$proc->{'dataRam0'}->{'size'}, $proc->{'dataRam1'}->{'size'}\n";
  push @$body, "--set_xtsc_udma_parm=ram_start_addresses=".
               "$proc->{'dataRam0'}->{'localAddr'}, ".
               "$proc->{'dataRam1'}->{'localAddr'}\n";
  push @$body, "--create_xtsc_udma=$proc->{'name'}_uDMA\n";
  push @$body, "\n";
}

# Generate the XTSC definition for a sdma
sub generateXTSCsdma {
  my ($body, $proc) = @_;
  push @$body, "// Create sDMA\n";
  push @$body, "--set_dma_parm=byte_width=$subSysBusWidth\n";
  push @$body, "--set_dma_parm=overlap_descriptors=true\n";
  push @$body, "--set_dma_parm=clear_notify_value=true\n";
  push @$body, "--set_dma_parm=max_reads=".
               "\$($proc->{'name'}_SDMA_MAX_OUTSTANDING_SYS_DMA_REQ)\n";
  push @$body, "--set_dma_parm=max_writes=".
               "\$($proc->{'name'}_SDMA_MAX_OUTSTANDING_SYS_DMA_REQ)\n";
  push @$body, "--set_dma_parm=reg_base_address=" . 
               sprintf("0x%x", hex($proc->{'sdma'}->{'globalAddr'})) . "\n";
  push @$body, "--set_dma_parm=start_at_index_1=false\n";
  push @$body, "--create_dma=$proc->{'name'}_sDMA\n";
  push @$body, "\n";

  if (!$subSysMasterProc->{'axi'}) {
    return;
  }

  # if to axi bus, create the transactors, 

  # Create AXI <-> PIF transactors
  push @$body, "// Instantiate the AXI <-> PIF transactors\n";
  push @$body, "--set_xtsc_axi2pif_transactor_parm=axi_byte_width=".
               "$proc->{'dmaWidth'}\n";
  push @$body, "--create_xtsc_axi2pif_transactor=".
               "$proc->{'name'}_sDMA_AXI2PIF_xtor\n";
  push @$body, "--connect=$proc->{'name'}_sDMA_AXI2PIF_xtor,master_port,".
               "slave_port,$proc->{'name'}_sDMA\n";
  push @$body, "\n";

  push @$body, "--set_xtsc_pif2axi_transactor_parm=".
               "pif_byte_width=$proc->{'dmaWidth'}\n";
  push @$body, "--set_xtsc_pif2axi_transactor_parm=".
               "axi_byte_width=$proc->{'dmaWidth'}\n";
  push @$body, "--create_xtsc_pif2axi_transactor=".
               "$proc->{'name'}_sDMA_PIF2AXI_xtor\n";
  push @$body, "\n";

  push @$body, "// Connect the sDMA to the transactors and rd/wr ".
               "arbiter/router\n";
  push @$body, "--connect=$proc->{'name'}_sDMA,master_port,slave_port,".
               "$proc->{'name'}_sDMA_PIF2AXI_xtor\n";
  push @$body, "\n";
}

# Instantiate InstRAMs. Only for LX.
sub generateXTSCInstRam {
  my ($body, $proc, $iram_id) = @_;
  if ($proc->{'pipeline'} eq 'NX') {
    return;
  }
  #if (!defined $proc->{'sharedLmemCid'}) {
  #  return;
  #}
  my $iram = ($iram_id == $IRAM0 ? $proc->{'instRam0'} : $proc->{'instRam1'});
  push @$body, "// Create $proc->{'name'} INSTRAM$iram_id\n";
  push @$body, "--memory_port=iram$iram_id\n";
  push @$body, "--set_memory_parm=num_ports=1\n";
  push @$body, "--set_memory_parm=byte_width=$proc->{'instRamFetchWidth'}\n";
  push @$body, "--set_memory_parm=immediate_timing=true\n";
  push @$body, "--set_memory_parm=start_byte_address=$iram->{'localAddr'}\n";
  push @$body, "--set_memory_parm=memory_byte_size=$iram->{'size'}\n";
  push @$body, "--create_memory=$proc->{'name'}_INSTRAM$iram_id\n";
  push @$body, "\n";
}

# Instantiate DataRAMs. Only for LX.
# Create a memory module per dataram. The number of ports is equal to the number
# of banks
sub generateXTSCDataRam {
  my ($body, $proc, $dram_id) = @_;
  if ($proc->{'pipeline'} eq 'NX') {
    return;
  }
  #if (!defined $proc->{'sharedLmemCid'}) {
  #  return;
  #}
  my $dram = ($dram_id == $DRAM0 ? $proc->{'dataRam0'} : $proc->{'dataRam1'});
  push @$body, "// Create $proc->{'name'} DATARAM$dram_id\n";
  push @$body, "--memory_port=dram$dram_id\n";
  push @$body, "--set_memory_parm=num_ports=".
               ($dram->{'numBanks'}*$dram->{'numSubBanks'})."\n";
  push @$body, "--set_memory_parm=byte_width=$proc->{'dataRamFetchWidth'}\n";
  push @$body, "--set_memory_parm=immediate_timing=true\n";
  push @$body, "--set_memory_parm=start_byte_address=$dram->{'localAddr'}\n";
  push @$body, "--set_memory_parm=memory_byte_size=$dram->{'size'}\n";
  push @$body, "--create_memory=$proc->{'name'}_DATARAM${dram_id}\n";
  push @$body, "\n";
}

# Generate xtsc mmio for per-processor local mmio
sub generateXTSClocalMMIO {
  my ($body, $proc) = @_;
  push @$body, "// Create $proc->{'name'}'s MMIO\n";
  push @$body, "--set_mmio_parm=definition_file=".
               "\$(XTSC_SCRIPT_FILE_PATH)/$proc->{'name'}_mmio.def\n";
  if ($proc->{'isBigEndian'}) {
    push @$body, "--set_mmio_parm=swizzle_bytes=true\n";
  }
  push @$body, "--create_mmio=$proc->{'name'}_mmio\n";
  push @$body, "\n";

  # Connect local MMIO to proc
  push @$body, "// Connect $proc->{'name'}'s MMIO to the proc\n";
  my $mmio = $proc->{'mmio'};
  my $h = $proc->{'mmio'}->{'intrReg'}->{'bIntrMap'};
  foreach my $bitOffset (sort {$a<=>$b} keys %$h) {
    my $bInterrupt = $h->{$bitOffset};
    my $bIntrPrefix = "";
    if ($bInterrupt < 10) {
      $bIntrPrefix = ($proc->{'pipeline'} eq 'LX') ? "0" : "00";
    } elsif ($bInterrupt < 100) {
      if ($proc->{'pipeline'} eq 'NX') {
        $bIntrPrefix = "0";
      }
    }
    push @$body, "--connect=$proc->{'name'}_mmio,".
                 "$proc->{'name'}_intr_reg_$bitOffset,BInterrupt".
                 $bIntrPrefix.$bInterrupt.",$proc->{'name'}\n";
  }

  # Hook the controls to the core
  my $controls = $proc->{'mmio'}->{'controls'};
  foreach my $ctrl (@$controls) {
    foreach my $reg (@{$ctrl->{'subRegs'}}) {
      push @$body, "--connect=$proc->{'name'}_mmio,".
                   "$proc->{'name'}_$reg->{'name'},$reg->{'name'},".
                   "$proc->{'name'}\n";
    }
  }
  push @$body, "\n";
}

# Arbitrate for local mmio (AXI rd/wr)
sub generateXTSClocalMMIOArbiter {
  my ($body, $proc) = @_;
  push @$body, 
       "// Create inbound arbiter for read/writes to $proc->{'name'}_mmio\n";
  push @$body, "--set_arbiter_parm=num_masters=2\n"; 
  push @$body, "--set_arbiter_parm=route_id_lsb=$AXI_MMIO_ARB_ROUTE_ID_LSB\n"; 
  push @$body, "--set_arbiter_parm=immediate_timing=true\n";
  push @$body, "--set_arbiter_parm=response_delay=0\n";
  push @$body, "--create_arbiter=$proc->{'name'}_mmio_arb\n";
  push @$body, "\n";

  push @$body, "// Connect inbound arbiter to $proc->{'name'}_mmio\n";
  push @$body, "--connect=$proc->{'name'}_mmio_arb,master_port,".
               "slave_port,$proc->{'name'}_mmio\n";
  push @$body, "\n";
}

# Generate inbound router to the processor. The router routes requests
# from the inbound arbiter to either the MMIO or the inbound PIF 
# or the inbound data/instruction read/write slave ports AXI.
sub generateXTSCInboundRouter {
  my ($body, $proc, $axi_type) = @_;
  my $nx = $proc->{'pipeline'} eq 'NX';
  my $lx = $proc->{'pipeline'} eq 'LX';
  my $axi_type_str = ($axi_type ne "" ? "${axi_type}_" : $axi_type);
  push @$body, 
       "// Create inbound PIF/AXI/MMIO/sDMA router for $proc->{'name'}\n";
  push @$body, "--set_router_parm=routing_table=\$(XTSC_SCRIPT_FILE_PATH)/".
               "$proc->{'name'}_inbound_${axi_type_str}rte.tab\n";
  push @$body, "--set_router_parm=default_port_num=666\n";

  # Can have just an MMIO with no inbound PIF, or just an inbound PIF with no
  # MMIO, or both
  my $num_slaves = 0;
  if (defined $proc->{'mmio'}) {
    $num_slaves++;
  }

  if ($proc->{'inBound'}) {
    if ($lx or $proc->{'slaveDataInstMerged'} or 
        defined $proc->{'slaveDataWidth'}) {
      $num_slaves++;
    }
    if ($nx && defined $proc->{'instRam0'} && 
        defined $proc->{'slaveInstWidth'}) {
      # For instslave read/write
      $num_slaves++;
    }
  }

  if (defined $proc->{'sdma'}) {
    $num_slaves++;
  }

  push @$body, "--set_router_parm=num_slaves=$num_slaves\n";
  if ($num_slaves == 1) {
    push @$body, "--set_router_parm=immediate_timing=true\n";
  }
  if (defined $proc->{'slaveInstWidth'} and 
      defined $proc->{'slaveDataWidth'} and 
      $proc->{'slaveInstWidth'} != $proc->{'slaveDataWidth'}) {
    push @$body, "--set_router_parm=master_byte_width=$proc->{'slaveWidth'}\n";
    push @$body, "--set_router_parm=slave_byte_widths=".
                 "$proc->{'slaveInstWidth'},$proc->{'slaveDataWidth'}".
                 (defined $proc->{'mmio'} ? (",".$proc->{'slaveWidth'}) 
                                          : "").
                 (defined $proc->{'sdma'} ? (",".$proc->{'slaveWidth'}) 
                                          : "").
                 "\n";
  }
  push @$body, "--create_router=$proc->{'name'}_inbound_${axi_type_str}rte\n";
  push @$body, "\n";

  push @$body, 
       "// Connect the inbound router to the inbound PIF/AXI (if defined) or\n";
  push @$body, "// local MMIO or sDMA (if defined)\n";
  # Connect first to inbound (if defined) and then to 
  # local MMIO (if defined)
  # and then to sDMA (if defined)
  my $port = 0;
  if ($proc->{'inBound'}) {
    if ($proc->{'axi'} && $lx) {
      push @$body, "--connect=$proc->{'name'}_inbound_${axi_type_str}rte,".
                   "master_port[$port],axislave_${axi_type},".
                   "$proc->{'name'}_inbound_AXI2PIF_xtor\n";
      $port++;
    } else {
      my $inbound_port;
      if ($proc->{'axi'} && defined $proc->{'slaveInstWidth'}) {
        $inbound_port = "instslave_" . $axi_type;
        push @$body, "--connect=$proc->{'name'}_inbound_${axi_type_str}rte,".
                     "master_port[$port],$inbound_port,$proc->{'name'}\n";
        $port++;
      }
      if ($lx or $proc->{'slaveDataInstMerged'} or 
          defined $proc->{'slaveDataWidth'}) {
        my $data_port_name = $proc->{'slaveDataInstMerged'} ? "axislave" 
                                                            : "dataslave";
        $inbound_port = ($proc->{'axi'} ? ($data_port_name."_" . $axi_type) 
                                        : "inbound_pif");
        push @$body, "--connect=$proc->{'name'}_inbound_${axi_type_str}rte,".
                     "master_port[$port],$inbound_port,$proc->{'name'}\n";
        $port++;
      }
    }
  }

  if (defined $proc->{'mmio'}) {
    if ($proc->{'axi'}) {
      # Connect the inbound router to the mmio 
      my $arb_port = $axi_type eq "rd" ? 0 : 1;
      push @$body, "--connect=$proc->{'name'}_inbound_${axi_type_str}rte,".
                   "master_port[$port],slave_port[$arb_port],".
                   "$proc->{'name'}_mmio_arb\n";
    } else {
      push @$body, "--connect=$proc->{'name'}_inbound_${axi_type_str}rte,".
                   "master_port[$port],slave_port,$proc->{'name'}_mmio\n";
    }
    $port++;
  }

  if (defined $proc->{'sdma'}) {
    if ($proc->{'axi'}) {
      # Connect the inbound router to the sdma 
      push @$body, "--connect=$proc->{'name'}_inbound_${axi_type_str}rte,".
                   "master_port[$port],axislave_$axi_type,".
                   "$proc->{'name'}_sDMA_AXI2PIF_xtor\n";
    } else {
      push @$body, "--connect=$proc->{'name'}_inbound_${axi_type_str}rte,".
                   "master_port[$port],slave_port,$proc->{'name'}_sDMA\n";
    }
    $port++;
  }

  push @$body, "\n";
}

# Create inbound arbiter to the processor. The arbiter could be mastered
# by the interface router bus and fast paths from other processors.
sub generateXTSCInboundArbiter {
  my ($body, $proc, $route_id_lsb, $axi_type) = @_;
  my $axi_type_str = ($axi_type ne "" ? "${axi_type}_" : $axi_type);

  push @$body, "// Create inbound arbiter for $proc->{'name'}\n";

  # Add all srcs procs that target this proc
  my $num_arb_masters = @{$subSysInterconnectFrom->{$proc->{'id'}}};

  # Add all src procs with dma that target this proc
  my @procsWithiDMA = ();  

  foreach my $src_id (@{$subSysInterconnectFrom->{$proc->{'id'}}}) {
    if ($src_id == $COMMON_BUS_ID) {
      next;
    }
    if (isProcId($src_id) and defined $procIdMap->{$src_id}->{'idma'} and
        !$procIdMap->{$src_id}->{'idma'}->{'shared'}) {
      $num_arb_masters++;
      push @procsWithiDMA, $src_id;
    }
  }

  # Restrict to 32 masters since we are reserving only 5-bits
  $num_arb_masters <= 32 or
    die "Number of masters $num_arb_masters for $proc->{'name'}'s inbound ".
        "arbiter has to be <= 32\n";

  push @$body, "--set_arbiter_parm=num_masters=$num_arb_masters\n";
  push @$body, "--set_arbiter_parm=route_id_lsb=$route_id_lsb\n";

  # The common bus, if connected, will always be the first port. The rest
  # follows sorted order of processor ids. The bitwidth of the common bus
  # port is the bus width, while for the processors, it is their respective
  # PIF/AXI width. If the incoming widths do not match this proc's PIF/AXI width
  # then this arbiter acts as a PIF width converter.
  my $nx = $proc->{'pipeline'} eq 'NX';
  my ($head, @rest) = sort {$a<=>$b} 
                      @{$subSysInterconnectFrom->{$proc->{'id'}}};

  my $rest_bw_str =
    @rest ? ",".join(",", map(isProcId($_)
                  ? ($procIdMap->{$_}->{'pipeline'} eq 'NX' 
                    ? $procIdMap->{$_}->{'masterWidth'} 
                    : $procIdMap->{$_}->{'pifWidth'})
                  : @{$xnneIdMap->{$_}->{'masterWidths'}}
                    [$xnneIdMap->{$_}->{'masterCompMap'}->{$proc->{'id'}}[0]],
                    @rest))
          : "";

  # Add the procs with idma to end of the list. The IDMA ports follows
  # after all the connections originating from the pif/axi master port

  my @rest_idma = sort {$a<=>$b} @procsWithiDMA;
  $rest_bw_str .= @rest_idma ? ",".join(",", map($procIdMap->{$_}->{'dmaWidth'},
                                                 @rest_idma)) 
                             : "";

  my @mws = isXNNEId($head) 
              ? @{$xnneIdMap->{$head}->{'masterCompMap'}->{$proc->{'id'}}} 
              : ();

  my $head_width = ($head == $COMMON_BUS_ID 
                      ? $subSysBusWidth 
                      : (isProcId($head) 
                           ? ($procIdMap->{$head}->{'pipeline'} eq 'NX'
                                ? $procIdMap->{$head}->{'masterWidth'}
                                : $procIdMap->{$head}->{'pifWidth'})
                           : @{$xnneIdMap->{$head}->{'masterWidths'}}[$mws[0]])
                   );

  my $slave_width = ($nx ? $proc->{'slaveWidth'} : $proc->{'pifWidth'});
                            
  # If there is just a single master and is not width-converting,
  # relax timing
  if ($num_arb_masters == 1 and ($head_width == $slave_width)) {
    push @$body, "--set_arbiter_parm=immediate_timing=true\n";
  } else {
    push @$body, "--set_arbiter_parm=master_byte_widths=".
                 ($head_width.$rest_bw_str)."\n";
    push @$body, "--set_arbiter_parm=slave_byte_width=$slave_width\n";
  }

  push @$body, "--set_arbiter_parm=arbitration_phase=$INBOUND_ARB_PHASE\n";
  push @$body, "--set_arbiter_parm=one_at_a_time=false\n";
  push @$body, "--create_arbiter=$proc->{'name'}_inbound_${axi_type_str}arb\n";
  push @$body, "\n";
  push @$body, "// Connect the inbound arbiter to the inbound router\n";
  push @$body, "--connect=$proc->{'name'}_inbound_${axi_type_str}arb,",
               "master_port,slave_port,",
               "$proc->{'name'}_inbound_${axi_type_str}rte\n";
  push @$body, "\n";
}

# Generate arbiter for idma and sdma
sub generateXTSCDMAArbiter {
  my ($body, $proc, $route_id_lsb, $axi_type) = @_;
  my $axi_type_str = ($axi_type ne "" ? "${axi_type}_" : $axi_type);

  if ($proc->{'sdma'}->{'shared'}) {
    return;
  }

  push @$body, "// Create arbiter for iDMA and sDMA\n";
  push @$body, "--set_arbiter_parm=num_masters=2\n";
  push @$body, "--set_arbiter_parm=route_id_lsb=$route_id_lsb\n";
  push @$body, "--set_arbiter_parm=arbitration_phase=$SDMA_IDMA_ARB_PHASE\n";
  push @$body, "--create_arbiter=$proc->{'name'}_dma_${axi_type_str}arb\n";
  push @$body, "\n";

  push @$body, "// Connect the sDMA and core idma to the dma arbiter\n";
  my $dma = ($proc->{'pipeline'} eq 'NX' ? "idma_${axi_type}" : "idma0");
  if ($proc->{'axi'}) {
    my $port = $axi_type eq "rd" ? "aximaster_rd" : "aximaster_wr";
    push @$body, "--connect=$proc->{'name'}_idma_PIF2AXI_xtor,$port,".
                 "slave_port[0],$proc->{'name'}_dma_${axi_type_str}arb\n";
  } else {
    push @$body, "--connect=$proc->{'name'},$dma,slave_port[0],".
                 "$proc->{'name'}_dma_${axi_type_str}arb\n";
  }
  if ($proc->{'axi'}) {
    my $port = $axi_type eq "rd" ? "aximaster_rd" : "aximaster_wr";
    push @$body, "--connect=$proc->{'name'}_sDMA_PIF2AXI_xtor,".
                 "$port,slave_port[1],".
                 "$proc->{'name'}_dma_${axi_type_str}arb\n";
  } else {
    push @$body, "--connect=$proc->{'name'}_sDMA,".
                 "master_port,slave_port[1],".
                 "$proc->{'name'}_dma_${axi_type_str}arb\n";
  }
  push @$body, "\n";
}

# The oubound arbiter arbitrates between the proc's outbound pif/axi master and 
# the udma, sdma, or shared idma
sub generateXTSCOutboundArbiter {
  my ($body, $proc, $route_id_lsb, $axi_type) = @_;
  my $axi_type_str = ($axi_type ne "" ? "${axi_type}_" : $axi_type);

  push @$body, "// Create outbound $axi_type arbiter for $proc->{'name'}\n";
  my @l2s = grep { defined $subSystemL2Ids->{$_} } 
                 @{$subSysInterconnectTo->{$proc->{'id'}}};
  my $to_L2CC = scalar @l2s && $subSystemL2Ids->{$l2s[0]}->{'isL2CC'};

  my $num_masters = 1;
  # For NX without L2-CC or with separate inst/data ports, 
  # arbitrate between the datamaster/instmaster rd
  if ($proc->{'pipeline'} eq 'NX' and !$to_L2CC and 
      !$proc->{'masterDataInstMerged'} and $axi_type eq "rd") {
    $num_masters++;
  }

  # Arbitrate, if udma or shared iDMA
  if (defined $proc->{'udma'} or (defined $proc->{'idma'} and
                                  $proc->{'idma'}->{'shared'})) {
    $num_masters++;
  }

  # Arbitrate, if sDMA is shared
  if (defined $proc->{'sdma'} and $proc->{'sdma'}->{'shared'}) {
    $num_masters++;
  }

  # Restrict to 32 masters since we are reserving only 5-bits
  $num_masters <= 32 or
    die "Number of masters $num_masters for $proc->{'name'}'s ".
        "outbound arbiter has to be <= 32\n";
  
  push @$body, "--set_arbiter_parm=num_masters=$num_masters\n";
  push @$body, "--set_arbiter_parm=route_id_lsb=$route_id_lsb\n";
  if ($num_masters == 1) {
    push @$body, "--set_arbiter_parm=immediate_timing=true\n";
  } else {
    # Set up the byte widths for the ports
    if ($proc->{'pipeline'} eq 'NX') {
      # NX
      if (defined $proc->{'masterDataWidth'}  and
          defined $proc->{'masterInstWidth'} and
          ($proc->{'masterDataWidth'} != $proc->{'masterInstWidth'} or
           $proc->{'masterDataWidth'} != $proc->{'dmaWidth'})) {
        push @$body, "--set_arbiter_parm=master_byte_widths=",
                     "$proc->{'masterDataWidth'}";
        if ($axi_type eq "rd") {
          push @$body, ",$proc->{'masterInstWidth'}";
        }
        if (defined $proc->{'udma'} or (defined $proc->{'idma'} and
                                        $proc->{'idma'}->{'shared'})) {
          push @$body, ",$proc->{'dmaWidth'}";
        }
        if (defined $proc->{'sdma'} and $proc->{'sdma'}->{'shared'}) {
          push @$body, ",$proc->{'dmaWidth'}";
        }
        push @$body, "\n";
        push @$body, "--set_arbiter_parm=".
                     "slave_byte_width=$proc->{'masterWidth'}\n";
      } elsif ((defined $proc->{'udma'} or (defined $proc->{'idma'} and
                                            $proc->{'idma'}->{'shared'})) and
                $proc->{'masterDataInstMerged'} and 
                $proc->{'mergedMasterWidth'} != $proc->{'dmaWidth'}) {
        push @$body, "--set_arbiter_parm=master_byte_widths=".
                     "$proc->{'mergedMasterWidth'},$proc->{'dmaWidth'}";
        if (defined $proc->{'sdma'} and $proc->{'sdma'}->{'shared'}) {
          push @$body, ",$proc->{'dmaWidth'}";
        }
        push @$body, "\n";
        push @$body, "--set_arbiter_parm=slave_byte_width=".
                     "$proc->{'masterWidth'}\n";
      }
    } else {
      # LX with dma
      if ((defined $proc->{'udma'} or (defined $proc->{'idma'} and
                                       $proc->{'idma'}->{'shared'})) and
           $proc->{'pifWidth'} != $proc->{'dmaWidth'}) {
        push @$body, "--set_arbiter_parm=master_byte_widths=".
                     "$proc->{'pifWidth'},$proc->{'dmaWidth'}";
        if (defined $proc->{'sdma'} and $proc->{'sdma'}->{'shared'}) {
          push @$body, ",$proc->{'dmaWidth'}";
        }
        push @$body, "\n";
        my $out_width = ($proc->{'dmaWidth' } > $proc->{'pifWidth'}
                        ? $proc->{'dmaWidth'} : $proc->{'pifWidth'});
        push @$body, "--set_arbiter_parm=slave_byte_width=$out_width\n";
      }
    }
    push @$body, "--set_arbiter_parm=arbitration_phase=".
                 "$OUTBOUND_PIF_ARB_PHASE\n";
  }

  # Create the arbiter
  push @$body, "--set_arbiter_parm=one_at_a_time=false\n";
  push @$body, "--create_arbiter=$proc->{'name'}_outbound_${axi_type_str}arb\n";
  push @$body, "\n";

  # Connect proc ports to the arbiter
  push @$body, "// Connect to outbound of proc $proc->{'name'}\n";
  my $port_num = 0;
  if ($proc->{'axi'}) {
    # On AXI
    if ($proc->{'pipeline'} eq 'NX') {
      # For axi reads, add datamaster_rd and 
      # instmaster_rd (if not L2)
      # for axi writes, add datamaster_wr only
      # for combined data/inst master, add the combined port name
      my $data_port = $proc->{'masterDataInstMerged'} ? "aximaster"
                                                      : "datamaster";
      push @$body, "--connect=$proc->{'name'},${data_port}_${axi_type},".
                   "slave_port[0],".
                   "$proc->{'name'}_outbound_${axi_type_str}arb\n";
      $port_num++;
      if ($axi_type eq "rd" and !$to_L2CC and 
          !$proc->{'masterDataInstMerged'}) {
        push @$body, "--connect=$proc->{'name'},".
                     "instmaster_${axi_type},slave_port[1],".
                     "$proc->{'name'}_outbound_${axi_type_str}arb\n";
        $port_num++;
      }
    } else {
      # For LX on AXI, use the PIF2AXI transactor
      if ($axi_type eq "rd") {
        push @$body, "--connect=$proc->{'name'}_PIF2AXI_xtor,".
                     "aximaster_rd,slave_port[0],".
                     "$proc->{'name'}_outbound_${axi_type_str}arb\n";
        $port_num++;
      } else {
        push @$body, "--connect=$proc->{'name'}_PIF2AXI_xtor,".
                     "aximaster_wr,slave_port[0],".
                     "$proc->{'name'}_outbound_${axi_type_str}arb\n";
        $port_num++;
      }
    }
  } else {
    push @$body, "--connect=$proc->{'name'},pif,slave_port[0],".
                 "$proc->{'name'}_outbound_arb\n";
    $port_num = 1;
  }
  push @$body, "\n";

  if (defined $proc->{'udma'}) {
    # udma pif port
    push @$body, "// Connect $proc->{'name'}'s uDMA to ".
                 "$proc->{'name'}'s outbound arbiter\n";
    push @$body, "--connect=$proc->{'name'}_uDMA,pif_master_port,".
                 "slave_port[$port_num],".
                 "$proc->{'name'}_outbound_${axi_type_str}arb\n";
    push @$body, "\n";
  } elsif (defined $proc->{'idma'} and $proc->{'idma'}->{'shared'}) {
    # idma
    push @$body, "// Connect $proc->{'name'}'s iDMA to ".
                 "$proc->{'name'}'s outbound arbiter\n";
    if ($proc->{'axi'} && $proc->{'pipeline'} eq 'LX') {
      # LX proc on AXI bus - use the PIF2AXI transactor
      my $port = $axi_type eq "rd" ? "aximaster_rd" : "aximaster_wr";
      push @$body, "--connect=$proc->{'name'}_idma_PIF2AXI_xtor,$port,".
                   "slave_port[$port_num],".
                   "$proc->{'name'}_outbound_${axi_type_str}arb\n";
    } else {
      # idma on AXI
      my $dma = ($proc->{'pipeline'} eq 'NX' ? "idma_${axi_type}" : "idma0");
      push @$body, "--connect=$proc->{'name'},$dma,slave_port[$port_num],".
                   "$proc->{'name'}_outbound_${axi_type_str}arb\n";
    }
    $port_num++;
    push @$body, "\n";
  }

  if (defined $proc->{'sdma'} and $proc->{'sdma'}->{'shared'}) {
    # sdma
    push @$body, "// Connect $proc->{'name'}'s sDMA to ".
                 "$proc->{'name'}'s outbound arbiter\n";
    if ($proc->{'axi'}) {
      my $p = $axi_type eq "rd" ? "aximaster_rd" : "aximaster_wr";
      push @$body, "--connect=$proc->{'name'}_sDMA_PIF2AXI_xtor,$p,".
                   "slave_port[$port_num],".
                   "$proc->{'name'}_outbound_${axi_type_str}arb\n";
    } else {
      push @$body, "--connect=$proc->{'name'}_sDMA,master_port,".
                   "slave_port[$port_num],".
                   "$proc->{'name'}_outbound_${axi_type_str}arb\n";
    }
    push @$body, "\n";
  }
}

# Create proc/dma outbound router to route requests to interface, SubSystemMMIO,
# other procs.
sub generateXTSCOutboundRouterInstance {
  my ($body, $proc, $master, $axi_type) = @_;
  my $master_str = ($master ne "" ? "${master}_" : $master);
  my $axi_type_str = ($axi_type ne "" ? "${axi_type}_" : $axi_type);

  push @$body, "// Create outbound router for $proc->{'name'} $master\n";
  my $m = "";
  if ($master eq 'dma') {
    $m = "dma_";
  }
  push @$body, "--set_router_parm=routing_table=".
               "\$(XTSC_SCRIPT_FILE_PATH)/".
               "$proc->{'name'}_${m}outbound_${axi_type_str}rte.tab\n";

  # Port 0 is routed to the interface. All requests, not targeting a
  # a proc that is directly connected to this proc, are routed to the interface
  # by default
  push @$body, "--set_router_parm=default_port_num=0\n";
  my @slaves;
  foreach my $id (@{$subSysInterconnectTo->{$proc->{'id'}}}) {
    # For the proc, avoid bus routing if the proc is connected to a L2-CC.
    if ($master ne 'dma' and $id == $COMMON_BUS_ID) {
      my @l2s =  grep { defined $subSystemL2Ids->{$_} } 
                      @{$subSysInterconnectTo->{$proc->{'id'}}};
      if (scalar @l2s and $subSystemL2Ids->{$l2s[0]}->{'isL2CC'}) {
        next;
      }
    }
    # Avoid routing if proc is connected to a APB SubSystemMMIO
    if (defined $subSystemMMIOIds->{$id} and 
        defined $subSystemMMIOIds->{$id}->{'apb'}) {
      next;
    }
    push @slaves, $id;
  }
  my $num_slaves = @slaves;
  push @$body, "--set_router_parm=num_slaves=$num_slaves\n";
  # The in width is the proc's pif/idma width. The out width's can vary.
  # For port 0, which is to the common bus, the width is the common bus width.
  # For the rest, it is same as the pif width of this proc. This device 
  # acts as a pif width converter if the out and in widths do not match.
  my $proc_width;
  if ($master eq "dma") {
    $proc_width = $proc->{'dmaWidth'};
  } else {
    if ($proc->{'pipeline'} eq 'NX') {
      $proc_width = $proc->{'masterWidth'};
    } else {
      if ((defined $proc->{'idma'} and $proc->{'idma'}->{'shared'}) ||
          defined $proc->{'udma'}) {
        $proc_width = ($proc->{'dmaWidth' } > $proc->{'pifWidth'}
                       ? $proc->{'dmaWidth'} : $proc->{'pifWidth'});
      } else {
        $proc_width = $proc->{'pifWidth'};
      }
    }
  }

  # Set immediate timing only if single master, slave and no width conversion
  if ($num_slaves == 1 and (($proc_width == $subSysBusWidth) or
                            !(grep { $_ eq $COMMON_BUS_ID } @slaves))) {
    push @$body, "--set_router_parm=immediate_timing=true\n";
  } else {
    push @$body, "--set_router_parm=master_byte_width=$proc_width\n";
    my @slave_widths = ();
    foreach my $s (sort {$a<=>$b} @slaves) {
      if ($s == $COMMON_BUS_ID) {
        push @slave_widths, $subSysBusWidth;
      } else {
        push @slave_widths, $proc_width;
      }
    }
    my $widths = join(",", @slave_widths);
    push @$body, "--set_router_parm=slave_byte_widths=$widths\n";
  }
  push @$body, "--set_router_parm=flexible_request_id=true\n";
  if ($master eq "dma") {
    push @$body, "--set_router_parm=interleave_responses=false\n";
  }
  push @$body, "--create_router=".
               "$proc->{'name'}_${master_str}outbound_${axi_type_str}rte\n";
  push @$body, "\n";
}

# Generate per proc outbound router and add connections from the proc's
# outbound arbiters
sub generateXTSCOutboundRouter {
  my ($body, $proc, $axi_type) = @_;
  my $axi_type_str = ($axi_type ne "" ? "${axi_type}_" : $axi_type);

  generateXTSCOutboundRouterInstance($body, $proc, "", $axi_type);

  # Generate an outbound router for the idma port, if defined
  if ((defined $proc->{'idma'} and !$proc->{'idma'}->{'shared'}) or 
      (defined $proc->{'sdma'} and !$proc->{'sdma'}->{'shared'})) {
    generateXTSCOutboundRouterInstance($body, $proc, "dma", $axi_type);
  }

  my $lx = $proc->{'pipeline'} eq 'LX';
  my $nx = $proc->{'pipeline'} eq 'NX';

  # If there is an exclusive IDMA or no IDMA/UDMA, directly connect the pif port
  # and the IDMA port (if defined) to the outbound router.
  # For a shared IDMA or UDMA, connect the outbound router to the outbound
  # arbiter

  my $data_port_name = $proc->{'masterDataInstMerged'} ? "aximaster" 
                                                       : "datamaster";
  my $proc_port = $proc->{'axi'} 
                    ? ($axi_type eq "rd" 
                        ? "master_port" 
                        : ($lx ? "aximaster_wr" 
                               : $data_port_name."_${axi_type}"))
                    : "pif";

  my $dma_port = $nx ? "idma_${axi_type}" : "idma0";

  my $src = ($proc->{'axi'} and ($axi_type eq "rd")) 
              ? "$proc->{'name'}_outbound_rd_arb" 
              : (($lx and $proc->{'axi'}) ? "$proc->{'name'}_PIF2AXI_xtor"
                                          : $proc->{'name'});

  if (defined $proc->{'idma'} and !$proc->{'idma'}->{'shared'}) {
    push @$body, "// Connect $proc->{'name'}'s pif/datamaster/outbound_arb ".
                 "and idma to $proc->{'name'}'s outbound router\n";
    push @$body, "--connect=$src,$proc_port,slave_port,".
                 "$proc->{'name'}_outbound_${axi_type_str}rte\n";

    if (defined $proc->{'sdma'}) {
      push @$body, "--connect=$proc->{'name'}_dma_${axi_type_str}arb,".
                   "master_port,slave_port,".
                   "$proc->{'name'}_dma_outbound_${axi_type_str}rte\n";
    } else {
      if ($nx or ($lx and !$proc->{'axi'})) {
        push @$body, "--connect=$proc->{'name'},$dma_port,slave_port,".
                     "$proc->{'name'}_dma_outbound_${axi_type_str}rte\n";
      } else {
        my $port = $axi_type eq "rd" ? "aximaster_rd" : "aximaster_wr";
        push @$body, "--connect=$proc->{'name'}_idma_PIF2AXI_xtor,".
                     "$port,slave_port,".
                     "$proc->{'name'}_dma_outbound_${axi_type_str}rte\n";
      }
    }
  } elsif (!defined $proc->{'udma'} and !defined $proc->{'idma'} and
           (!defined $proc->{'sdma'} or !$proc->{'sdma'}->{'shared'})) {
    push @$body, "// Connect $proc->{'name'}'s pif/datamaster/outbound_arb ".
                 "to $proc->{'name'}'s outbound router\n";
    push @$body, "--connect=$src,$proc_port,slave_port,".
                 "$proc->{'name'}_outbound_${axi_type_str}rte\n";
    if (defined $proc->{'sdma'}) {
      push @$body, "// Connect $proc->{'name'}'s sDMA to $proc->{'name'}'s".
                   "outbound dma router\n";
      if ($proc->{'axi'}) {
        my $p = $axi_type eq "rd" ? "aximaster_rd" : "aximaster_wr";
        push @$body, "--connect=$proc->{'name'}_sDMA_PIF2AXI_xtor,".
                     "$p,slave_port,".
                     "$proc->{'name'}_dma_outbound_${axi_type_str}rte\n";
      } else {
        push @$body, "--connect=$proc->{'name'}_sDMA,master_port,slave_port,".
                     "$proc->{'name'}_dma_outbound_${axi_type_str}rte\n";
      }
    }
  } else {
    push @$body, "// Connect $proc->{'name'}'s outbound arbiter to ".
                 "$proc->{'name'}'s outbound router\n";
    push @$body, "--connect=$proc->{'name'}_outbound_${axi_type_str}arb,".
                 "master_port,slave_port,".
                 "$proc->{'name'}_outbound_${axi_type_str}rte\n";
  }
  push @$body, "\n";
}

# Create SubSystemIO
sub createXTSCSubSystemIO {
  my ($body, $xtsc_run_gen_dir) = @_;

  if (!@subSystemIOs) {
    return;
  }

  push @$body, "// Generate SubSystem IO pins\n";
  push @$body, "--set_source_parm=definition_file=".
               "\$(XTSC_SCRIPT_FILE_PATH)/SubSystemIO.def\n";
  push @$body, "--set_source_parm=script_file=".
               "\$(XTSC_SCRIPT_FILE_PATH)/SubSystemIO.vec\n";
  push @$body, "--create_source=SubSystemIO\n";

  push @$body, "\n";
  push @$body, "--set_logic_parm=definition_file=".
               "\$(XTSC_SCRIPT_FILE_PATH)/SubSystemIO_logic.def\n";
  push @$body, "--create_logic=SubSystemIO_logic\n";

  # wire source
  my $ssio_vec_file = "$xtsc_run_gen_dir/SubSystemIO.vec\n";
  open(ssio_vec_file, ">$ssio_vec_file") or 
      sysBuildError("Could not open $ssio_vec_file\n");

  my $ssio_def_file = "$xtsc_run_gen_dir/SubSystemIO.def\n";
  open(ssio_def_file, ">$ssio_def_file") or 
      sysBuildError("Could not open $ssio_def_file\n");
  print ssio_def_file 
        "/* <output>  <OutputName>   <BitWidth>  <InitValue>  */\n\n";

  foreach my $ssio (@subSystemIOs) {
    printf ssio_def_file "%-12s %-20s %-10d %-10d\n", "output",
          $ssio->{'name'}, $ssio->{'width'}, $ssio->{'initValue'};
  }

  # logic
  my $ssio_logic_file = "$xtsc_run_gen_dir/SubSystemIO_logic.def\n";
  open(ssio_logic_file, ">$ssio_logic_file") or 
      sysBuildError("Could not open $ssio_logic_file\n");

  print ssio_logic_file 
    "/* <input>  <Name>   <BitWidth>  <InitValue>  */\n\n";
  foreach my $ssio (@subSystemIOs) {
    printf ssio_logic_file "%-10s %-20s %-10d %-10d\n", "input",
          $ssio->{'name'}, $ssio->{'width'}, $ssio->{'initValue'};
  }
  print ssio_logic_file "\n";

  print ssio_logic_file 
    "/* <output>  <Name>   <BitWidth>  <InitValue>  */\n\n";
  foreach my $ssio (@subSystemIOs) {
    my $i = 0;
    foreach my $ctrl (@{$ssio->{'subPins'}}) {
      my $mask = $ctrl->{'bitEnd'} - $ctrl->{'bitStart'} + 1;
      printf ssio_logic_file "%-10s %-20s %-10d %-10d\n", "output",
             $ssio->{'name'}."_subPin$i",
             $ctrl->{'bitEnd'}-$ctrl->{'bitStart'}+1,
             (($ssio->{'initValue'} >> $ctrl->{'bitStart'}) & $mask);
      $i++;
    }
  }

  foreach my $ssio (@subSystemIOs) {
    my $i = 0;
    foreach my $ctrl (@{$ssio->{'subPins'}}) {
      print ssio_logic_file "\n";
      print ssio_logic_file 
            "iterator i$i $ctrl->{'bitStart'} $ctrl->{'bitEnd'}\n";
      printf ssio_logic_file "assign %s = %-20s\n",
             $ssio->{'name'}."_subPin".$i."[i$i]", $ssio->{'name'}."[i$i]";
      
      $i++;
    }
  }

  push @$body, "\n";
  foreach my $ssio (@subSystemIOs) {
    push @$body, "--connect=SubSystemIO,$ssio->{'name'},".
                 "$ssio->{'name'},SubSystemIO_logic\n";
  }
  foreach my $ssio (@subSystemIOs) {
    my $i = 0;
    foreach my $ctrl (@{$ssio->{'subPins'}}) {
      push @$body, "--connect=SubSystemIO_logic,$ssio->{'name'}_subPin$i,".
                   "$ctrl->{'name'},$ctrl->{'comp'}\n";
      $i++;
    }
  }
  push @$body, "\n";

  close ssio_vec_file;
  close ssio_def_file;
  close ssio_logic_file;
}

# Create SubSystemMMIO
sub createXTSCSubSystemMMIO {
  my ($body, $route_id_lsb, $xtsc_run_gen_dir, $smmio) = @_;

  # The APB bus is currently just a single arbiter connected to the
  # the interrupt distributor (SubSystemMMIO)

  # All above cores + bus + SystemDMA (optional)
  my $numSubSystemMMIOArbMasters;

  if (defined $smmio->{'apb'}) {
    $numSubSystemMMIOArbMasters = 
     # procs connected to this mmio
     (!defined $subSysInterconnectFrom->{$smmio->{'id'}}
      ? 0 : scalar (@{$subSysInterconnectFrom->{$smmio->{'id'}}})) +
     # bus
     1 + 
     # SystemDMA
    (defined $SystemDMA->{'baseAddr'} ? 1 : 0);
  } else {
    # Can have ports from bus, all procs (including dma)
    # connected to this SubSystemMMIO 
    my $numPorts = 1 +  # bus
                   (defined $SystemDMA->{'baseAddr'} ? 1 : 0) +
                   (!defined $subSysInterconnectFrom->{$smmio->{'id'}}
                    ? 0 
                    : scalar (@{$subSysInterconnectFrom->{$smmio->{'id'}}}));
    if (defined $subSysInterconnectFrom->{$smmio->{'id'}}) {
      foreach my $id (@{$subSysInterconnectFrom->{$smmio->{'id'}}}) {
        if (isProcId($id)) {
          my $proc = $procIdMap->{$id};
          if ((defined $proc->{'idma'} and !$proc->{'idma'}->{'shared'}) or 
              (defined $proc->{'sdma'} and !$proc->{'sdma'}->{'shared'})) {
            $numPorts++;
          }
        } elsif (isXNNEId($id)) {
          # Add additional xnne master ports connected to this mmio
          my $xnne = $xnneIdMap->{$id};
          $numPorts += 
              (scalar (@{$xnne->{'masterCompMap'}->{$smmio->{'id'}}}) - 1);
        }
      }
    }
    $numSubSystemMMIOArbMasters = ($subSysMasterProc->{'axi'} ? 2 : 1) * 
                                  $numPorts;
  }

  # Create the SubSystemMMIO arbiter
  push @$body, "// Create the SubSystemMMIO arbiter\n";
  push @$body, "--set_arbiter_parm=num_masters=$numSubSystemMMIOArbMasters\n";
  if (defined $smmio->{'apb'}) {
    push @$body, "--set_arbiter_parm=apb=true\n";
  } else {
    # apb=true needs default route_id_lsb settings
    push @$body, "--set_arbiter_parm=route_id_lsb=$route_id_lsb\n";
  }
  if ($numSubSystemMMIOArbMasters == 1 && 
      !defined $smmio->{'apb'}) {
    push @$body, "--set_arbiter_parm=immediate_timing=true\n";
  } else {
    push @$body, "--set_arbiter_parm=arbitration_phase=".
                 "$SUB_SYSTEM_MMIO_ARB_PHASE\n";
  }
  push @$body, "--create_arbiter=$smmio->{'name'}_arb\n";
  push @$body, "\n";

  if (defined $smmio->{'apb'}) {
    # Connect from proc's apb ports to the arbiter
    push @$body, "// APB arbiter masters - ".
                 join(", ", map("$procIdMap->{$_}->{'name'}", 
                      (sort {$a<=>$b} 
                       @{$subSysInterconnectFrom->{$smmio->{'id'}}})))."\n";
    # First port to the apb arbiter is from the bus
    # Followed by optional SystemDMA
    my $port = 1;
    if ($SystemDMA->{'baseAddr'}) {
      $port++;
    }
    # The processors follow this
    foreach my $pid (sort {$a<=>$b} 
                     @{$subSysInterconnectFrom->{$smmio->{'id'}}}) {
      push @$body, "--connect=$procIdMap->{$pid}->{'name'},apb,".
                   "slave_port[$port],$smmio->{'name'}_arb\n";
      $port++;
    }
    push @$body, "\n";
  } 

  # Create dummy APB router
  if (defined $smmio->{'apb'}) {
    push @$body, "// Create dummy router to route apb requests to ".
                 "the SubSystemMMIO or possibly to external\n";
    push @$body, "--set_router_parm=routing_table=".
                 "\$(XTSC_SCRIPT_FILE_PATH)/$smmio->{'name'}_rte.tab\n";
    push @$body, "--set_router_parm=default_port_num=0\n";
    push @$body, "--set_router_parm=num_slaves=1\n";
    push @$body, "--create_router=$smmio->{'name'}_rte\n";
    push @$body, "\n";
    push @$body, "// Connect the SubsystemMMIO arb to router\n";
    push @$body, "--connect=$smmio->{'name'}_arb,master_port,".
                 "slave_port,$smmio->{'name'}_rte\n";
    push @$body, "\n";

    # Create routing table entries
    my $apb_routing_tab_file = "$xtsc_run_gen_dir/$smmio->{'name'}_rte.tab";
    open(apb_routing_tab_file, ">$apb_routing_tab_file") or 
      sysBuildError("Could not open $apb_routing_tab_file\n");
    print apb_routing_tab_file 
          "/* <Port>  <LowAddr>   <HighAddr>  <NewBaseAddr>  */\n\n";

    foreach my $car (@{$smmio->{'intrRegs'}}) {
      printf apb_routing_tab_file "    0     $car->{'localAddr'}     ".
                                  "0x%x            /* $smmio->{'name'} */\n", 
                                  hex($car->{'localAddr'}) + 4 - 1;
    }
    foreach my $car (@{$smmio->{'controlRegs'}}) {
      printf apb_routing_tab_file "    0     $car->{'localAddr'}     ".
                                  "0x%x            /* $smmio->{'name'} */\n", 
                                  hex($car->{'localAddr'}) + 4 - 1;
    }
  }

  # Define the xtsc mmio
  push @$body, "// Create the MMIO for the SubSystemMMIO registers\n";
  push @$body, "--set_mmio_parm=definition_file=".
               "\$(XTSC_SCRIPT_FILE_PATH)/$smmio->{'name'}.def\n";
  push @$body, "--create_mmio=$smmio->{'name'}_mmio\n";
  push @$body, "\n";

  if (defined $smmio->{'apb'}) {
    push @$body, "// Connect the SubSystemMMIO rte to the SubSystemMMIO mmio\n";
    push @$body, "--connect=$smmio->{'name'}_rte,master_port[0],".
                 "slave_port,$smmio->{'name'}_mmio\n";
  } else {
    push @$body, "// Connect the SubSystemMMIO arb to the SubSystemMMIO mmio\n";
    push @$body, "--connect=$smmio->{'name'}_arb,master_port,".
                 "slave_port,$smmio->{'name'}_mmio\n";
  }
  push @$body, "\n";

  # Connect xtsc mmio to processors BInterrupt pins
  push @$body, "// Connect the SubSystemMMIO interrupts\n";
  my $num = 0;
  foreach my $car (@{$smmio->{'intrRegs'}}) {
    push @$body, "// Connect SubSystemMMIO $smmio->{'name'} ".
                 "to the processor Binterrupts\n";
    my $h = $car->{'bIntrMap'};
    foreach my $bitOffset (sort {$a<=>$b} keys %$h) {
      my $bInterrupt = $h->{$bitOffset};
      my $bIntrPrefix = "";
      my $proc = $car->{'procMap'}{$bitOffset};
      if ($bInterrupt < 10) {
        $bIntrPrefix = ($procNameMap->{$proc}->{'pipeline'} eq 'LX') ? "0" 
                                                                     : "00";
      } elsif ($bInterrupt < 100) {
        if ($procNameMap->{$proc}->{'pipeline'} eq 'NX') {
          $bIntrPrefix = "0";
        }
      }
      push @$body, "--connect=$smmio->{'name'}_mmio,".
                   "$smmio->{'name'}_intrreg${num}_${bitOffset},BInterrupt".
                   $bIntrPrefix.$bInterrupt.
                   ",$procNameMap->{$proc}->{'name'}\n";
    }
    $num++;
  }
  push @$body, "\n";

  # Hook the controls to the core
  push @$body, "// Connect the SubSystemMMIO control\n";
  my $car_controls = $smmio->{'controlRegs'};

  my $runonreset_logic = 0;
exit_runonreset:
  foreach my $car_ctrl (@$car_controls) {
    foreach my $reg (@{$car_ctrl->{'subRegs'}}) {
      if ($reg->{'name'} eq 'RunOnReset') {
        $runonreset_logic = 1;
        push @$body, "// Logic for SubSystemMMIO_RunOnReset\n";
        push @$body, "--set_logic_parm=definition_file=".
                     "\$(XTSC_SCRIPT_FILE_PATH)/".
                     "$smmio->{'name'}_RunOnReset_logic.def\n";
        push @$body, "--create_logic=$smmio->{'name'}_RunOnReset_logic\n";
        push @$body, "\n";
        last exit_runonreset;
      }
    }
  }

  # Generate the special RunOnReset negation logic
  if ($runonreset_logic) {
    my $xtsc_car_run_on_reset_logic_def = 
       "$xtsc_run_gen_dir/$smmio->{'name'}_RunOnReset_logic.def";
    open(xtsc_car_run_on_reset_logic_def, 
         ">$xtsc_car_run_on_reset_logic_def") or 
      sysBuildError("Could not open $xtsc_car_run_on_reset_logic_def\n");

    printf xtsc_car_run_on_reset_logic_def 
           "/* input <InputName> <BitWidth> */\n\n";

    foreach my $car_ctrl (@$car_controls) {
      foreach my $reg (@{$car_ctrl->{'subRegs'}}) {
        if ($reg->{'name'} eq 'RunOnReset') {
          printf xtsc_car_run_on_reset_logic_def 
                 "input  %-30s 1\n", 
                 "$smmio->{'name'}_RunOnReset_in_$reg->{'comp'}";
        }
      }
    }

    print xtsc_car_run_on_reset_logic_def "\n";
    printf xtsc_car_run_on_reset_logic_def 
           "/* output <OutputName> <BitWidth> <InitialValue>*/\n\n";
    foreach my $car_ctrl (@$car_controls) {
      foreach my $reg (@{$car_ctrl->{'subRegs'}}) {
        if ($reg->{'name'} eq 'RunOnReset') {
          my $mask = $reg->{'bitEnd'} - $reg->{'bitStart'} + 1;
          printf xtsc_car_run_on_reset_logic_def "output %-30s 1 ".
                 (($car_ctrl->{'initValue'} >> $reg->{'bitStart'}) & $mask).
                 "\n", "$smmio->{'name'}_RunOnReset_out_$reg->{'comp'}";
        }
      }
    }
    print xtsc_car_run_on_reset_logic_def "\n";
    printf xtsc_car_run_on_reset_logic_def 
           "/* assign <OutputName> <RpnExpression>*/\n\n";

    foreach my $car_ctrl (@$car_controls) {
      foreach my $reg (@{$car_ctrl->{'subRegs'}}) {
        if ($reg->{'name'} eq 'RunOnReset') {
          printf xtsc_car_run_on_reset_logic_def 
                 "assign %-30s = %s !\n", 
                 "$smmio->{'name'}_RunOnReset_out_$reg->{'comp'}", 
                 "$smmio->{'name'}_RunOnReset_in_$reg->{'comp'}";
        }
      }
      print xtsc_car_run_on_reset_logic_def "\n";
    }
  }

  foreach my $car_ctrl (@$car_controls) {
    foreach my $reg (@{$car_ctrl->{'subRegs'}}) {
      # Special handling for RunOnReset. Negate the output before connecting
      # to core's RunStallOnReset
      my $comp = $reg->{'comp'};
      my @l2s = ();
      if (defined $reg->{'comp'} and defined $procNameMap->{$comp}) { 
        @l2s = grep { defined $subSystemL2Ids->{$_} } 
                    @{$subSysInterconnectTo->{$procNameMap->{$comp}->{'id'}}};
      }
      if ($reg->{'name'} eq 'RunOnReset') {
        push @$body, "// Connect $reg->{'name'} control\n";
        push @$body, "--connect=$smmio->{'name'}_mmio,".
                     "$smmio->{'name'}_$reg->{'name'}_$comp,".
                     "$smmio->{'name'}_$reg->{'name'}_in_$comp,".
                     "$smmio->{'name'}_$reg->{'name'}_logic\n";
        push @$body, "--connect=$smmio->{'name'}_$reg->{'name'}_logic,".
                     "$smmio->{'name'}_$reg->{'name'}_out_$comp,".
                     "RunStallOnReset,$comp\n";
      } elsif (scalar @l2s and $subSystemL2Ids->{$l2s[0]}->{'isL2CC'} and 
               $reg->{'name'} eq 'PWaitMode') {
        # Generate PWaitMode
        $reg->{'dir'} eq 'in' or 
          die "For PWaitMode, in control register $car_ctrl->{'globalAddr'}, ".
              "the direction has to be 'in'\n";
        push @$body, "// Connect $reg->{'name'} PWaitMode\n";
        my $p = $procNameMap->{$comp};
        push @$body, "--connect=$subSystemL2Ids->{$l2s[0]}->{'name'}".
                     "_pwait_logic,".
                     "$smmio->{'name'}_$p->{'name'}_pwait,".
                     "$smmio->{'name'}_PWaitMode_$p->{'name'},".
                     "$smmio->{'name'}_mmio\n";
        my $pwait_logic_file = 
           "$xtsc_run_gen_dir/$subSystemL2Ids->{$l2s[0]}->{'name'}_pwait.def\n";
        open(pwait_logic_file, ">>$pwait_logic_file") or 
            sysBuildError("Could not open $pwait_logic_file\n");
        print pwait_logic_file "\n";
        print pwait_logic_file 
              "output $smmio->{'name'}_$p->{'name'}_pwait 1 0\n";
        print pwait_logic_file "assign $smmio->{'name'}_$p->{'name'}_pwait = ".
                               "$p->{'name'}_pwait\n";
        close pwait_logic_file;
      } else {
        if (defined $comp) {
          push @$body, "// Connect $reg->{'name'} control\n";
          if ($reg->{'dir'} eq 'out') {
            push @$body, "--connect=$smmio->{'name'}_mmio,".
                         "$smmio->{'name'}_$reg->{'name'}_$comp,".
                         "$reg->{'name'},$comp\n";
          } else {
            push @$body, "--connect=$comp,$reg->{'name'},".
                         "$smmio->{'name'}_$reg->{'name'}_$comp,".
                         "$smmio->{'name'}_mmio\n";
          }
        }
      }
    }
  }
  push @$body, "\n";
}

# Create SubSystem inbound router that routes requests from bus
# to processors in the interface
sub generateXTSCSubSystemInboundRouter {
  my ($body, $axi_type, $id) = @_;
  my $axi_type_str1 = ($axi_type ne "" ? "${axi_type}_" : $axi_type);

  # Find procs in the interface set with connection from Bus
  my @procs;
  foreach my $pid (@{$subSysInterconnectTo->{$COMMON_BUS_ID}}) {
    if (isProcId($pid) and $procIdMap->{$pid}->{'extIntfId'} == $id) {
      push @procs, $pid;
    }
  }

  # Find XNNEs in the interface set with connection from Bus
  my @xnnes;
  foreach my $xid (@{$subSysInterconnectTo->{$COMMON_BUS_ID}}) {
    if (isXNNEId($xid) and $xnneIdMap->{$xid}->{'extIntfId'} == $id) {
      push @xnnes, $xid;
    }
  }

  # Router for routing external access to the inbound of all processors
  # and XNNEs
  my $numBusRouterSlaves = scalar @procs + scalar @xnnes;

  if ($numBusRouterSlaves == 0) {
    return;
  }

  # Find the procs with local MMIOs
  my @procsWithLocalMMIOS;
  foreach my $pid (@procs) {
    if (defined $procIdMap->{$pid}->{'mmio'}) {
      push @procsWithLocalMMIOS, $procIdMap->{$pid}->{'name'};
    }
  }

  push @$body, "// Create subsystem inbound ${axi_type} router\n";
  push @$body, "// Subsystem inbound router slaves - ".
               join(", ", map($procIdMap->{$_}->{'name'}, 
                              sort {$a<=>$b} @procs))."\n";
  if (@procsWithLocalMMIOS) {
    push @$body, "//                     ".
                 join(", ", map($_."'s MMIO", @procsWithLocalMMIOS)).",\n";
  }
  if (@xnnes) {
    push @$body, "//                     ".
                 join(", ", map($xnneIdMap->{$_}->{'name'}, 
                                sort {$a<=>$b} @xnnes))."\n";
  }

  push @$body, "--set_router_parm=routing_table=".
               "\$(XTSC_SCRIPT_FILE_PATH)/SubSystem_inbound_rte${id}.tab\n";
  push @$body, "--set_router_parm=num_slaves=".$numBusRouterSlaves."\n";
  push @$body, "--set_router_parm=default_port_num=666\n";
  push @$body, "--create_router=SubSystem_inbound_${axi_type_str1}rte${id}\n";
  push @$body, "\n";
}

# Creates SubSystem outbound arbiter/router/ROB and for each interface
# and connect the proc's outbounds to it. 'procIds' is a list of procs,
# xnnes is a list of xnnes and numSubSystemExtPorts is the number of 
# ports for this interface. Note, numSubSystemExtPorts can be null.
sub generateXTSCSubsystemOutboundArbiter {
  my ($body, $route_id_lsb, $axi_type, $arbIdStart, $procIds, $xnneIds,
      $numSubSystemExtPorts, $rob) = @_;
  my $axi_type_str1 = ($axi_type ne "" ? "${axi_type}_" : $axi_type);

  my $numOutBounds = {};

  # Compute number of outbound subsystem ports per core
  foreach my $pid (sort {$a<=>$b} @$procIds) {
    my $proc = $procIdMap->{$pid};

    my $numArbMasters = 0;

    if (grep { $_ eq $pid } @{$subSysInterconnectFrom->{$COMMON_BUS_ID}}) {
      # If core has a connection to L2 CC, ignore
      my @l2s = grep { defined $subSystemL2Ids->{$_} } 
                @{$subSysInterconnectTo->{$pid}};
      my $to_l2cc = scalar @l2s && $subSystemL2Ids->{$l2s[0]}->{'isL2CC'};
      if (!$to_l2cc) {
        $numArbMasters = 1;
      }
    }

    # If cores have the idma, they have a separate port to the arbiter
    if ((defined $procIdMap->{$pid}->{'idma'} and 
         !$procIdMap->{$pid}->{'idma'}->{'shared'}) or
        (defined $procIdMap->{$pid}->{'sdma'} and 
         !$procIdMap->{$pid}->{'sdma'}->{'shared'}) ) {
      $numArbMasters++;
    }

    # Note, if core is connected to L2CC and has no dma, then it has no
    # direct path to the outside
    $numOutBounds->{$pid} = $numArbMasters;
  }

  # Add XNNEs. Each XNNE master port can possibly have a dedicated 
  # SubSystem outbound port
  my $numXnneMasters = 0;
  if (defined $xnneIds) {
    foreach my $xid (sort {$a<=>$b} @$xnneIds) {
      $numXnneMasters += 
        (scalar @{$xnneIdMap->{$xid}->{'masterCompMap'}->{$COMMON_BUS_ID}});
    }
  }

  # Compute number of masters per subsystem outbound arbiter
  # Can potentially be 0.
  my $numMastersPerArb = {};
  my $ndevs_per_arb = 0;

  if ($numSubSystemExtPorts) {
    $ndevs_per_arb = 
        (scalar (@$procIds) + $numXnneMasters) / $numSubSystemExtPorts;
    my $rid = 0;
    foreach my $pid (sort {$a<=>$b} @$procIds) {
      my $my_arb = int($rid / $ndevs_per_arb);
      $numMastersPerArb->{$my_arb} += $numOutBounds->{$pid};
      $rid++;
    }
    if (defined $xnneIds) {
      foreach my $xid (sort {$a<=>$b} @$xnneIds) {
        foreach (@{$xnneIdMap->{$xid}->{'masterCompMap'}->{$COMMON_BUS_ID}}) {
          my $my_arb = int($rid / $ndevs_per_arb);
          $numMastersPerArb->{$my_arb}++;
          $rid++;
        }
      }
    }
  }

  # Create ROB per arbiter
  if (defined $rob and $axi_type eq "rd") {
    push @$body, "// Create ROB\n";
    foreach my $arb (sort {$a<=>$b} keys %$numMastersPerArb) {
      my $arbn = $arbIdStart + $arb;
      push @$body, "--set_xtsc_reorder_buffer_parm=num_entries=",
                   "$rob->{'numEntries'}\n";
      push @$body, "--set_xtsc_reorder_buffer_parm=",
                   "axi_byte_width=$subSysBusWidth\n";
      push @$body, "--create_xtsc_reorder_buffer=SubSystem_ROB${arbn}\n";
      push @$body, "\n";
    }
  }

  # Create arbiters
  push @$body, "// Create subsystem outbound $axi_type arbiters\n";
  foreach my $arb (sort {$a<=>$b} keys %$numMastersPerArb) {
    my $arbn = $arbIdStart + $arb;
    my $numArbMasters = $numMastersPerArb->{$arb};

    # Restrict to 32 masters since we are reserving only 5-bits
    $numArbMasters <= 32 or
      die "Number of masters $numArbMasters for SubSystem ".
          "outbound arbiter has to be <= 32\n";

    push @$body, "--set_arbiter_parm=num_masters=$numArbMasters\n";
    push @$body, "--set_arbiter_parm=route_id_lsb=$route_id_lsb\n";
    # the out and the in widths are the same common bus width
    if ($numArbMasters == 1) {
      push @$body, "--set_arbiter_parm=immediate_timing=true\n";
    } else {
      push @$body, "--set_arbiter_parm=arbitration_phase=",
                   "$OUTBOUND_SUBSYSTEM_PIF_ARB_PHASE\n";
    }
    push @$body, "--set_arbiter_parm=one_at_a_time=false\n";
    push @$body, "--create_arbiter=",
                 "SubSystem_outbound_${axi_type_str1}arb${arbn}\n";
    push @$body, "\n";

    # Connect arbiter to ROB
    if (defined $rob) {
      push @$body, "--connect=SubSystem_outbound_${axi_type_str1}arb${arbn},",
                   "master_port,axislave_${axi_type},SubSystem_ROB${arbn}\n";
      push @$body, "\n";
    }
    
    # Create a dummy router for possible future extension. For now it
    # goes to the Bus.
    push @$body, "// Add a dummy router. Default to bus. ",
                 "Possibly route to other targets\n";
    push @$body, "--set_router_parm=num_slaves=1\n";
    push @$body, "--set_router_parm=immediate_timing=true\n";
    push @$body, "--create_router=",
                 "SubSystem_outbound_${axi_type_str1}rte${arbn}\n";
    push @$body, "\n";

    # Connect ROB to router. arb -> rob -> rte
    if (defined $rob) {
      push @$body, "--connect=SubSystem_ROB${arbn},aximaster_${axi_type},",
                   "slave_port,SubSystem_outbound_${axi_type_str1}rte${arbn}\n";
    } else {
      push @$body, "--connect=SubSystem_outbound_${axi_type_str1}arb${arbn},",
                   "master_port,slave_port,",
                   "SubSystem_outbound_${axi_type_str1}rte${arbn}\n";
    }
    push @$body, "\n";
  }

  # Connect proc's outbound router to subsystem outbound and SubSystemMMIO
  # arbiter
  # Port 0 of the outbound router for each proc is connected to the
  # subsystem outbound arbiter.
  # Port 1 of the outbound router for each proc is connected to the
  # SubSystemMMIO arbiter.
  push @$body, "// Connect processor outbound router to subsystem ",
               "$axi_type arbiter\n";
  my $arbCurPort = {};
  my $rid = 0;
  foreach my $pid (sort {$a<=>$b} @$procIds) {
    my $proc = $procIdMap->{$pid};
    my $my_arb = 0;
    my @l2s = grep { defined $subSystemL2Ids->{$_} } 
              @{$subSysInterconnectTo->{$proc->{'id'}}};
    my $to_L2CC = scalar @l2s && $subSystemL2Ids->{$l2s[0]}->{'isL2CC'};
    if ($to_L2CC) {
      # For L2-CC, only the dma goes to the subsystem outbound arbiter
      if ((defined $proc->{'idma'} and !$proc->{'idma'}->{'shared'}) or 
          (defined $proc->{'sdma'} and !$proc->{'sdma'}->{'shared'})) {
        $my_arb = int($rid / $ndevs_per_arb);
        my $arbn = $arbIdStart + $my_arb;
        my $cur_port = exists($arbCurPort->{$my_arb}) ? $arbCurPort->{$my_arb} 
                                                      : 0;
        push @$body, 
             "--connect=$proc->{'name'}_dma_outbound_${axi_type_str1}rte,",
             "master_port[0],slave_port[${cur_port}],",
             "SubSystem_outbound_${axi_type_str1}arb${arbn}\n";
      }
    } else {
      # Else, core and dma goes to the subsystem outbound arbiter
      $my_arb = int($rid / $ndevs_per_arb);
      my $arbn = $arbIdStart + $my_arb;
      my $cur_port = exists($arbCurPort->{$my_arb}) ? $arbCurPort->{$my_arb} 
                                                    : 0;
      # Port 0 of the proc's outbound router goes to the subsystem outbound
      # arbiter
      push @$body, "--connect=$proc->{'name'}_outbound_${axi_type_str1}rte,",
                   "master_port[0],slave_port[${cur_port}],",
                   "SubSystem_outbound_${axi_type_str1}arb${arbn}\n";

      if ((defined $proc->{'idma'} and !$proc->{'idma'}->{'shared'}) or 
          (defined $proc->{'sdma'} and !$proc->{'sdma'}->{'shared'})) {
        # Port 0 of the proc's dma outbound router goes to the subsystem 
        # outbound arbiter
        push @$body, "--connect=",
                     "$proc->{'name'}_dma_outbound_${axi_type_str1}rte,",
                     "master_port[0],slave_port[".(${cur_port}+1)."]",
                     ",SubSystem_outbound_${axi_type_str1}arb${arbn}\n";
      }
    }
    $arbCurPort->{$my_arb} += $numOutBounds->{$pid};
    $rid++;
  }

  # Add ports from the XNNE outbound router
  if (defined $xnneIds) {
    foreach my $xid (sort {$a<=>$b} @$xnneIds) {
      my $xnne = $xnneIdMap->{$xid};
      # Port 0 of the XNNE's outbound router goes to the subsystem outbound
      # arbiter
      my $idx = 0;
      foreach my $m (@{$xnne->{'masterCompMap'}->{$COMMON_BUS_ID}}) {
        my $my_arb = int($rid / $ndevs_per_arb);
        my $arbn = $arbIdStart + $my_arb;
        my $cur_port = exists($arbCurPort->{$my_arb}) ? $arbCurPort->{$my_arb} 
                                                      : 0;
        push @$body, 
             "--connect=$xnne->{'name'}_outbound_${axi_type_str1}rte$idx,",
             "master_port[0],slave_port[$cur_port],",
             "SubSystem_outbound_${axi_type_str1}arb${arbn}\n";

        $arbCurPort->{$my_arb}++;
        $idx++;
        $rid++;
      }
    }
  }
  push @$body, "\n";
}

sub generateXTSCBusArbiterRouter {
  my ($body, $route_id_lsb, $axi_type) = @_;
  my $axi_type_str = ($axi_type ne "" ? "_${axi_type}" : $axi_type);

  ##### BUS Arbiter ######

  # Compute the total number of ports from each external interface
  my $numSubSystemExtPorts = 0;
  foreach my $extIntf (@subSystemExternalInterfaces) {
    $numSubSystemExtPorts += $extIntf->{'numPorts'};
  }

  # The ports of the bus arbiter are from the external interfaces. 
  my $numBusArbMasters = $numSubSystemExtPorts;
  
  # L2 
  foreach my $l2 (values %$subSystemL2s) {
    if ($l2->{'isL2CC'}) {
      $numBusArbMasters++;
    }
  }

  # SystemDMA 
  if (defined $SystemDMA->{'baseAddr'}) {
    $numBusArbMasters++;
  }

  # Testbench xtsc_master 
  $numBusArbMasters++;

  push @$body, "// Bus arbiter masters - ".
               join(", ", map((defined $xnneIdMap->{$_} 
                                 ? $xnneIdMap->{$_}->{'name'}
                                 : $procIdMap->{$_}->{'name'}), 
               sort {$a<=>$b} @{$subSysInterconnectFrom->{$COMMON_BUS_ID}})).
              (scalar @{$subSysInterconnectFrom->{$COMMON_BUS_ID}} ? ", " : "").
              "L2 (optional), SystemDMA (optional) and the TestBenchMaster\n";

  # Restrict to 64 masters since we are reserving only 6-bits
  $numBusArbMasters <= 64 or
    die "Nuber of bus masters $numBusArbMasters has to be <= 64\n";

  push @$body, "--set_arbiter_parm=num_masters=$numBusArbMasters\n";
  push @$body, "--set_arbiter_parm=route_id_lsb=$route_id_lsb\n";

  # Form a list of subsystem interface arbiters that are connected to the bus
  my @subsystemArbs = map  {$_} 0..$numSubSystemExtPorts-1;

  # the out and the in widths are the same common bus width
  push @$body, "--set_arbiter_parm=master_byte_widths=".
               join(",", map($subSysBusWidth, @subsystemArbs)).
               (scalar @subsystemArbs ? "," : "");

  # L2 follows the interfaces
  foreach my $l2 (values %$subSystemL2s) {
    if ($l2->{'isL2CC'}) {
      push @$body, "$l2->{'masterWidth'},";
    }
  }

  # SystemDMA 
  if (defined $SystemDMA->{'baseAddr'}) {
    push @$body, "$subSysBusWidth,";
  }

  # Testbench master
  push @$body, "$subSysBusWidth\n";
  push @$body, "--set_arbiter_parm=slave_byte_width=$subSysBusWidth\n";
  push @$body, "--set_arbiter_parm=request_fifo_depth=32\n";
  push @$body, "--set_arbiter_parm=response_fifo_depth=32\n";
  push @$body, "--set_arbiter_parm=one_at_a_time=false\n";
  push @$body, "--create_arbiter=BUS_arb${axi_type_str}\n";
  push @$body, "\n";

  ##### BUS Router ######

  my $bus_memories  = 1 + # SystemRAM
                      (defined $systemROM->{'globalAddr'} ? 1 : 0) +
                      @DeviceMemories +
                      scalar (values %$subSystemL2s) +
                      (defined $SystemDMA->{'baseAddr'} ? 1 : 0) +
                      (scalar (keys %$subSystemMMIOs));

  # Find unique interfaces for procs with connection from bus
  my $intf = {};
  foreach my $id (@{$subSysInterconnectTo->{$COMMON_BUS_ID}}) {
    if (isProcId($id)) {
      $intf->{$procIdMap->{$id}->{'extIntfId'}} = 1;
    } else {
      $intf->{$xnneIdMap->{$id}->{'extIntfId'}} = 1;
    }
  }
    
  my $numBusRouterSlaves =
    # For the subsystem routers
    scalar (keys %$intf) +
    $bus_memories;

  push @$body, "// Create common bus router\n";
  push @$body, "// Bus router slaves - SubSystem inbound router\n";
  push @$body, "//                     SystemRAM, SystemROM";
  my $has_default_mem = 0;
  foreach my $devMem (@DeviceMemories) {
    if ($devMem->{'name'} eq '__DefaultMem__') {
      $has_default_mem = 1;
    }
    push @$body, ", $devMem->{'name'}";
  }
  push @$body, (scalar (values %$subSystemL2s) ? ", L2" : "");
  push @$body, (defined $SystemDMA->{'baseAddr'} ? ", SystemDMA" : "");
  push @$body, (scalar (keys %$subSystemMMIOs)) ? ", SubSystemMMIO mmio" : "";
  push @$body, "\n";
  push @$body, "--set_router_parm=routing_table=",
               "\$(XTSC_SCRIPT_FILE_PATH)/BUS_rte.tab\n";
  push @$body, "--set_router_parm=immediate_timing=true\n";
  push @$body, "--set_router_parm=num_slaves=".$numBusRouterSlaves."\n";

  # The bus arbiter always has the same common bus width for the in/out.
  # The pif width conversion, if any, is done at the outbound router and
  # at the inbound arbiter. 

  push @$body, "--set_router_parm=request_fifo_depth=32\n";
  push @$body, "--set_router_parm=response_fifo_depth=32\n";
  push @$body, "--set_router_parm=flexible_request_id=true\n";
  push @$body, "--set_router_parm=default_port_num=".
       ($has_default_mem ? $numBusRouterSlaves-1 : 666)."\n";
  push @$body, "--create_router=BUS_rte${axi_type_str}\n";
  push @$body, "\n";

  push @$body, "// Instantiate the common bus by connecting the BUS ",
                "router and arbiter\n";
  push @$body, "--connect=BUS_arb${axi_type_str},master_port,",
               "slave_port,BUS_rte${axi_type_str}\n";
  push @$body, "\n";
}

# Create multi-channel SystemDMA on the bus
sub generateXTSCSystemDMA {
  my ($body) = @_;
  my $size = $SystemDMA->{'size'}/$SystemDMA->{'numChannels'};
  foreach my $ch (0..$SystemDMA->{'numChannels'}-1) {
    push @$body, "// Create SystemDMA channel $ch\n";
    push @$body, "--set_dma_parm=byte_width=$subSysBusWidth\n";
    push @$body, "--set_dma_parm=overlap_descriptors=true\n";
    push @$body, "--set_dma_parm=clear_notify_value=true\n";
    push @$body, "--set_dma_parm=max_reads=\$(MAX_OUTSTANDING_SYS_DMA_REQ)\n";
    push @$body, "--set_dma_parm=max_writes=\$(MAX_OUTSTANDING_SYS_DMA_REQ)\n";
    push @$body, "--set_dma_parm=reg_base_address=" . 
                 sprintf("0x%x", hex($SystemDMA->{'baseAddr'})+$ch*$size)."\n";
    push @$body, "--set_dma_parm=start_at_index_1=false\n";
    push @$body, "--create_dma=SystemDMAChannel$ch\n";
    push @$body, "\n";
  }

  # For non-AXI subsystem, directly connect the bus rte/arb to the SystemDMA
  # without the transactors
  if (!$subSysMasterProc->{'axi'}) {
    # Create router for all DMA channels
    push @$body, "// Router for SystemDMA channels\n";
    push @$body, "--set_router_parm=routing_table=".
                 "\$(XTSC_SCRIPT_FILE_PATH)/SystemDMA_channel_rte.tab\n";
    push @$body, "--set_router_parm=num_slaves=".
                 $SystemDMA->{'numChannels'}."\n";
    push @$body, "--set_router_parm=default_port_num=666\n";
    push @$body, "--create_router=SystemDMAChannelRte\n";

    # Create an arbiter for all the channels
    push @$body, "\n";
    push @$body, "// Create arbiter for all the SystemDMA channels\n";
    # the out and the in widths are the same common bus width
    push @$body, "--set_arbiter_parm=num_masters=$SystemDMA->{'numChannels'}\n";
    push @$body, "--set_arbiter_parm=route_id_lsb=".
                 "$SYSTEM_DMA_CH_ARB_ROUTE_ID_LSB\n";
    push @$body, "--set_arbiter_parm=slave_byte_width=$subSysBusWidth\n";
    push @$body, "--set_arbiter_parm=master_byte_widths=".
                 join(",", map($subSysBusWidth, 
                               0..$SystemDMA->{'numChannels'}-1))."\n";
    push @$body, "--set_arbiter_parm=arbitration_phase=".
                 "$SYSTEM_DMA_CH_ARB_PHASE\n";
    push @$body, "--create_arbiter=SystemDMAChannelArb\n";

    push @$body, "\n";
    push @$body, "// System DMA connections\n";
    foreach my $ch (0..$SystemDMA->{'numChannels'}-1) {
      push @$body, "--connect=SystemDMAChannelRte,master_port[$ch],".
                   "slave_port,SystemDMAChannel$ch\n";
    }
    foreach my $ch (0..$SystemDMA->{'numChannels'}-1) {
      push @$body, "--connect=SystemDMAChannel$ch,master_port,".
                   "slave_port[$ch],SystemDMAChannelArb\n";
    }
    push @$body, "\n";

    # Create SystemDMA output router
    push @$body, "\n";
    push @$body, "// SystemDMA output router ".
                 "(default to BUS and optionally to SubSystemMMIOs\n";
    # First port to bus, rest to SubSystemMMIOs
    my $num_ports = 1 + scalar (keys %$subSystemMMIOs);
    push @$body, "--set_router_parm=num_slaves=$num_ports\n";
    push @$body, "--set_router_parm=default_port_num=0\n";
    push @$body, "--set_router_parm=routing_table=".
                 "\$(XTSC_SCRIPT_FILE_PATH)/SystemDMA_out_rte.tab\n";
    push @$body, "--set_router_parm=immediate_timing=true\n";
    push @$body, "--create_router=SystemDMAOutRte\n";

    push @$body, "\n";
    push @$body, "--connect=SystemDMAChannelArb,master_port,".
                 "slave_port,SystemDMAOutRte\n";

    push @$body, "\n";
    return;
  }

  # Create SystemDMA output router
  push @$body, "\n";
  push @$body, "// SystemDMA output router ".
               "(default to BUS and optionally to APB\n";
  # First port to bus, rest to SubSystemMMIOs
  my $num_ports = 1 + scalar (keys %$subSystemMMIOs);
  push @$body, "--set_router_parm=num_slaves=$num_ports\n";
  push @$body, "--set_router_parm=default_port_num=0\n";
  push @$body, "--set_router_parm=routing_table=".
               "\$(XTSC_SCRIPT_FILE_PATH)/SystemDMA_out_rte.tab\n";
  push @$body, "--set_router_parm=immediate_timing=true\n";
  push @$body, "--create_router=SystemDMAOutRte\n";

  # Create AXI <-> PIF transactors
  push @$body, "\n";
  push @$body, "// Instantiate the AXI <-> PIF transactors\n";
  push @$body, "--set_xtsc_axi2pif_transactor_parm=axi_byte_width=".
               "$subSysBusWidth\n";
  push @$body, "--create_xtsc_axi2pif_transactor=SystemDMA_AXI2PIF_xtor\n";
  push @$body, "\n";

  push @$body, "--set_xtsc_pif2axi_transactor_parm=".
               "pif_byte_width=$subSysBusWidth\n";
  push @$body, "--set_xtsc_pif2axi_transactor_parm=".
               "axi_byte_width=$subSysBusWidth\n";
  push @$body, "--create_xtsc_pif2axi_transactor=SystemDMA_Bus_PIF2AXI_xtor\n";

  foreach my $smmio (values %$subSystemMMIOs) {
    if (defined $smmio->{'apb'}) {
      # Add PIF2APB
      push @$body, "\n";
      push @$body, "--set_xttlm2tlm2_parm=num_ports=1\n";
      push @$body, "--set_xttlm2tlm2_parm=use_nb_transport=true\n";
      push @$body, "--set_xttlm2tlm2_parm=byte_width=4\n";
      push @$body, "--create_xttlm2tlm2=".
                   "SystemDMA_$smmio->{'name'}_PIF2APB_X2T\n";
      push @$body, "\n";
      push @$body, "--set_tlm22xttlm_parm=num_ports=1\n";
      push @$body, "--set_tlm22xttlm_parm=apb=true\n";
      push @$body, "--set_tlm22xttlm_parm=byte_width=4\n";
      push @$body, "--create_tlm22xttlm=SystemDMA_".
                   "$smmio->{'name'}_PIF2APB_T2X\n";
    } else {
      # Add PIF2AXI
      push @$body, "\n";
      push @$body, "--set_xtsc_pif2axi_transactor_parm=pif_byte_width=4\n";
      push @$body, "--set_xtsc_pif2axi_transactor_parm=axi_byte_width=4\n";
      push @$body, "--create_xtsc_pif2axi_transactor=".
                   "SystemDMA_".$smmio->{'name'}."_PIF2AXI_xtor\n";
    }
  }

  # Create router for all DMA channels
  push @$body, "\n";
  push @$body, "// Router for SystemDMA channels\n";
  push @$body, "--set_router_parm=routing_table=".
               "\$(XTSC_SCRIPT_FILE_PATH)/SystemDMA_channel_rte.tab\n";
  push @$body, "--set_router_parm=num_slaves=".$SystemDMA->{'numChannels'}."\n";
  push @$body, "--set_router_parm=default_port_num=666\n";
  push @$body, "--create_router=SystemDMAChannelRte\n";

  # Create an arbiter for all the channels
  push @$body, "\n";
  push @$body, "// Create arbiter for all the SystemDMA channels\n";
  # the out and the in widths are the same common bus width
  push @$body, "--set_arbiter_parm=num_masters=$SystemDMA->{'numChannels'}\n";
  push @$body, "--set_arbiter_parm=route_id_lsb=".
               "$SYSTEM_DMA_CH_ARB_ROUTE_ID_LSB\n";
  push @$body, "--set_arbiter_parm=slave_byte_width=$subSysBusWidth\n";
  push @$body, "--set_arbiter_parm=master_byte_widths=".
               join(",", map($subSysBusWidth, 
                             0..$SystemDMA->{'numChannels'}-1))."\n";
  push @$body, "--set_arbiter_parm=arbitration_phase=".
               "$SYSTEM_DMA_CH_ARB_PHASE\n";
  push @$body, "--create_arbiter=SystemDMAChannelArb\n";

  push @$body, "\n";
  push @$body, "// System DMA connections\n";
  push @$body, "--connect=SystemDMA_AXI2PIF_xtor,master_port,".
               "slave_port,SystemDMAChannelRte\n";
  foreach my $ch (0..$SystemDMA->{'numChannels'}-1) {
    push @$body, "--connect=SystemDMAChannelRte,master_port[$ch],".
                 "slave_port,SystemDMAChannel$ch\n";
  }
  foreach my $ch (0..$SystemDMA->{'numChannels'}-1) {
    push @$body, "--connect=SystemDMAChannel$ch,master_port,".
                 "slave_port[$ch],SystemDMAChannelArb\n";
  }
  push @$body, "--connect=SystemDMAChannelArb,master_port,".
               "slave_port,SystemDMAOutRte\n";

  my $numAPBssmio = 0;
  foreach my $smmio (values %$subSystemMMIOs) {
    if (defined $smmio->{'apb'}) {
      $numAPBssmio++;
    }
  }

  # First port to bus
  push @$body, "--connect=SystemDMAOutRte,master_port[0],".
               "slave_port,SystemDMA_Bus_PIF2AXI_xtor\n";
  my $port = 1;
  # Rest to SubSystemMMIOs
  foreach my $smmio (values %$subSystemMMIOs) {
    if (defined $smmio->{'apb'}) {
      push @$body, "--connect=SystemDMAOutRte,master_port[$port],".
                   "slave_port,SystemDMA_$smmio->{'name'}_PIF2APB_X2T\n";
      push @$body, 
           "--connect=SystemDMA_$smmio->{'name'}_PIF2APB_X2T,initiator_socket,".
           "target_socket,SystemDMA_$smmio->{'name'}_PIF2APB_T2X\n";
    } else {
      push @$body, "--connect=SystemDMAOutRte,master_port[$port],".
                   "slave_port,SystemDMA_$smmio->{'name'}_PIF2AXI_xtor\n";
    }
    $port++;
  }
  push @$body, "\n";
}

# Create numArbiters arbiters for the numArbiters L2 slave arbiter ports
# for arbitrating across numMastersPerArbiter core dma connections
sub generateXTSCL2InboundArbiter {
  my ($body, $numArbiters, $numCoreArbiters, $numMastersPerArbiter, 
      $axi_type, $l2) = @_;
  my $axi_type_str = ($axi_type ne "" ? "${axi_type}_" : $axi_type);
  my $axi_type_str1 = ($axi_type ne "" ? "_${axi_type}" : $axi_type);

  # Create the slave L2 arbiter
  push @$body, "// Create $l2->{'name'} inbound arbiters\n";
  foreach my $port (0..$numArbiters-1) {
    # The arbiter for the first port will also service the bus request
    my $nmpa = $port == 0 ? $numMastersPerArbiter + 1 : $numMastersPerArbiter;

    push @$body, "// Create $l2->{'name'} inbound arbiter $port\n";
    push @$body, "--set_arbiter_parm=num_masters=$nmpa\n";
    if ($nmpa == 1) {
      push @$body, "--set_arbiter_parm=immediate_timing=true\n";
    } else {
      push @$body, "--set_arbiter_parm=arbitration_phase=$L2_ARB_PHASE\n";
    }
    push @$body, "--set_arbiter_parm=route_id_lsb=$L2_ARB_ROUTE_ID_LSB\n";
    push @$body, "--set_arbiter_parm=nacc_wait_time=$L2_ARB_NACC_WAIT_TIME\n";
    push @$body, "--create_arbiter=$l2->{'name'}_${axi_type_str}arb${port}\n";
    push @$body, "\n";
  }

  # Connect the arbiter to the L2 port
  push @$body, "// Connect $l2->{'name'} inbound arbiters\n";
  foreach my $num (0..$numArbiters-1) {
    if ($l2->{'isL2CC'}) {
      push @$body, "--connect=$l2->{'name'}_${axi_type_str}arb${num},",
                   "master_port,slave${num}${axi_type_str1},$l2->{'name'}\n";
    } else {
      # For non-L2CC, adjust for the ports to L2 from the core.
      my $port = $axi_type eq "" ? ($num + $numCoreArbiters)
                                 : (($num + $numCoreArbiters)*2+
                                    ($axi_type eq "rd" ? 0 : 1));
      push @$body, "--connect=$l2->{'name'}_${axi_type_str}arb${num},",
                   "master_port,slave_port[$port],$l2->{'name'}\n";
    }
  }
  push @$body, "\n";
}

# Create numArbiters arbiters to service the numArbiters core ports of the L2 
# by arbitrating across all numMastersPerArbiter cores per arbiter.
sub generateXTSCL2CoreArbiter {
  my ($body, $numArbiters, $numMastersPerArbiter, $axi_type, $l2) = @_;
  my $axi_type_str = ($axi_type ne "" ? "${axi_type}_" : $axi_type);

  # Create the arbiters
  push @$body, "// Create $l2->{'name'} core arbiters\n";
  foreach my $port (0..$numArbiters-1) {
    push @$body, "// Create $l2->{'name'} core arbiter $port\n";
    push @$body, "--set_arbiter_parm=num_masters=$numMastersPerArbiter\n";
    if ($numMastersPerArbiter == 1) {
      push @$body, "--set_arbiter_parm=immediate_timing=true\n";
    } else {
      push @$body, "--set_arbiter_parm=arbitration_phase=$L2_ARB_PHASE\n";
    }
    push @$body, "--set_arbiter_parm=route_id_lsb=$L2_ARB_ROUTE_ID_LSB\n";
    push @$body, "--create_arbiter=",
                 "$l2->{'name'}_core_${axi_type_str}arb${port}\n";
    push @$body, "\n";
  }

  # Connect arbiter to L2 port
  push @$body, "// Connect $l2->{'name'} core arbiters\n";
  foreach my $num (0..$numArbiters-1) {
    my $port = $axi_type eq "" ? $num 
                               : $num*2+($axi_type eq "rd" ? 0 : 1);
    push @$body, "--connect=$l2->{'name'}_core_${axi_type_str}arb${num},",
                 "master_port,slave_port[$port],$l2->{'name'}\n";
  }
  push @$body, "\n";
}

# Create router for bus to L2 
sub generateXTSCL2BusRouter {
  my ($body, $axi_type, $l2) = @_;
  my $axi_type_str = ($axi_type ne "" ? "${axi_type}_" : $axi_type);

  push @$body, "// Create $l2->{'name'} bus $axi_type router\n";
  push @$body, "--set_router_parm=num_slaves=1\n";
  if ($l2->{'dataWidth'} != $subSysBusWidth) {
    push @$body, "--set_router_parm=master_byte_width=$subSysBusWidth\n";
    push @$body, "--set_router_parm=slave_byte_widths=$l2->{'dataWidth'}\n";
  } else {
    push @$body, "--set_router_parm=immediate_timing=true\n";
  }
  push @$body, "--create_router=$l2->{'name'}_bus_${axi_type_str}rte\n";
  push @$body, "\n";

  # Bus is connected to port 0 of the first L2 arbiter
  push @$body, "// Connect $l2->{'name'} bus $axi_type router to ",
               "$l2->{'name'} mem\n";
  my $dest_port = 0;
  push @$body, "--connect=$l2->{'name'}_bus_${axi_type_str}rte,",
               "master_port[0],slave_port[$dest_port],",
               "$l2->{'name'}_${axi_type_str}arb0\n";
  push @$body, "\n";
}

# Create a XTSC L2CC or a XTSC memory L2
sub generateXTSCL2 {
  my ($body, $l2, $mem_config, $xtsc_run_gen_dir) = @_;
  push @$body, "// Create $l2->{'name'}\n";
  my $axi_type = $subSysMasterProc->{'axi'} ? "rd" : "";
  my $axi_type_str = ($axi_type ne "" ? "${axi_type}_" : $axi_type);
  if (!$l2->{'isL2CC'}) {
    # L2-RAM case
    $l2->{'numBanks'} == 1 or die "Multi-bank L2 RAM not supported\n";
    # For a L2 RAM, create a xtsc memory
    my $numL2masters = $l2->{'numPorts'} + $l2->{'numCorePorts'};
    # For axi, add separate ports for read and write
    # Bus ports come first followed by the cores
    $numL2masters *= ($subSysMasterProc->{'axi'} ? 2 : 1);
    push @$body, "--memory_port=" . 
         ($mem_config->{'pipeline'} eq 'NX' ? 'axi' : 'pif') . "\n";
    push @$body, "--set_memory_parm=num_ports=$numL2masters\n";
    push @$body, "--set_memory_parm=byte_width=$l2->{'dataWidth'}\n";
    push @$body, "--set_memory_parm=start_byte_address=$l2->{'localAddr'}\n";
    push @$body, "--set_memory_parm=memory_byte_size=$l2->{'size'}\n";
    push @$body, "#ifdef ".uc($l2->{'name'})."_PROFILE\n";
    push @$body, "--set_memory_parm=interval_size=\$(".
                 uc($l2->{'name'})."_PROFILE_INTERVAL)\n";
    push @$body, "--set_memory_parm=summary=true\n";
    push @$body, "#endif\n";
    push @$body, "--set_memory_parm=read_delay=\$(".
                 uc($l2->{'name'})."_READ_DELAY)\n";
    push @$body, "--set_memory_parm=block_read_delay=\$(".
                 uc($l2->{'name'})."_READ_DELAY)\n";
    push @$body, "--set_memory_parm=burst_read_delay=\$(".
                 uc($l2->{'name'})."_READ_DELAY)\n";
    push @$body, "--set_memory_parm=block_read_repeat=$l2->{'read_repeat'}\n";
    push @$body, "--set_memory_parm=burst_read_repeat=$l2->{'read_repeat'}\n";
    push @$body, "--set_memory_parm=write_delay=\$(".
                 uc($l2->{'name'})."_WRITE_DELAY)\n";
    push @$body, "--set_memory_parm=block_write_delay=\$(".
                 uc($l2->{'name'})."_WRITE_DELAY)\n";
    push @$body, "--set_memory_parm=burst_write_delay=\$(".
                 uc($l2->{'name'})."_WRITE_DELAY)\n";
    push @$body, "--set_memory_parm=block_write_repeat=$l2->{'write_repeat'}\n";
    push @$body, "--set_memory_parm=burst_write_repeat=$l2->{'write_repeat'}\n";
    push @$body, "--set_memory_parm=block_write_response=\$(".
                 uc($l2->{'name'})."_WRITE_RESPONSE)\n";
    push @$body, "--set_memory_parm=burst_write_response=\$(".
                 uc($l2->{'name'})."_WRITE_RESPONSE)\n";
    push @$body, "--set_memory_parm=request_fifo_depth=",
                 "\$(".uc($l2->{'name'})."_REQUEST_FIFO_DEPTH)\n";
    if ($l2->{'host_shared'}) {
      push @$body, "--set_memory_parm=host_shared_memory=true\n";
      push @$body, "--set_memory_parm=shared_memory_name=",
                   "\$(".uc($l2->{'name'})."_NAME)\n";
    }
    push @$body, "--create_memory=$l2->{'name'}\n";
    push @$body, "\n";

    if ($l2->{'numPorts'}) {
      # For L2 slave ports, find the number of dma/xnne masters
      my $numProcL2Masters = 0;
      foreach my $pid (@{$subSysInterconnectFrom->{$l2->{'id'}}}) {
        if (isProcId($pid)) {
          my $proc = $procIdMap->{$pid};
          if ((defined $proc->{'idma'} and !$proc->{'idma'}->{'shared'}) or
              (defined $proc->{'sdma'} and !$proc->{'sdma'}->{'shared'})) {
            $numProcL2Masters++;
          }
        } else {
          $numProcL2Masters += 
                    @{$xnneIdMap->{$pid}->{'masterCompMap'}->{$l2->{'id'}}};
        }
      }
      # Generate arbiters to arbitrate for the L2 slave ports. For non-L2CC,
      # adjust the port number based on the core ports. L2CC, on the other hand,
      # has specially named ports for the core.
      generateXTSCL2InboundArbiter($body, $l2->{'numPorts'}, 
                                   $l2->{'numCorePorts'},
                                   $numProcL2Masters/$l2->{'numPorts'},
                                   ($subSysMasterProc->{'axi'} ? "rd" : ""), 
                                   $l2);
      if ($subSysMasterProc->{'axi'}) {
        generateXTSCL2InboundArbiter($body, $l2->{'numPorts'}, 
                                     $l2->{'numCorePorts'},
                                     $numProcL2Masters/$l2->{'numPorts'}, "wr",
                                     $l2);
      }
    }

    if ($l2->{'numCorePorts'}) {
      # For L2 core ports, find the number of core masters
      my $numProcL2Masters = grep { isProcId($_) }
                             @{$subSysInterconnectFrom->{$l2->{'id'}}};
      # Generate arbiters to arbitrate for the L2 core ports
      generateXTSCL2CoreArbiter($body, $l2->{'numCorePorts'}, 
                                $numProcL2Masters/$l2->{'numCorePorts'},
                                ($subSysMasterProc->{'axi'} ? "rd" : ""), $l2);
      if ($subSysMasterProc->{'axi'}) {
        generateXTSCL2CoreArbiter($body, $l2->{'numCorePorts'}, 
                                 $numProcL2Masters/$l2->{'numCorePorts'}, "wr",
                                 $l2);
      }
    }
    
    # Connect bus to the first slave port. Note, we only allow one
    # connection from the bus.
    generateXTSCL2BusRouter($body, ($subSysMasterProc->{'axi'} ? "rd" : ""), 
                            $l2);
    if ($subSysMasterProc->{'axi'}) {
      generateXTSCL2BusRouter($body, "wr", $l2);
    }
  } else {
    # For L2-CC
    push @$body, "--set_xtsc_l2cc_parm=cache_byte_size=$l2->{'size'}\n";
    if (defined $l2->{'lineSize'}) {
      push @$body, "--set_xtsc_l2cc_parm=line_byte_size=$l2->{'lineSize'}\n";
    }
    if (defined $l2->{'numWays'}) {
      push @$body, "--set_xtsc_l2cc_parm=num_ways=$l2->{'numWays'}\n";
    }
    push @$body, "--set_xtsc_l2cc_parm=control_reg_address=",
                 "$l2->{'controlRegAddr'}\n";
    push @$body, "--set_xtsc_l2cc_parm=reset_tcm_base_address=",
                 "$l2->{'localAddr'}\n";
    push @$body, "--set_xtsc_l2cc_parm=core_inst_byte_width=",
                 "$l2->{'instWidth'}\n";
    push @$body, "--set_xtsc_l2cc_parm=core_data_byte_width=",
                 "$l2->{'dataWidth'}\n";
    push @$body, "--set_xtsc_l2cc_parm=master_byte_width=",
                 "$l2->{'masterWidth'}\n";
    push @$body, "--set_xtsc_l2cc_parm=slave_byte_width=$l2->{'slaveWidth'}\n";
    #push @$body, "--set_xtsc_l2cc_parm=has_l2_error=0\n";
    push @$body, "--set_xtsc_l2cc_parm=connect_slave_interface=true\n";
    push @$body, "--set_xtsc_l2cc_parm=num_cores=".
                 (scalar @{$subSysInterconnectFrom->{$l2->{'id'}}})."\n";
    push @$body, "--set_xtsc_l2cc_parm=support_multicore=true\n";
    if ($l2->{'coherent'}) {
      push @$body, "--set_xtsc_l2cc_parm=has_coherency_controller=1\n";
      push @$body, "--set_xtsc_l2cc_parm=l2ram_coherent=1\n";
    }
    if ($l2->{'ramOnly'}) {
      push @$body, "--set_xtsc_l2cc_parm=l2ram_only=1\n";
    }
    push @$body, "--set_xtsc_l2cc_parm=num_slaves=$l2->{'numPorts'}\n";
    push @$body, "--set_xtsc_l2cc_parm=core_port_muxing=".
                 "$l2->{'numCorePorts'}\n";
    if (defined $l2->{'numExclusives'}) {
      push @$body, 
           "--set_xtsc_l2cc_parm=num_exclusives=$l2->{'numExclusives'}\n";
    } else {
      push @$body, "--set_xtsc_l2cc_parm=num_exclusives=".
                   (scalar @{$subSysInterconnectFrom->{$l2->{'id'}}})."\n";
    }
    if (defined $l2->{'cacheLineSize'}) {
      push @$body, 
           "--set_xtsc_l2cc_parm=line_byte_size=$l2->{'cacheLineSize'}\n";
    }
    if ($l2->{'ramOnly'} and $l2->{'host_shared'} == 1) { 
      push @$body, "--set_xtsc_l2cc_parm=host_shared_memory=true\n";
      push @$body, "--set_xtsc_l2cc_parm=shared_memory_name=\$(".
                   uc($l2->{'name'})."_NAME)\n";
    }
    push @$body, "--create_xtsc_l2cc=$l2->{'name'}\n";
    push @$body, "\n";

    if ($l2->{'numPorts'}) {
      # For L2 slave ports, find the number of dma masters
      my $numProcL2Masters = 0;
      foreach my $pid (@{$subSysInterconnectFrom->{$l2->{'id'}}}) {
        my $proc = $procIdMap->{$pid};
        if ((defined $proc->{'idma'} and !$proc->{'idma'}->{'shared'}) or
            (defined $proc->{'sdma'} and !$proc->{'sdma'}->{'shared'})) {
          $numProcL2Masters++;
        }
      }
      # Generate arbiters to arbitrate for the L2 slave ports. For non-L2CC,
      # adjust the port number based on the core ports. L2CC, on the other hand,
      # has specially named ports for the core.
      generateXTSCL2InboundArbiter($body, $l2->{'numPorts'}, 
                                   0,
                                   $numProcL2Masters/$l2->{'numPorts'},
                                   ($subSysMasterProc->{'axi'} ? "rd" : ""),
                                   $l2);
      if ($subSysMasterProc->{'axi'}) {
        generateXTSCL2InboundArbiter($body, $l2->{'numPorts'}, 
                                     0,
                                     $numProcL2Masters/$l2->{'numPorts'}, "wr",
                                     $l2);
      }
      # Note, there are no core arbiters for L2-CC. The core data/inst ports
      # go directly to the L2CC and the muxing is done internal to L2CC
    }
  }

  # Connect PWaitMode  
  if ($l2->{'isL2CC'}) {
    push @$body, "// Connect core PWaitMode to L2\n";
    push @$body, "--set_logic_parm=definition_file=".
                 "\$(XTSC_SCRIPT_FILE_PATH)/$l2->{'name'}_pwait.def\n";
    push @$body, "--create_logic=$l2->{'name'}_pwait_logic\n";
    push @$body, "\n";
    # logic
    my $pwait_logic_file = "$xtsc_run_gen_dir/$l2->{'name'}_pwait.def\n";
    open(pwait_logic_file, ">$pwait_logic_file") or 
        sysBuildError("Could not open $pwait_logic_file\n");

    print pwait_logic_file 
      "/* <input>  <Name>   <BitWidth>  <InitValue>  */\n\n";
    foreach my $pid (sort {$a<=>$b} @{$subSysInterconnectFrom->{$l2->{'id'}}}) {
      my $proc = $procIdMap->{$pid};
      print pwait_logic_file "input $proc->{'name'}_pwait 1 0\n";
    }
    print pwait_logic_file "\n";
    print pwait_logic_file 
      "/* <output>  <Name>   <BitWidth>  <InitValue>  */\n\n";
    foreach my $pid (sort {$a<=>$b} @{$subSysInterconnectFrom->{$l2->{'id'}}}) {
      my $proc = $procIdMap->{$pid};
      print pwait_logic_file "output $l2->{'name'}_$proc->{'name'}_pwait 1 0\n";
    }
    print pwait_logic_file "\n";
    foreach my $pid (sort {$a<=>$b} @{$subSysInterconnectFrom->{$l2->{'id'}}}) {
      my $proc = $procIdMap->{$pid};
      print pwait_logic_file "assign $l2->{'name'}_$proc->{'name'}_pwait = ".
                             "$proc->{'name'}_pwait\n";
    }
    close pwait_logic_file;
  }
}

# Create memories on bus
sub generateXTSCSystemMemory {
  my ($body, $name, $mem, $mem_config) = @_;
  push @$body, "// Create $name\n";
  # For axi, use 2 axi ports - read and write
  push @$body, "--memory_port=" . 
       ($mem_config->{'pipeline'} eq 'NX' ? 'axi' : 'pif') . "\n";
  push @$body, "--set_memory_parm=num_ports=".
               ($subSysMasterProc->{'axi'} ? '2' : '1')."\n";
  push @$body, "--set_memory_parm=byte_width=$subSysBusWidth\n";
  push @$body, "--set_memory_parm=start_byte_address=$mem->{'globalAddr'}\n";
  push @$body, "--set_memory_parm=memory_byte_size=$mem->{'size'}\n";
  push @$body, "#ifdef ".uc($mem->{'name'})."_PROFILE\n";
  push @$body, "--set_memory_parm=interval_size=\$(".
               uc($mem->{'name'})."_PROFILE_INTERVAL)\n";
  push @$body, "--set_memory_parm=summary=true\n";
  push @$body, "#endif\n";
  push @$body, "--set_memory_parm=clock_period=\$(".
               uc($mem->{'name'})."_CLOCK)\n";
  push @$body, "--set_memory_parm=read_delay=\$(".
               uc($mem->{'name'})."_READ_DELAY)\n";
  push @$body, "--set_memory_parm=block_read_delay=\$(".
               uc($mem->{'name'})."_READ_DELAY)\n";
  push @$body, "--set_memory_parm=burst_read_delay=\$(".
               uc($mem->{'name'})."_READ_DELAY)\n";
  push @$body, "--set_memory_parm=block_read_repeat=$mem->{'read_repeat'}\n";
  push @$body, "--set_memory_parm=burst_read_repeat=$mem->{'read_repeat'}\n";
  push @$body, "--set_memory_parm=write_delay=\$(".
               uc($mem->{'name'})."_WRITE_DELAY)\n";
  push @$body, "--set_memory_parm=block_write_delay=\$(".
               uc($mem->{'name'})."_WRITE_DELAY)\n";
  push @$body, "--set_memory_parm=burst_write_delay=\$(".
               uc($mem->{'name'})."_WRITE_DELAY)\n";
  push @$body, "--set_memory_parm=block_write_repeat=$mem->{'write_repeat'}\n";
  push @$body, "--set_memory_parm=burst_write_repeat=$mem->{'write_repeat'}\n";
  push @$body, "--set_memory_parm=block_write_response=\$(".
               uc($mem->{'name'})."_WRITE_RESPONSE)\n";
  push @$body, "--set_memory_parm=burst_write_response=\$(".
               uc($mem->{'name'})."_WRITE_RESPONSE)\n";
  push @$body, "--set_memory_parm=request_fifo_depth=\$(".
               uc($mem->{'name'})."_REQUEST_FIFO_DEPTH)\n";
  if ($mem->{'host_shared'} == 1) {
    push @$body, "--set_memory_parm=host_shared_memory=true\n";
    push @$body, "--set_memory_parm=shared_memory_name=\$(" . uc($name) 
                                                            . "_NAME)\n";
  }
  push @$body, "--create_memory=$name\n";
  push @$body, "\n";
}

# Arbitrate for InstRAM
sub generateXTSCInstRamArbiters {
  my ($body, $proc, $iram_id, $route_id_lsb) = @_;
  if ($proc->{'pipeline'} eq 'NX') {
    return;
  }
  #if (!defined $proc->{'sharedLmemCid'}) {
  #  return;
  #}
  my $iram = ($iram_id == $IRAM0 ? $proc->{'instRam0'} : $proc->{'instRam1'});
  push @$body, "// Create $proc->{'name'} INSTRAM$iram_id arbiters\n";
  push @$body, "--set_arbiter_parm=num_masters=1\n";
  push @$body, "--set_arbiter_parm=route_id_lsb=$route_id_lsb\n";
  push @$body, "--set_arbiter_parm=immediate_timing=true\n";
  push @$body, "--set_arbiter_parm=response_delay=0\n";
  push @$body, "--create_arbiter=$proc->{'name'}_INSTRAM${iram_id}_arb\n";
  push @$body, "\n";
  push @$body, "// Connect $proc->{'name'} INSTRAM$iram_id ".
               "port to the INSTRAM$iram_id arbiters\n";
  push @$body, "--connect=$proc->{'name'},iram${iram_id},".
               "slave_port[0],$proc->{'name'}_INSTRAM${iram_id}_arb\n";
  push @$body, "// Connect $proc->{'name'} INSTRAM$iram_id ".
              "arbiter to INSTRAM$iram_id\n";
  push @$body, "--connect=$proc->{'name'}_INSTRAM${iram_id}_arb,".
               "master_port,slave_port,$proc->{'name'}_INSTRAM${iram_id}\n";
  push @$body, "\n";
}

# Create an arbiter per dataram bank. Each arbiter is mastered by all the
# corresponding port from the core (dram0p0, dram0p1, etc.) and the uDMA, 
# if present.
sub generateXTSCDataRamArbiters {
  my ($body, $proc, $dram_id, $route_id_lsb) = @_;
  if ($proc->{'pipeline'} eq 'NX') {
    return;
  }
  #if (!defined $proc->{'sharedLmemCid'} and !defined $proc->{'udma'}) {
  #  return;
  #}
  my $dram = ($dram_id == $DRAM0 ? $proc->{'dataRam0'} : $proc->{'dataRam1'});
  my $num_arb_masters;
  if (defined $proc->{'sharedLmemCid'}) {
    my $cid = $proc->{'sharedLmemCid'};
    $num_arb_masters = @{$sharedLocalMemClusterMap->{$cid}};
  } else {
    $num_arb_masters = 1 + (defined $proc->{'udma'} ? 1 : 0);
  }
  push @$body, "// Create $proc->{'name'} DATARAM$dram_id arbiters\n";
  foreach my $b (0..$dram->{'numBanks'}-1) {
    foreach my $sb (0..$dram->{'numSubBanks'}-1) {
      push @$body, "// Create $proc->{'name'}_DATARAM$dram_id ".
                   "bank $b sub-bank $sb arbiter\n";
      push @$body, "--set_arbiter_parm=num_masters=$num_arb_masters\n";
      push @$body, "--set_arbiter_parm=route_id_lsb=$route_id_lsb\n";
      push @$body, "--set_arbiter_parm=response_delay=0\n";
      if (defined $proc->{'sharedLmemCid'} && $num_arb_masters > 1) {
        push @$body, "--set_arbiter_parm=dram_lock=true\n";
      }
      if ($num_arb_masters == 1) {
        push @$body, "--set_arbiter_parm=immediate_timing=true\n";
      }
      # The uDMA gets the highest priority
      if (defined $proc->{'udma'}) {
        push @$body, "--set_arbiter_parm=arbitration_policy=".
                     join(";", map("1,1,0", 0..$num_arb_masters-2)).";0,0,0\n";
      }
      push @$body, "--create_arbiter=$proc->{'name'}_".
                   "DATARAM${dram_id}_b${b}_s${sb}_arb\n";
      push @$body, "\n";
    }
  }
  push @$body, "// Connect $proc->{'name'} dram$dram_id ".
               "ports to DATARAM$dram_id arbiter\n";
  # For 1-bank datarams, use dram0, dram1 without the port suffix
  if ($dram->{'numBanks'} == 1) {
    push @$body, "--connect=$proc->{'name'},dram${dram_id},".
                 "slave_port[0],$proc->{'name'}_DATARAM${dram_id}_b0_s0_arb\n";
  } elsif ($dram->{'numSubBanks'} == 1) {
    foreach my $b (0..$dram->{'numBanks'}-1) {
      push @$body, "--connect=$proc->{'name'},dram${dram_id}p${b},".
                   "slave_port[0],".
                   "$proc->{'name'}_DATARAM${dram_id}_b${b}_s0_arb\n";
    }
  } else {
    foreach my $b (0..$dram->{'numBanks'}-1) {
      foreach my $sb (0..$dram->{'numSubBanks'}-1) {
        my $nsb = $sb < 10 ? "0".$sb : $sb;
        push @$body, "--connect=$proc->{'name'},dram${dram_id}b${b}s$nsb,".
                     "slave_port[0],".
                     "$proc->{'name'}_DATARAM${dram_id}_b${b}_s${sb}_arb\n";
      }
    }
  }
  push @$body, "// Connect $proc->{'name'} DATARAM$dram_id ".
               "arbiters to DATARAM$dram_id ports\n";
  foreach my $b (0..$dram->{'numBanks'}-1) {
    foreach my $sb (0..$dram->{'numSubBanks'}-1) {
      push @$body, "--connect=$proc->{'name'}_DATARAM".
                   "${dram_id}_b${b}_s${sb}_arb,master_port,".
                   "slave_port[".($b*$dram->{'numSubBanks'}+$sb)."],".
                   "$proc->{'name'}_DATARAM${dram_id}\n";
    }
  }
  push @$body, "\n";
}

sub generateXTSCSharedLmemDataRamArbiterInterconnect {
  my ($body, $proc, $cluster_proc, $cid, $dram_id, $route_id_lsb) = @_;
  push @$body, "// Connect $proc->{'name'} dram$dram_id ports to ".
               "$cluster_proc->{'name'}'s DATARAM$dram_id arbiter\n";
  my $dram = ($dram_id == $DRAM0 ? $cluster_proc->{'dataRam0'} 
                                 : $cluster_proc->{'dataRam1'});
  my $num_procs_in_cluster = @{$sharedLocalMemClusterMap->{$cid}};
  my @idxs = grep { ${$sharedLocalMemClusterMap->{$cid}}[$_] == $proc } 
             0 .. $num_procs_in_cluster-1;
  my $arb_port = $idxs[0];
  # For 1-bank datarams, use dram0, dram1 without the port suffix
  if ($dram->{'numBanks'} == 1) {
    push @$body, "--connect=$proc->{'name'},dram${dram_id},".
                 "slave_port[$arb_port],".
                 "$cluster_proc->{'name'}_DATARAM${dram_id}_b0_s0_arb\n";
  } elsif ($dram->{'numSubBanks'} == 1) {
    foreach my $b (0..$dram->{'numBanks'}-1) {
      push @$body, "--connect=$proc->{'name'},dram${dram_id}p${b},".
                   "slave_port[$arb_port],".
                   "$cluster_proc->{'name'}_DATARAM${dram_id}_b${b}_s0_arb\n";
    }
  } else {
    foreach my $b (0..$dram->{'numBanks'}-1) {
      foreach my $sb (0..$dram->{'numSubBanks'}-1) {
        my $nsb = $sb < 10 ? "0".$sb : $sb;
        push @$body, 
             "--connect=$proc->{'name'},".
             "dram${dram_id}b${b}s${nsb},slave_port[$arb_port],".
             "$cluster_proc->{'name'}_DATARAM${dram_id}_b${b}_s${sb}_arb\n";
      }
    }
  }
  push @$body, "\n";
}

# Create routers to route request to either of the
# banks for a particular dataram using address routing bits to do the
# low order interleaving.
sub createXTSCudmaDataRAMBankRouters {
  my ($body, $proc, $dram_id) = @_;
  my $dram = ($dram_id == $DRAM0 ? $proc->{'dataRam0'} : $proc->{'dataRam1'});
  push @$body, "// Create uDMA DATARAM$dram_id bank router\n";
  push @$body, "--set_router_parm=num_slaves=$dram->{'numBanks'}\n";
  my $sb = log($proc->{'dataRamFetchWidth'})/log(2);
  my $sn = log($dram->{'numBanks'})/log(2);
  if ($dram->{'numBanks'} != 1) {
    if ($dram->{'numBanks'} == 2) {
      push @$body, "--set_router_parm=address_routing_bits=$sb,$sb\n";
    } else {
      push @$body, "--set_router_parm=address_routing_bits=".
                   join(",",map("$_",reverse $sb..$sb+$sn-1))."\n";
    }
    push @$body, "--set_router_parm=master_byte_width=".
                 "$proc->{'dataRamFetchWidth'}\n";
  }
  push @$body, "--set_router_parm=immediate_timing=true\n";
  push @$body, 
       "--create_router=$proc->{'name'}_udma_dataram${dram_id}_bank_rte\n";
  push @$body, 
       "// Connect the first level $proc->{'name'} uDMA router to the\n";
  push @$body, "// second level uDMA DATARAM$dram_id bank router\n";
  push @$body, "--connect=$proc->{'name'}_udma_rte,master_port[$dram_id],".
               "slave_port,$proc->{'name'}_udma_dataram${dram_id}_bank_rte\n";
  push @$body, "// Connect the uDMA DATARAM$dram_id bank router to ".
               "DATARAM${dram_id}'s bank arbiters\n";
  my $router_port = 0; 
  foreach my $b (0..($dram->{'numBanks'}-1)) {
    push @$body, "--connect=$proc->{'name'}_udma_dataram${dram_id}_bank_rte,".
                 "master_port[$router_port],slave_port[1],".
                 "$proc->{'name'}_DATARAM${dram_id}_b${b}_s0_arb\n";
    $router_port++;
  }
}

# The uDMA requests are routed using 2 sets of routers - one which directs
# to dataram0 or dataram1. This request is further routed to either of the
# banks for a particular dataram using address routing bits to do the
# low order interleaving.
sub connectXTSCudma {
  my ($body, $proc) = @_;

  push @$body, "// Connect $proc->{'name'} uDMA to DataRAMs\n";
  push @$body, "// Create first level $proc->{'name'} uDMA router to ".
               "route to the DATARAMs\n";
  push @$body, "--set_router_parm=routing_table=".
               "\$(XTSC_SCRIPT_FILE_PATH)/$proc->{'name'}_udma_rte.tab\n";
  push @$body, "--set_router_parm=num_slaves=".
               (defined $proc->{'dataRam1'} ? "2" : "1")."\n";
  push @$body, "--set_router_parm=immediate_timing=true\n";
  push @$body, "--set_router_parm=default_port_num=666\n";
  push @$body, "--create_router=$proc->{'name'}_udma_rte\n";
  push @$body, "// Connect $proc->{'name'} uDMA\n";
  push @$body, "--connect=$proc->{'name'}_uDMA,ram_master_port,".
               "slave_port,$proc->{'name'}_udma_rte\n";
  push @$body, "// Create second level $proc->{'name'} uDMA routers to ".
               "route to the DATARAM banks\n";
  createXTSCudmaDataRAMBankRouters($body, $proc, 0);
  if (defined $proc->{'dataRam1'}) {
    createXTSCudmaDataRAMBankRouters($body, $proc, 1);
  }
  push @$body, "// Connect the uDMA sync and error interrupt\n";
  push @$body, "// Connect to $proc->{'name'}'s RER/WER interface\n";
  push @$body, "--connect=$proc->{'name'}_uDMA,sync_intr_port,BInterrupt".
               ($proc->{'udma'}->{'syncBIntr'} < 10 
                  ? "0".$proc->{'udma'}->{'syncBIntr'} 
                  : $proc->{'udma'}->{'syncBIntr'}).
               ",$proc->{'name'}\n";
  push @$body, "--connect=$proc->{'name'}_uDMA,error_intr_port,BInterrupt".
               ($proc->{'udma'}->{'errorBIntr'} < 10 
                  ? "0".$proc->{'udma'}->{'errorBIntr'} 
                  : $proc->{'udma'}->{'errorBIntr'}).
               ",$proc->{'name'}\n";
  # Set the lookup port to the uDMA name prefix based on the config
  my $lookup_prefix = $proc->{'udma'}->{'lookupPort'};
  push @$body, "--connect=$proc->{'name'},${lookup_prefix}_RER,".
               "rer_export,$proc->{'name'}_uDMA\n";
  push @$body, "--connect=$proc->{'name'},${lookup_prefix}_WER,".
               "wer_export,$proc->{'name'}_uDMA\n";
  push @$body, "\n";
}

# Connect the bus to the SystemRAM, ROM, device memories, L2, SubSystemMMIO
# arbiters, SubSystem interfaces, SystemDMA
sub connectXTSCBusRouter {
  my ($body, $axi_type) = @_;
  my $axi_type_str = ($axi_type ne "" ? "_${axi_type}" : $axi_type);
  my $axi_type_str1 = ($axi_type ne "" ? "${axi_type}_" : $axi_type);

  my $bus_rte_port = 0;

  # Find unique interfaces for procs with connection from bus
  my $intf = {};
  foreach my $id (@{$subSysInterconnectTo->{$COMMON_BUS_ID}}) {
    if (isProcId($id)) {
      $intf->{$procIdMap->{$id}->{'extIntfId'}} = 1;
    } else {
      $intf->{$xnneIdMap->{$id}->{'extIntfId'}} = 1;
    }
  }

  # Connect the bus to the subsystem inbound interface
  push @$body, "// Connect the common BUS $axi_type router to ",
               "SubSystem inbounds \n";
  foreach my $id (keys %$intf) {
    push @$body, "--connect=BUS_rte${axi_type_str},",
                 "master_port[$bus_rte_port],slave_port,",
                 "SubSystem_inbound_${axi_type_str1}rte$id\n";
    $bus_rte_port++;
  }

  # Connect to SystemRAM, SystemROM, DeviceMemories, L2, SystemDMA
  push @$body, "// Connect SystemRAM, SystemROM, DeviceMemories (optional),\n";
  push @$body, "// L2 (optional), SystemDMA (optional) to the ",
               "common bus router\n";

  # Connect SystemRAM, SystemROM
  my $mem_port = ($axi_type eq 'rd' or $axi_type eq '') ? 0 : 1;
  push @$body, "--connect=BUS_rte${axi_type_str},master_port[$bus_rte_port],".
               ($mem_port != -1 ? "slave_port[$mem_port]" : "slave_port").
               ",$systemRAM->{'name'}\n"; 
  $bus_rte_port++;

  # SystemROM could be optional
  if (defined $systemROM->{'globalAddr'}) {
    push @$body, "--connect=BUS_rte${axi_type_str},master_port[$bus_rte_port],".
                 ($mem_port != -1 ? "slave_port[$mem_port]" : "slave_port").
                 ",$systemROM->{'name'}\n";
    $bus_rte_port++;
  }

  # Connect other device memories
  if (@DeviceMemories) {
    push @$body, "// Connect DeviceMemories to the common bus router\n";
  }
  foreach my $devMem (@DeviceMemories) { 
    # If the special __DefaultMem__ is defined, add it at the end
    if ($devMem->{'name'} eq '__DefaultMem__') {
      next;
    }
    my $mem_port = ($axi_type eq 'rd' or $axi_type eq '') ? 0 : 1;
    push @$body, "--connect=BUS_rte${axi_type_str},master_port[$bus_rte_port],".
                 ($mem_port != -1 ? "slave_port[$mem_port]" : "slave_port").
                 ",$devMem->{'name'}\n"; 
    $bus_rte_port++;
  }

  # Connect L2.
  # Note, we only allow one inbound to the L2 slave port
  push @$body, "// Connect common bus to L2 (if defined)\n";
  foreach my $l2 (values %$subSystemL2s) {
    if ($l2->{'isL2CC'}) {
      # Connect to L2-CC's slave port 0 arbiter.
      push @$body, "--connect=BUS_rte${axi_type_str},",
                   "master_port[$bus_rte_port],slave_port[0],",
                   "$l2->{'name'}_${axi_type_str1}arb0\n";
      $bus_rte_port++;
    } elsif (!$l2->{'isL2CC'}) {
      # Connect to L2 RAM, if defined
      push @$body, "--connect=BUS_rte${axi_type_str},",
                   "master_port[$bus_rte_port],slave_port,",
                   "$l2->{'name'}_bus_${axi_type_str1}rte\n";
      $bus_rte_port++;
    }
  }

  # Connect SystemDMA
  if (defined $SystemDMA->{'baseAddr'}) {
    if ($axi_type ne "") {
      # For axi, combine the rd/wr ports before translating from axi to pif
      push @$body, "--connect=BUS_rte${axi_type_str},".
                   "master_port[$bus_rte_port],axislave_$axi_type".
                   ",SystemDMA_AXI2PIF_xtor\n";
    } else {
      push @$body, "--connect=BUS_rte,master_port[$bus_rte_port],",
                   "slave_port,SystemDMAChannelRte\n";
    }
    $bus_rte_port++;
  }

  # Connect SubSystemMMIOs
  foreach my $smmio (values %$subSystemMMIOs) {
    if (!defined $smmio->{'apb'}) {
      # Non-apb connects directly to port 0 of the SubSystemMMIO arbiter
      if ($axi_type ne "") {
        push @$body, "--connect=BUS_rte${axi_type_str},".
                     "master_port[$bus_rte_port],slave_port[".
                     ($axi_type eq 'rd' ? "0" : "1")."],$smmio->{'name'}_arb\n";
      } else {
        push @$body, "--connect=BUS_rte,master_port[$bus_rte_port],".
                     "slave_port[0],$smmio->{'name'}_arb\n";
      }
    } else {
      # For apb, combine the rd/wr ports before translating from axi to apb
      if ($axi_type ne "") {
        push @$body, "--connect=BUS_rte${axi_type_str},".
                     "master_port[$bus_rte_port],slave_port[".
                     ($axi_type eq 'rd' ? "0" : "1").
                     "],$smmio->{'name'}_BusRdWrArb\n";
      }
    }
    $bus_rte_port++;
  }

  # If the special __DefaultMem__ is defined, add it at the end
  foreach my $devMem (@DeviceMemories) { 
    if ($devMem->{'name'} eq '__DefaultMem__') {
      my $mem_port = ($axi_type eq 'rd' or $axi_type eq '') ? 0 : 1;
      push @$body, "--connect=BUS_rte${axi_type_str},",
                   "master_port[$bus_rte_port],".
                   ($mem_port != -1 ? "slave_port[$mem_port]" : "slave_port").
                   ",$devMem->{'name'}\n"; 
      $bus_rte_port++;
    }
  }

  push @$body, "\n";
}

# Connect the SubSystem inbound router for each interface to the
# processor on that interface
sub connectXTSCSubSystemInboundRouter {
  my ($body, $axi_type, $extIntf) = @_;
  my $axi_type_str = ($axi_type ne "" ? "${axi_type}_" : $axi_type);
  push @$body, "// Connect the SubSystem inbound $axi_type router ",
               "to processors, XNNEs (if defined)\n";

  # The router is connected to all procs that have an incoming connection from
  # the interface, in increasing order of their proc ids. 
  # The bus always hooks to
  # port 0 of the target processor's inbound arbiter. The rest of the
  # ports of the target processor's inbound arbiter are from 
  # fastpaths from other processors
  my $rte_port = 0;
  foreach my $dest_pid (sort {$a<=>$b} @{$extIntf->{'procs'}}) {
    if (grep { $_ eq $dest_pid } @{$subSysInterconnectTo->{$COMMON_BUS_ID}}) {
      push @$body, 
        "--connect=SubSystem_inbound_${axi_type_str}rte$extIntf->{'id'},",
        "master_port[$rte_port],slave_port[0],",
        "$procIdMap->{$dest_pid}->{'name'}_inbound_${axi_type_str}arb\n";
      $rte_port++;
    }
  }
  push @$body, "\n";

  # The router is connected to all XNNEs that have an incoming connection from
  # the interface, in increasing order of their XNNE ids. 
  # The bus always hooks to
  # port 0 of the target XNNE's inbound arbiter. The rest of the
  # ports of the target XNNE's inbound arbiter are from 
  # fastpaths from other processors
  if (defined $extIntf->{'xnnes'}) {
    foreach my $dest_xid (sort {$a<=>$b} @{$extIntf->{'xnnes'}}) {
      if (grep { $_ eq $dest_xid } @{$subSysInterconnectTo->{$COMMON_BUS_ID}}) {
        push @$body, 
             "--connect=SubSystem_inbound_${axi_type_str}rte$extIntf->{'id'},",
             "master_port[$rte_port],slave_port[0],",
             "$xnneIdMap->{$dest_xid}->{'name'}_inbound_${axi_type_str}arb\n";
        $rte_port++;
      }
    }
  }
}

# Connect the SubSystem external interfaces, L2, SystemDMA to the bus
sub connectXTSCBusArbiter {
  my ($body, $axi_type) = @_;
  my $axi_type_str = ($axi_type ne "" ? "_${axi_type}" : $axi_type);
  my $axi_type_str1 = ($axi_type ne "" ? "${axi_type}_" : $axi_type);

  my $bus_arb_port = 0;

  # Find number of ports from all the SubSystem external interfaces
  my $numSubSystemExtPorts = 0;
  foreach my $extIntf (@subSystemExternalInterfaces) {
    $numSubSystemExtPorts += $extIntf->{'numPorts'};
  }

  push @$body, "// Connect interface's outbound router to BUS ",
               "$axi_type arbiter\n";
  foreach my $r (0..$numSubSystemExtPorts-1) {
    push @$body, "--connect=SubSystem_outbound_${axi_type_str1}rte${r},",
                 "master_port[0],slave_port[$bus_arb_port],",
                 "BUS_arb${axi_type_str}\n";
    $bus_arb_port++;
  }

  # Connect the L2-CC to the BUS
  foreach my $l2 (values %$subSystemL2s) {
    if ($l2->{'isL2CC'}) {
      push @$body, "\n";
      push @$body, "// Connect the $l2->{'name'} to the BUS_arb\n";
      push @$body, "--connect=$l2->{'name'},master0${axi_type_str},",
                   "slave_port[$bus_arb_port],BUS_arb${axi_type_str}\n";
      $bus_arb_port++;
    }
  }

  # Connect the SystemDMA to the BUS
  if (defined $SystemDMA->{'baseAddr'}) {
    push @$body, "\n";
    push @$body, "// Connect the SystemDMA to the BUS_arb\n";
    if ($axi_type ne "") {
      my $port = $axi_type eq 'rd'? "aximaster_rd" : "aximaster_wr";
      push @$body, "--connect=SystemDMA_Bus_PIF2AXI_xtor,$port,".
                   "slave_port[$bus_arb_port],BUS_arb${axi_type_str}\n";
    } else {
      push @$body, "--connect=SystemDMAOutRte,master_port[0],",
                   "slave_port[$bus_arb_port],BUS_arb\n";
    }
    $bus_arb_port++;
  }

  # Connect the TestBenchMaster
  push @$body, "\n";
  push @$body, "// Connect the TestBench xtsc_master router to the BUS_arb\n";
  push @$body, "--connect=TestBenchMaster_rte,master_port[".
               ($axi_type eq 'wr' ? "1" : "0").
               "],slave_port[$bus_arb_port],BUS_arb${axi_type_str}\n";
  push @$body, "\n";
}

# Connect proc/xnne to SubSystemMMIO arbiters
sub connectXTSCDevToSubSystemMMIOArb {
  my ($body, $axi_type, $smmio) = @_;
  my $axi_type_str1 = ($axi_type ne "" ? "${axi_type}_" : $axi_type);

  # APBs go directly from the apb port of the core
  if (defined $smmio->{'apb'}) {
    return;
  }

  # If the SubSystemMMIO is not connected to any procs
  if (! defined $subSysInterconnectFrom->{$smmio->{'id'}}) { 
    return;
  }

  push @$body, "// Connect processor outbound router to $smmio->{'name'}\n";

  # First port to the SubSystemMMIO arbiter is from the bus
  my $dport = 1;

  # Followed by optional SystemDMA
  $dport += (defined $SystemDMA->{'baseAddr'} ? 1 : 0);

  # Connect all the core/xnne outbound
  foreach my $id (sort {$a<=>$b} 
                  @{$subSysInterconnectFrom->{$smmio->{'id'}}}) { 
    if (isProcId($id)) {
      my $proc = $procIdMap->{$id};
      my $dest_arb_port = $dport;
      # Account for rd/wr ports, if axi
      $dest_arb_port *= ($axi_type eq "" ? 1 : 2);
      $dest_arb_port += ($axi_type eq "wr" ? 1 : 0);
      # Port 1 of the proc's outbound router goes to the SubSystemMMIO arbiter
      push @$body, "--connect=$proc->{'name'}_outbound_${axi_type_str1}rte,",
                   "master_port[1],slave_port[${dest_arb_port}],",
                   "$smmio->{'name'}_arb\n";
      $dport++;
      if ((defined $proc->{'idma'} and !$proc->{'idma'}->{'shared'}) or 
          (defined $proc->{'sdma'} and !$proc->{'sdma'}->{'shared'})) {
        my $dest_arb_port = $dport;
        # Account for rd/wr ports, if axi
        $dest_arb_port *= ($axi_type eq "" ? 1 : 2);
        $dest_arb_port += ($axi_type eq "wr" ? 1 : 0);
        # Port 1 of the proc dma's outbound router goes to the 
        # SubSystemMMIO arbiter
        push @$body, "--connect=",
                     "$proc->{'name'}_dma_outbound_${axi_type_str1}rte,",
                     "master_port[1],slave_port[${dest_arb_port}],",
                     "$smmio->{'name'}_arb\n";
        $dport++;
      }
    } else {
      my $xnne = $xnneIdMap->{$id};
      foreach my $xp (@{$xnne->{'masterCompMap'}->{$smmio->{'id'}}}) {
        my $dest_arb_port = $dport;
        # Account for rd/wr ports
        $dest_arb_port *= 2;
        $dest_arb_port += ($axi_type eq "wr" ? 1 : 0);
        # Port 1 of the XNNE's outbound router goes to the SubSystemMMIO arbiter
        # if the router is connected to bus
        my $xnne_port = (grep {$_ eq $COMMON_BUS_ID } 
                         @{$xnne->{'masterPortMap'}->{$xp}})
                        ? "1" : "0";
        push @$body, 
             "--connect=$xnne->{'name'}_outbound_${axi_type_str1}rte$xp,",
             "master_port[$xnne_port],slave_port[${dest_arb_port}],",
             "$smmio->{'name'}_arb\n";
        $dport++;
      }
    }
  }
  push @$body, "\n";
}

# Connect proc to L2 
sub connectXTSCProcToL2 {
  my ($body, $axi_type, $l2) = @_;
  my $axi_type_str = ($axi_type ne "" ? "${axi_type}_" : $axi_type);
  my $axi_type_str1 = ($axi_type ne "" ? "_${axi_type}" : $axi_type);
  push @$body, "// Connect processor outbound router to $l2->{'name'}\n";
  if ($l2->{'isL2CC'}) {
    # L2 CC case
    # Port 0 of the dma outbound router is to the common bus
    # Port 1 of the dma outbound router is to the L2 slave port arbiter 
    my $pnum_d = 0;
    foreach my $pid (sort {$a<=>$b} @{$subSysInterconnectFrom->{$l2->{'id'}}}) {
      my $proc = $procIdMap->{$pid};
      if (defined $proc->{'idma'} or defined $proc->{'sdma'}) {
        my $l2_arb_num = int($pnum_d % $l2->{'numPorts'}); 
        my $l2_arb_port = int($pnum_d / $l2->{'numPorts'});
        # Port 0 of the first arbiter is inbound from the bus.
        my $p = $l2_arb_num == 0 ? ($l2_arb_port+1) : $l2_arb_port;
        push @$body, 
            "--connect=$proc->{'name'}_dma_outbound_${axi_type_str}rte,",
            "master_port[1],slave_port[$p],",
            "$l2->{'name'}_${axi_type_str}arb${l2_arb_num}\n";
        $pnum_d++;
      }
    }
    push @$body, "\n";
  
    # Connect proc to L2 core ports
    my $num = 0;
    push @$body, "// Connect processor to $l2->{'name'} core ports\n";
    foreach my $pid (sort {$a<=>$b} @{$subSysInterconnectFrom->{$l2->{'id'}}}) {
      my $proc = $procIdMap->{$pid};
      push @$body, "--connect=$proc->{'name'}_outbound_${axi_type_str}rte,",
                   "master_port[0],core${num}data${axi_type_str1},",
                   "$l2->{'name'}\n";
      # Directly connect to L2 inst rd, and optional snoop
      if ($axi_type eq 'rd') {
        push @$body, "--connect=$proc->{'name'},instmaster_rd,",
                     "core${num}inst${axi_type_str1},$l2->{'name'}\n";
        if ($l2->{'coherent'}) {
          push @$body, "--connect=$proc->{'name'},snoop,",
                       "core${num}data_sn,$l2->{'name'}\n";
          push @$body, "--connect=$proc->{'name'},RACK,",
                       "core${num}data_RACK,$l2->{'name'}\n";
          push @$body, "--connect=$proc->{'name'},L2Status,",
                       "core${num}l2_status,$l2->{'name'}\n";
          push @$body, "--connect=$proc->{'name'},L2Err,",
                       "core${num}l2_err,$l2->{'name'}\n";
          push @$body, "\n";
        }
        push @$body, "\n";
        push @$body, "// Connect PWaitMode to L2\n";
        push @$body, "--connect=$proc->{'name'},PWaitMode,".
                     "$proc->{'name'}_pwait,$l2->{'name'}_pwait_logic\n";
        push @$body, "--connect=$l2->{'name'}_pwait_logic,".
                     "$l2->{'name'}_$proc->{'name'}_pwait,".
                     "core${num}_pwait,L2\n";
        push @$body, "\n";
      }
      $num++;
    }
  } else {
    # L2 RAM case
    my $pnum = 0;
    my $pnum_d = 0;
    foreach my $pid (sort {$a<=>$b} @{$subSysInterconnectFrom->{$l2->{'id'}}}) {
      if (isProcId($pid)) {
        my $proc = $procIdMap->{$pid};
        # Port 0 of the out bound router is to bus and port 1 is
        # optionally to SubSystemMMIO
        my $src_port = (grep { defined $subSystemMMIOIds->{$_} and
                               !defined $subSystemMMIOIds->{$_}->{'apb'} } 
                       @{$subSysInterconnectTo->{$pid}}) ? 2 : 1;
        my $l2_arb_num = int($pnum % $l2->{'numCorePorts'});
        my $l2_arb_port = int($pnum / $l2->{'numCorePorts'});
        # Connect to the L2's core port arbiters
        push @$body, "--connect=$proc->{'name'}_outbound_${axi_type_str}rte,",
                     "master_port[$src_port],",
                     "slave_port[$l2_arb_port],",
                     "$l2->{'name'}_core_${axi_type_str}arb${l2_arb_num}\n";
        # Connect iDMA to L2's inbound slave port arbiters
        if ((defined $proc->{'idma'} and !$proc->{'idma'}->{'shared'}) or 
            (defined $proc->{'sdma'} and !$proc->{'sdma'}->{'shared'})) {
          my $l2_arb_num = int($pnum_d % $l2->{'numPorts'}); 
          my $l2_arb_port = int($pnum_d / $l2->{'numPorts'});
          # Port 0 of the first arbiter is inbound from the bus.
          my $p = $l2_arb_num == 0 ? ($l2_arb_port+1) : $l2_arb_port;
          push @$body, 
            "--connect=$proc->{'name'}_dma_outbound_${axi_type_str}rte,",
            "master_port[$src_port],",
            "slave_port[$p],$l2->{'name'}_${axi_type_str}arb${l2_arb_num}\n";
          $pnum_d++;
        }
        $pnum++;
      } else {
        my $xnne = $xnneIdMap->{$pid};
        foreach my $xp (@{$xnne->{'masterCompMap'}->{$l2->{'id'}}}) {
          my $src_port = 0;
          # Account for connects from the port to bus, mmio
          $src_port += (grep { $_ eq $COMMON_BUS_ID } 
                        @{$xnne->{'masterPortMap'}->{$xp}}) ? 1 : 0;
          $src_port += (grep { defined $subSystemMMIOIds->{$_} and 
                               !defined $subSystemMMIOIds->{$_}->{'apb'} } 
                        @{$xnne->{'masterPortMap'}->{$xp}})
                        ? 1 : 0;
          my $l2_arb_num = int($pnum_d % $l2->{'numPorts'}); 
          my $l2_arb_port = int($pnum_d / $l2->{'numPorts'});
          # Port 0 of the first arbiter is inbound from the bus.
          my $p = $l2_arb_num == 0 ? ($l2_arb_port+1) : $l2_arb_port;
          push @$body, 
               "--connect=$xnne->{'name'}_outbound_${axi_type_str}rte$xp,",
               "master_port[$src_port],",
               "slave_port[$p],$l2->{'name'}_${axi_type_str}arb${l2_arb_num}\n";
          $pnum_d++;
        }
      }
    }
  }
  push @$body, "\n";
}
    
# Generate per XNNE outbound router
sub generateXTSCXNNERouter {
  my ($body, $xnne, $axi_type) = @_;

  push @$body, "// Create XNNE $xnne->{'name'}'s outbound routers\n";
  my $port = 0;
  foreach my $mwidth (@{$xnne->{'masterWidths'}}) {
    # Port 0 is routed to the interface. All requests, not targeting a
    # a proc/xnne that is directly connected to this proc, 
    # are routed to the interface # by default. If the xnne master port is not
    # connected to the bus, use a default invalid dest port
    push @$body, "--set_router_parm=default_port_num=".
      ((grep { $_ == $COMMON_BUS_ID } @{$xnne->{'masterPortMap'}->{$port}})
       ? 0 : "666"). "\n";
    my @slaves;
    foreach my $id (@{$xnne->{'masterPortMap'}->{$port}}) {
      # Avoid routing if is connected to a APB SubSystemMMIO
      if (defined $subSystemMMIOIds->{$id} and 
          defined $subSystemMMIOIds->{$id}->{'apb'}) {
        next;
      }
      push @slaves, $id;
    }
    my $num_slaves = @slaves;
    push @$body, "--set_router_parm=num_slaves=$num_slaves\n";
    push @$body, "--set_router_parm=routing_table=".
                 "\$(XTSC_SCRIPT_FILE_PATH)/".
                 "$xnne->{'name'}_outbound_${axi_type}_rte$port.tab\n";
    # Set immediate timing only if single master, slave and no width conversion
    if ($num_slaves == 1 and ($mwidth == $subSysBusWidth)) {
      push @$body, "--set_router_parm=immediate_timing=true\n";
    } else {
      push @$body, "--set_router_parm=master_byte_width=$mwidth\n";
      my @slave_widths = ();
      foreach my $s (sort {$a<=>$b} @slaves) {
        if ($s == $COMMON_BUS_ID) {
          push @slave_widths, $subSysBusWidth;
        } else {
          push @slave_widths, $mwidth;
        }
      }
      my $widths = join(",", @slave_widths);
      push @$body, "--set_router_parm=slave_byte_widths=$widths\n";
    }
    push @$body, "--create_router=".
                 "$xnne->{'name'}_outbound_${axi_type}_rte$port\n";
    push @$body, "\n";
    push @$body, "// Connect XNNE to router\n";
    push @$body, "--connect=$xnne->{'name'},${axi_type}0_master_port[$port],".
                 "slave_port,$xnne->{'name'}_outbound_${axi_type}_rte$port\n";
    push @$body, "\n";
    $port++;
  }
  push @$body, "\n";
}

# Create inbound arbiter to the XNNE. The arbiter could be mastered
# by the interface router bus and fast paths from other processors/XNNEs.
sub generateXTSCXNNEArbiter {
  my ($body, $xnne, $route_id_lsb, $axi_type) = @_;
  my $axi_type_str = ($axi_type ne "" ? "${axi_type}_" : $axi_type);

  push @$body, "// Create inbound arbiter for $xnne->{'name'}\n";

  # Add all srcs procs that target this xnne
  my $num_arb_masters = @{$subSysInterconnectFrom->{$xnne->{'id'}}};

  # Add all src procs with dma that target this proc
  my @procsWithiDMA = ();  

  # Add all srcs that have a 2nd XNNE master that target this proc
  my @xnnesWith2ndMaster = ();

  foreach my $src_id (@{$subSysInterconnectFrom->{$xnne->{'id'}}}) {
    if ($src_id == $COMMON_BUS_ID) {
      next;
    }
    if (isProcId($src_id) and defined $procIdMap->{$src_id}->{'idma'} and
        !$procIdMap->{$src_id}->{'idma'}->{'shared'}) {
      $num_arb_masters++;
      push @procsWithiDMA, $src_id;
    } 
  }

  # Restrict to 32 masters since we are reserving only 5-bits
  $num_arb_masters <= 32 or
    die "Number of masters $num_arb_masters for $xnne->{'name'}'s inbound ".
        "arbiter has to be <= 32\n";

  push @$body, "--set_arbiter_parm=num_masters=$num_arb_masters\n";
  push @$body, "--set_arbiter_parm=route_id_lsb=$route_id_lsb\n";

  # The common bus, if connected, will always be the first port. The rest
  # follows sorted order of processor/xnne ids. The bitwidth of the common bus
  # port is the bus width, while for the processors, it is their respective
  # PIF/AXI width. If the incoming widths do not match this proc's PIF/AXI width
  # then this arbiter acts as a PIF width converter.

  my ($head, @rest) = sort {$a<=>$b} 
                      @{$subSysInterconnectFrom->{$xnne->{'id'}}};
  my $rest_bw_str =
    @rest ? ",".join(",", map(isProcId($_)
                  ? ($procIdMap->{$_}->{'pipeline'} eq 'NX' 
                    ? $procIdMap->{$_}->{'masterWidth'} 
                    : $procIdMap->{$_}->{'pifWidth'})
                  : @{$xnneIdMap->{$_}->{'masterWidths'}}
                     [@$xnneIdMap->{$_}->{'masterCompMap'}->{$xnne->{'id'}}[0]],
                    @rest))
          : "";

  # Add the procs with idma to end of the list. The IDMA ports follows
  # after all the connections originating from the pif/axi master port

  my @rest_idma = sort {$a<=>$b} @procsWithiDMA;
  $rest_bw_str .= @rest_idma ? ",".join(",", map($procIdMap->{$_}->{'dmaWidth'},
                                                 @rest_idma)) 
                             : "";

  my @mws = isXNNEId($head) 
              ? @{$xnneIdMap->{$head}->{'masterCompMap'}->{$xnne->{'id'}}} 
              : ();

  my $head_width = ($head == $COMMON_BUS_ID 
                      ? $subSysBusWidth 
                      : (isProcId($head) 
                           ? ($procIdMap->{$head}->{'pipeline'} eq 'NX'
                                ? $procIdMap->{$head}->{'masterWidth'}
                                : $procIdMap->{$head}->{'pifWidth'})
                           : @{$xnneIdMap->{$head}->{'masterWidths'}}[$mws[0]])
                   );
  my $slave_width = $xnne->{'slaveWidth'};
                            
  # If there is just a single master and is not width-converting,
  # relax timing
  if ($num_arb_masters == 1 and ($head_width == $slave_width)) {
    push @$body, "--set_arbiter_parm=immediate_timing=true\n";
  } else {
    push @$body, "--set_arbiter_parm=master_byte_widths=".
                 ($head_width.$rest_bw_str)."\n";
    push @$body, "--set_arbiter_parm=slave_byte_width=$slave_width\n";
  }

  push @$body, "--set_arbiter_parm=arbitration_phase=$INBOUND_ARB_PHASE\n";
  push @$body, "--set_arbiter_parm=one_at_a_time=false\n";
  push @$body, "--create_arbiter=$xnne->{'name'}_inbound_${axi_type_str}arb\n";
  push @$body, "\n";
  push @$body, "// Connect the inbound arbiter to the inbound router\n";
  push @$body, "--connect=$xnne->{'name'}_inbound_${axi_type_str}arb,",
               "master_port,${axi_type_str}slave_port,$xnne->{'name'}\n";
  push @$body, "\n";
}

sub generateXTSCXNNEInterConnect {
  my ($body, $xnne) = @_;

  generateXTSCXNNERouter($body, $xnne, "rd");
  generateXTSCXNNERouter($body, $xnne, "wr");

  generateXTSCXNNEArbiter($body, $xnne, $INBOUND_ARB_ROUTE_ID_LSB, "rd");
  generateXTSCXNNEArbiter($body, $xnne, $INBOUND_ARB_ROUTE_ID_LSB, "wr");
}

# Generate inter proc/xnne interconnect
sub generateXTSCInterDevRouterArbiter {
  my ($body, $axi_type, $dev) = @_;
  my $axi_type_str = ($axi_type ne "" ? "${axi_type}_" : $axi_type);

  my $dma_src_port = 0;
  
  # Map from dev's router instance to its src port
  my $rte_src_port = {};
  if (isXNNEId($dev->{'id'})) {
    foreach my $p (keys %{$dev->{'masterPortMap'}}) {
      $rte_src_port->{$p} = 0;
    }
  } else {
    $rte_src_port->{0} = 0;
  }
  
  foreach my $dest_id (sort {$a<=>$b}
                       @{$subSysInterconnectTo->{$dev->{'id'}}}) {
    # Ignore L2-CC
    if (defined $subSystemL2Ids->{$dest_id} and 
        $subSystemL2Ids->{$dest_id}->{'isL2CC'}) {
      # DMA routes to L2CC slave port
      $dma_src_port++;
      next;
    }

    # Ignore SubSystemMMIO on apb
    if (defined $subSystemMMIOIds->{$dest_id} and
        defined $subSystemMMIOIds->{$dest_id}->{'apb'}) {
      next;
    }

    # Only consider component id that is a processor id
    if ($dest_id <= -1) {
      if (isXNNEId($dev->{'id'})) {
        foreach my $p (@{$dev->{'masterCompMap'}->{$dest_id}}) {
          $rte_src_port->{$p}++;
        }
      } else {
        $rte_src_port->{0}++;
      }
      $dma_src_port++;
      next;
    }

    # Find the position of the proc's pid in the sorted list of pids of procs
    # that are connected to the destination proc. This position is used as 
    # the port number to the destination proc's inbound arbiter
    my @dest_arb_proc_masters = sort {$a<=>$b} 
                                @{$subSysInterconnectFrom->{$dest_id}};
    my @idxs = grep { $dest_arb_proc_masters[$_] == $dev->{'id'} } 
                    0 .. $#dest_arb_proc_masters;

    my $dest_arb_port = $idxs[0];

    my $inst = isProcId($dev->{'id'}) 
                 ? 0 : @{$dev->{'masterCompMap'}->{$dest_id}}[0];
    my $inst_s = isProcId($dev->{'id'}) ? "" : $inst;

    my $src_port = $rte_src_port->{$inst};

    if (isProcId($dest_id)) {
      push @$body, 
           "--connect=$dev->{'name'}_outbound_${axi_type_str}rte$inst_s,".
           "master_port[$src_port],slave_port[$dest_arb_port],".
           "$procIdMap->{$dest_id}->{'name'}_inbound_${axi_type_str}arb\n";
      $rte_src_port->{$inst}++;
    } else {
      push @$body, 
           "--connect=$dev->{'name'}_outbound_${axi_type_str}rte$inst_s,".
           "master_port[$src_port],slave_port[$dest_arb_port],".
           "$xnneIdMap->{$dest_id}->{'name'}_inbound_${axi_type_str}arb\n";
      $rte_src_port->{$inst}++;
    }

    # Add the IDMA, if defined
    if (isProcId($dev->{'id'}) and 
        defined $dev->{'idma'} and !$dev->{'idma'}->{'shared'}) {
      # Find the src processors that have IDMA. Similar to the above, 
      # based on the sorted proc ids and find the idx, which determines the 
      # target port on the dest proc
      my @dest_arb_proc_masters_idma = ();
      foreach my $id (@dest_arb_proc_masters) {
        if ($id == $COMMON_BUS_ID) {
          next;
        }
        if (isProcId($id) and defined $procIdMap->{$id}->{'idma'} and
            !$procIdMap->{$id}->{'idma'}->{'shared'}) {
          push @dest_arb_proc_masters_idma, $id;          
        }
      }

      # The IDMA ports follows after all the connections originating 
      # from the pif port
      my @idxs_idma = grep { $dest_arb_proc_masters_idma[$_] == 
                             $dev->{'id'} } 
                      0 .. $#dest_arb_proc_masters_idma;
      my $dest_arb_port_idma = $idxs_idma[0] + @dest_arb_proc_masters;
      if (isProcId($dest_id)) {
        push @$body,
             "--connect=$dev->{'name'}_dma_outbound_${axi_type_str}rte,".
             "master_port[$dma_src_port],slave_port[$dest_arb_port_idma],".
             "$procIdMap->{$dest_id}->{'name'}_inbound_${axi_type_str}arb\n";
      } else {
        push @$body,
             "--connect=$dev->{'name'}_dma_outbound_${axi_type_str}rte,".
             "master_port[$dma_src_port],slave_port[$dest_arb_port_idma],".
             "$xnneIdMap->{$dest_id}->{'name'}_inbound_${axi_type_str}arb\n";
      }
      $dma_src_port++;
    }
  }
}

# Fastpaths between processors/xnne
sub connectXTSCInterDevRouterArbiter {
  my ($body, $axi_type) = @_;

  push @$body, "// Connect the outbound router to other processors/XNNEs ".
               "(if fast-paths present)\n";

  # Generate interconnect between a proc and other procs/xnne
  foreach my $pid (sort {$a<=>$b} (keys %$procIdMap)) {
    my $proc = $procIdMap->{$pid};
    generateXTSCInterDevRouterArbiter($body, $axi_type, $proc);
  }

  # Generate interconnect between a xnne and other procs/xnne
  foreach my $pid (sort {$a<=>$b} (keys %$xnneIdMap)) {
    my $xnne = $xnneIdMap->{$pid};
    generateXTSCInterDevRouterArbiter($body, $axi_type, $xnne);
  }
  push @$body, "\n";
}

# Generate xtsc mmio def file
sub generateSubSystemMMIOMMIODef {
  my ($xtsc_run_gen_dir, $smmio) = @_;

  my $xtsc_car_mmio_def_file = "$xtsc_run_gen_dir/$smmio->{'name'}.def";

  open(xtsc_car_mmio_def_file, ">$xtsc_car_mmio_def_file") or 
    sysBuildError("Could not open $xtsc_car_mmio_def_file\n");

  print xtsc_car_mmio_def_file "/*\n"; 
  print xtsc_car_mmio_def_file "register  <RegisterName>  <BitWidth>  ".
                               "<Address>   {read_only} {<InitialValue>}\n";
  print xtsc_car_mmio_def_file "--------  --------------  ----------  ".
                               "----------   ---------- --------------  */\n";
  my $num = 0;
  foreach my $car (@{$smmio->{'intrRegs'}}) {
    printf xtsc_car_mmio_def_file "register    %-20s %-4d %-10s %-12s %-10d\n",
                                  "$smmio->{'name'}_intrreg$num", 32, 
                                  $car->{'localAddr'}, "         ", 0;
    $num++;
  }
  print xtsc_car_mmio_def_file "\n";

  # SubSystemMMIO controls
  $num = 0;
  foreach my $car_ctrl (@{$smmio->{'controlRegs'}}) {
    printf xtsc_car_mmio_def_file "register    %-20s %-4d %-10s %-12s %-10s\n",
                                  "$smmio->{'name'}_ctrlreg$num", 
                                  $car_ctrl->{'width'}, 
                                  $car_ctrl->{'localAddr'}, 
                                  $car_ctrl->{'readOnly'} ? "read_only" 
                                                          : "         ", 
                                  $car_ctrl->{'initValue'};
   $num++;
  }
  print xtsc_car_mmio_def_file "\n";
  
  print xtsc_car_mmio_def_file "/*\n";
  print xtsc_car_mmio_def_file "output  <PortName>    <RegisterName>  ".
                               "{<HighBit>  {<LowBit>}}\n";
  print xtsc_car_mmio_def_file "------  ------------  --------------   ".
                               "---------   --------  */\n";
  $num = 0;
  foreach my $car (@{$smmio->{'intrRegs'}}) {
    my $h = $car->{'bIntrMap'};
    foreach my $intr (sort {$a<=>$b} keys %$h) {
      print xtsc_car_mmio_def_file 
            "output   $smmio->{'name'}_intrreg${num}_${intr}      ".
            "$smmio->{'name'}_intrreg${num}         $intr           $intr\n";
    }
    $num++;
  }
  
  print xtsc_car_mmio_def_file "\n";

  # SubSystemMMIO controls
  $num = 0;
  foreach my $car_ctrl (@{$smmio->{'controlRegs'}}) {
    foreach my $reg (@{$car_ctrl->{'subRegs'}}) {
      if (defined $reg->{'comp'} and ($reg->{'dir'} eq 'out')) {
        printf xtsc_car_mmio_def_file 
               "output   %-25s %-20s  $reg->{'bitEnd'}           ".
               "$reg->{'bitStart'}\n", 
               "$smmio->{'name'}_$reg->{'name'}_$reg->{'comp'}", 
               "$smmio->{'name'}_ctrlreg$num";
      }
    }
    $num++;
  }
  print xtsc_car_mmio_def_file "\n";
  
  # Handle inputs
  $num = 0;
  print xtsc_car_mmio_def_file "/*\n";
  print xtsc_car_mmio_def_file "input  <ExportName>    <RegisterName>  ".
                               "{<HighBit>  {<LowBit>}}\n";
  print xtsc_car_mmio_def_file "------  ------------  --------------   ".
                               "---------   --------  */\n";
  foreach my $car_ctrl (@{$smmio->{'controlRegs'}}) {
    foreach my $reg (@{$car_ctrl->{'subRegs'}}) {
      if (defined $reg->{'comp'} and ($reg->{'dir'} eq 'in')) {
        printf xtsc_car_mmio_def_file 
               "input   %-25s %-20s  $reg->{'bitEnd'}           ".
               "$reg->{'bitStart'}\n", 
               "$smmio->{'name'}_$reg->{'name'}_$reg->{'comp'}", 
               "$smmio->{'name'}_ctrlreg$num";
      }
    }
    $num++;
  }
  print xtsc_car_mmio_def_file "\n";

  close xtsc_car_mmio_def_file;
}

# Generate local xtsc mmio def
sub generateLocalMMIODef {
  my ($xtsc_run_gen_dir, $proc) = @_;

  my $xtsc_local_mmio_def_file = "$xtsc_run_gen_dir/$proc->{'name'}_mmio.def";

  open(xtsc_local_mmio_def_file, ">$xtsc_local_mmio_def_file") or 
    sysBuildError("Could not open $xtsc_local_mmio_def_file\n");

  print xtsc_local_mmio_def_file "/*\n"; 
  print xtsc_local_mmio_def_file "register  <RegisterName>  <BitWidth>  ".
                                 "<Address>   {<InitialValue>}\n";
  print xtsc_local_mmio_def_file "--------  --------------  ----------  ".
                                 "----------   --------------  */\n";
  print xtsc_local_mmio_def_file 
        "register    $proc->{'name'}_intr_reg  32       ".
        "$proc->{'mmio'}->{'intrReg'}->{'globalAddr'}         0\n";
  my $j = 0;
  foreach my $gpio_reg (@{$proc->{'mmio'}->{'gpioRegs'}}) {
    print xtsc_local_mmio_def_file 
          "register    $proc->{'name'}_GPIO_$j    32       ".
          "$gpio_reg         0\n";
    $j++;
  }
  print xtsc_local_mmio_def_file "\n";

  # Hook up the controls
  my $controls = $proc->{'mmio'}->{'controls'};
  my $num = 0;
  foreach my $ctrl (@$controls) {
    printf xtsc_local_mmio_def_file "register    %-25s $ctrl->{'width'}    ".
                                    "$ctrl->{'globalAddr'}     ".
                                    "$ctrl->{'initValue'}\n", 
                                    $proc->{'name'}."_ctrl_reg_".$num;
    $num++;
  }
  print xtsc_local_mmio_def_file "\n";
  print xtsc_local_mmio_def_file "/*\n";
  print xtsc_local_mmio_def_file "output  <PortName>    <RegisterName>  ".
                                 "{<HighBit>  {<LowBit>}}\n";
  print xtsc_local_mmio_def_file "------  ------------  --------------   ".
                                 "---------   --------  */\n";
  my $h = $proc->{'mmio'}->{'intrReg'}->{'bIntrMap'};
  foreach my $intr (sort {$a<=>$b} keys %$h) {
    print xtsc_local_mmio_def_file 
          "output   $proc->{'name'}_intr_reg_$intr   ".
          "$proc->{'name'}_intr_reg   $intr     $intr\n";
  }

  # Add the controls
  print xtsc_local_mmio_def_file "\n";
  $num = 0;
  foreach my $ctrl (@$controls) {
    foreach my $reg (@{$ctrl->{'subRegs'}}) {
      printf xtsc_local_mmio_def_file 
             "output   %-25s %-25s $reg->{'bitEnd'}     ".
             "$reg->{'bitStart'}\n", $proc->{'name'}."_".$reg->{'name'}, 
             $proc->{'name'}."_ctrl_reg_".$num;
    }
    $num++;
  }
  close xtsc_local_mmio_def_file;
}

# Generate routing tables for the dma
sub generateXTSCDMAOutboundRoutingTables {
  my ($xtsc_run_gen_dir, $proc, $axi_type) = @_;
  my $axi_type_str = ($axi_type ne "" ? "${axi_type}_" : $axi_type);

  # Generate the outbound routing table for the idma port, if defined
  if (!(defined $proc->{'idma'} and !$proc->{'idma'}->{'shared'}) and
      !(defined $proc->{'sdma'} and !$proc->{'sdma'}->{'shared'})) {
    return;
  }

  my $xtsc_outbound_routing_tab_file = 
     "$xtsc_run_gen_dir/$proc->{'name'}_dma_outbound_${axi_type_str}rte.tab";

  open(xtsc_outbound_routing_tab_file, 
       ">$xtsc_outbound_routing_tab_file") or 
    sysBuildError("Could not open $xtsc_outbound_routing_tab_file\n");

  print xtsc_outbound_routing_tab_file 
        "/* <Port>  <LowAddr>   <HighAddr>  <NewBaseAddr>  */\n\n";

  # The first port is to the interface
  my $port = 0;
  $port++;

  # The rest could be to SubSystemMMIO, L2 or processors 
  # that are on the fastpath
  foreach my $dest_pid (sort {$a<=>$b} 
                        @{$subSysInterconnectTo->{$proc->{'id'}}}) {
    # Ignore Bus. Default is to the bus
    if ($dest_pid == $COMMON_BUS_ID) {
      next;
    }

    # SubSystemMMIO mmio (not apb)
    if (defined $subSystemMMIOIds->{$dest_pid}) {
      if (!defined $subSystemMMIOIds->{$dest_pid}->{'apb'}) {
        my $smmio = $subSystemMMIOIds->{$dest_pid};
        foreach my $car (@{$smmio->{'intrRegs'}}) {
          printf xtsc_outbound_routing_tab_file 
                 "    $port     $car->{'localAddr'}     0x%x            ".
                 "/* $smmio->{'name'} */\n", hex($car->{'localAddr'}) + 4 - 1;
        }
        foreach my $car (@{$smmio->{'controlRegs'}}) {
          printf xtsc_outbound_routing_tab_file 
                 "    $port     $car->{'localAddr'}     0x%x            ".
                 "/* $smmio->{'name'} */\n", hex($car->{'localAddr'}) + 4 - 1;
        }
        $port++;
      }
      # Ignore if SubSystemMMIO on apb
      next;
    }

    # L2
    if (defined $subSystemL2Ids->{$dest_pid}) {
      my $l2 = $subSystemL2Ids->{$dest_pid};
      printf xtsc_outbound_routing_tab_file 
             "    $port     $l2->{'localAddr'}     0x%x            ".
             "/* $l2->{'name'} */\n", 
             hex($l2->{'localAddr'}) + $l2->{'size'} - 1;
      $port++;
      next;
    }

    # XNNE
    if (defined $xnneIdMap->{$dest_pid}) {
      my $xnne = $xnneIdMap->{$dest_pid};
      printf xtsc_outbound_routing_tab_file 
             "    $port     $xnne->{'globalAddr'}     0x%x            ".
             "/* $xnne->{'name'} */\n", 
             hex($xnne->{'globalAddr'}) + $xnne->{'size'} - 1;
      $port++;
      next;
    }

    # Fast-path processors

    my $dest_proc = $procIdMap->{$dest_pid};

    # Translate from the global address to dest proc local address when
    # routing. When specifying the interconnect we have ensured that
    # there is either an instram or dataram0
  
    # InstRAM0
    if (defined $dest_proc->{'instRam0'} and 
        defined $dest_proc->{'instRam0'}->{'globalAddr'}) {
      printf xtsc_outbound_routing_tab_file 
             "    $port     $dest_proc->{'instRam0'}->{'globalAddr'}     ".
             "0x%x            /* $dest_proc->{'name'} INSTRAM0 */\n", 
             hex($dest_proc->{'instRam0'}->{'globalAddr'}) + 
             $dest_proc->{'instRam0'}->{'size'} - 1;
    }

    # InstRAM1
    if (defined $dest_proc->{'instRam1'} and 
        defined $dest_proc->{'instRam1'}->{'globalAddr'}) {
      printf xtsc_outbound_routing_tab_file 
             "    $port     $dest_proc->{'instRam1'}->{'globalAddr'}     ".
             "0x%x            /* $dest_proc->{'name'} INSTRAM1 */\n", 
             hex($dest_proc->{'instRam1'}->{'globalAddr'}) + 
             $dest_proc->{'instRam1'}->{'size'} - 1;
    }

    # DataRAM0
    if (defined $dest_proc->{'dataRam0'} and
        defined $dest_proc->{'dataRam0'}->{'globalAddr'}) {
      printf xtsc_outbound_routing_tab_file 
             "    $port     $dest_proc->{'dataRam0'}->{'globalAddr'}     ".
             "0x%x            /* $dest_proc->{'name'} DATARAM0 */\n", 
             hex($dest_proc->{'dataRam0'}->{'globalAddr'}) + 
             $dest_proc->{'dataRam0'}->{'size'} - 1;
    }

    # DatamRAM1
    if (defined $dest_proc->{'dataRam1'} and
        defined $dest_proc->{'dataRam1'}->{'globalAddr'}) {
      printf xtsc_outbound_routing_tab_file 
             "    $port     $dest_proc->{'dataRam1'}->{'globalAddr'}     ".
             "0x%x            /* $dest_proc->{'name'} DATARAM1 */\n", 
             hex($dest_proc->{'dataRam1'}->{'globalAddr'}) + 
             $dest_proc->{'dataRam1'}->{'size'} - 1;
    }

    # Local MMIO
    if (defined $dest_proc->{'mmio'}) {
      printf xtsc_outbound_routing_tab_file 
             "    $port     $dest_proc->{'mmio'}->{'globalAddr'}     ".
             "0x%x            /* $dest_proc->{'name'} MMIO */\n", 
             hex($dest_proc->{'mmio'}->{'globalAddr'}) + 
             $dest_proc->{'mmio'}->{'size'} - 1;
    }

    $port++;
  }

  close xtsc_outbound_routing_tab_file;
}

# Generate the processor's outbound routing table entries.
# Note, the ports should match the outbound router
sub generateXTSCOutboundRoutingTables {
  my ($xtsc_run_gen_dir, $proc, $axi_type) = @_;
  my $axi_type_str = ($axi_type ne "" ? "${axi_type}_" : $axi_type);

  my $xtsc_outbound_routing_tab_file = 
     "$xtsc_run_gen_dir/$proc->{'name'}_outbound_${axi_type_str}rte.tab";

  open(xtsc_outbound_routing_tab_file, 
       ">$xtsc_outbound_routing_tab_file") or 
    sysBuildError("Could not open $xtsc_outbound_routing_tab_file\n");

  print xtsc_outbound_routing_tab_file 
        "/* <Port>  <LowAddr>   <HighAddr>  <NewBaseAddr>  */\n\n";

  # The first port is to the common bus/L2
  my $port = 0;
  $port++;

  # The rest could be SubSystemMMIO, L2 or processors that are on the fastpath
  foreach my $dest_pid (sort {$a<=>$b} 
                        @{$subSysInterconnectTo->{$proc->{'id'}}}) {
    # If Bus or L2CC, ignore. Bus/L2CC is the default port
    if ($dest_pid == $COMMON_BUS_ID || 
        (defined $subSystemL2Ids->{$dest_pid} and 
         $subSystemL2Ids->{$dest_pid}->{'isL2CC'})) {
      next;
    }

    # SubSystemMMIO mmio (if not apb)
    if (defined $subSystemMMIOIds->{$dest_pid}) {
      if (!defined $subSystemMMIOIds->{$dest_pid}->{'apb'}) {
        my $smmio = $subSystemMMIOIds->{$dest_pid};
        foreach my $car (@{$smmio->{'intrRegs'}}) {
          printf xtsc_outbound_routing_tab_file 
                 "    $port     $car->{'localAddr'}     0x%x            ".
                 "/* $smmio->{'name'} */\n", hex($car->{'localAddr'}) + 4 - 1;
        }
        foreach my $car (@{$smmio->{'controlRegs'}}) {
          printf xtsc_outbound_routing_tab_file 
                 "    $port     $car->{'localAddr'}     0x%x            ".
                 "/* $smmio->{'name'} */\n", hex($car->{'localAddr'}) + 4 - 1;
        }
        $port++;
      }
      next;
    }

    # L2
    if (defined $subSystemL2Ids->{$dest_pid}) {
      my $l2 = $subSystemL2Ids->{$dest_pid};
      printf xtsc_outbound_routing_tab_file 
             "    $port     $l2->{'localAddr'}     0x%x            ".
             "/* $l2->{'name'} */\n", 
             hex($l2->{'localAddr'}) + $l2->{'size'} - 1;
      $port++;
      next;
    }

    # XNNE
    if (isXNNEId($dest_pid)) {
      my $xnne = $xnneIdMap->{$dest_pid};
      printf xtsc_outbound_routing_tab_file 
             "    $port     $xnne->{'globalAddr'}     0x%x            ".
             "/* $xnne->{'name'} */\n", 
             hex($xnne->{'globalAddr'}) + $xnne->{'size'} - 1;
      $port++;
      next;
    }

    # Processors on the fast path

    my $dest_proc = $procIdMap->{$dest_pid};

    # Translate from the global address to dest proc local address when
    # routing. When specifying the interconnect we have ensured that
    # there is either an instram or dataram0

    # InstRAM0
    if (defined $dest_proc->{'instRam0'} and 
        defined $dest_proc->{'instRam0'}->{'globalAddr'}) {
      printf xtsc_outbound_routing_tab_file 
             "    $port     $dest_proc->{'instRam0'}->{'globalAddr'}      ".
             "0x%x           /* $dest_proc->{'name'} INSTRAM0 */\n", 
             hex($dest_proc->{'instRam0'}->{'globalAddr'}) + 
             $dest_proc->{'instRam0'}->{'size'} - 1;
    }

    # InstRAM1
    if (defined $dest_proc->{'instRam1'} and 
        defined $dest_proc->{'instRam1'}->{'globalAddr'}) {
      printf xtsc_outbound_routing_tab_file 
             "    $port     $dest_proc->{'instRam1'}->{'globalAddr'}      ".
             "0x%x           /* $dest_proc->{'name'} INSTRAM1 */\n", 
             hex($dest_proc->{'instRam1'}->{'globalAddr'}) + 
             $dest_proc->{'instRam1'}->{'size'} - 1;
    }

    # DataRAM0
    if (defined $dest_proc->{'dataRam0'} and
        defined $dest_proc->{'dataRam0'}->{'globalAddr'}) {
      printf xtsc_outbound_routing_tab_file 
             "    $port     $dest_proc->{'dataRam0'}->{'globalAddr'}      ".
             "0x%x           /* $dest_proc->{'name'} DATARAM0 */\n", 
             hex($dest_proc->{'dataRam0'}->{'globalAddr'}) + 
             $dest_proc->{'dataRam0'}->{'size'} - 1;
    }

    # DataRAM1
    if (defined $dest_proc->{'dataRam1'} and
        defined $dest_proc->{'dataRam1'}->{'globalAddr'}) {
      printf xtsc_outbound_routing_tab_file 
             "    $port     $dest_proc->{'dataRam1'}->{'globalAddr'}      ".
             "0x%x           /* $dest_proc->{'name'} DATARAM1 */\n", 
             hex($dest_proc->{'dataRam1'}->{'globalAddr'}) + 
             $dest_proc->{'dataRam1'}->{'size'} - 1;
    }

    # Local MMIO
    if (defined $dest_proc->{'mmio'}) {
      printf xtsc_outbound_routing_tab_file 
             "    $port     $dest_proc->{'mmio'}->{'globalAddr'}      ".
             "0x%x           /* $dest_proc->{'name'} MMIO */\n", 
             hex($dest_proc->{'mmio'}->{'globalAddr'}) + 
             $dest_proc->{'mmio'}->{'size'} - 1;
    }

    $port++;
  }

  close xtsc_outbound_routing_tab_file;
}

sub generateXTSCXNNERoutingTables {
  my ($xtsc_run_gen_dir, $xnne, $master_port, $axi_type) = @_;

  my $xtsc_xnne_routing_tab_file = 
   "$xtsc_run_gen_dir/$xnne->{'name'}_outbound_${axi_type}_rte$master_port.tab";

  open(xtsc_xnne_routing_tab_file, ">$xtsc_xnne_routing_tab_file") or 
    sysBuildError("Could not open $xtsc_xnne_routing_tab_file\n");

  print xtsc_xnne_routing_tab_file 
        "/* <Port>  <LowAddr>   <HighAddr>  <NewBaseAddr>  */\n\n";

  my $port = 0;

  # The rest could be SubSystemMMIO, L2 or processors that are on the fastpath
  foreach my $dest_pid (sort {$a<=>$b} 
                        @{$xnne->{'masterPortMap'}->{$master_port}}) {
    # If Bus, ignore. Bus is the default port
    if ($dest_pid == $COMMON_BUS_ID) {
      $port++;;
      next;
    }

    # SubSystemMMIO mmio (if not apb)
    if (defined $subSystemMMIOIds->{$dest_pid}) {
      if (!defined $subSystemMMIOIds->{$dest_pid}->{'apb'}) {
        my $smmio = $subSystemMMIOIds->{$dest_pid};
        foreach my $car (@{$smmio->{'intrRegs'}}) {
          printf xtsc_xnne_routing_tab_file 
                 "    $port     $car->{'localAddr'}     0x%x            ".
                 "/* $smmio->{'name'} */\n", hex($car->{'localAddr'}) + 4 - 1;
        }
        foreach my $car (@{$smmio->{'controlRegs'}}) {
          printf xtsc_xnne_routing_tab_file 
                 "    $port     $car->{'localAddr'}     0x%x            ".
                 "/* $smmio->{'name'} */\n", hex($car->{'localAddr'}) + 4 - 1;
        }
        $port++;
      }
      next;
    }

    # L2
    if (defined $subSystemL2Ids->{$dest_pid}) {
      my $l2 = $subSystemL2Ids->{$dest_pid};
      printf xtsc_xnne_routing_tab_file 
             "    $port     $l2->{'localAddr'}     0x%x            ".
             "/* $l2->{'name'} */\n", 
             hex($l2->{'localAddr'}) + $l2->{'size'} - 1;
      $port++;
      next;
    }

    # Processors on the fast path
    if (isProcId($dest_pid)) {
      my $dest_proc = $procIdMap->{$dest_pid};

      # Translate from the global address to dest proc local address when
      # routing. When specifying the interconnect we have ensured that
      # there is either an instram or dataram0

      # InstRAM0
      if (defined $dest_proc->{'instRam0'} and 
          defined $dest_proc->{'instRam0'}->{'globalAddr'}) {
        printf xtsc_xnne_routing_tab_file 
               "    $port     $dest_proc->{'instRam0'}->{'globalAddr'}      ".
               "0x%x           /* $dest_proc->{'name'} INSTRAM0 */\n", 
               hex($dest_proc->{'instRam0'}->{'globalAddr'}) + 
               $dest_proc->{'instRam0'}->{'size'} - 1;
      }

      # InstRAM1
      if (defined $dest_proc->{'instRam1'} and 
          defined $dest_proc->{'instRam1'}->{'globalAddr'}) {
        printf xtsc_xnne_routing_tab_file 
               "    $port     $dest_proc->{'instRam1'}->{'globalAddr'}      ".
               "0x%x           /* $dest_proc->{'name'} INSTRAM1 */\n", 
               hex($dest_proc->{'instRam1'}->{'globalAddr'}) + 
               $dest_proc->{'instRam1'}->{'size'} - 1;
      }

      # DataRAM0
      if (defined $dest_proc->{'dataRam0'} and
          defined $dest_proc->{'dataRam0'}->{'globalAddr'}) {
        printf xtsc_xnne_routing_tab_file 
               "    $port     $dest_proc->{'dataRam0'}->{'globalAddr'}      ".
               "0x%x           /* $dest_proc->{'name'} DATARAM0 */\n", 
               hex($dest_proc->{'dataRam0'}->{'globalAddr'}) + 
               $dest_proc->{'dataRam0'}->{'size'} - 1;
      }

      # DataRAM1
      if (defined $dest_proc->{'dataRam1'} and
          defined $dest_proc->{'dataRam1'}->{'globalAddr'}) {
        printf xtsc_xnne_routing_tab_file 
               "    $port     $dest_proc->{'dataRam1'}->{'globalAddr'}      ".
               "0x%x           /* $dest_proc->{'name'} DATARAM1 */\n", 
               hex($dest_proc->{'dataRam1'}->{'globalAddr'}) + 
               $dest_proc->{'dataRam1'}->{'size'} - 1;
      }

      # Local MMIO
      if (defined $dest_proc->{'mmio'}) {
        printf xtsc_xnne_routing_tab_file 
               "    $port     $dest_proc->{'mmio'}->{'globalAddr'}      ".
               "0x%x           /* $dest_proc->{'name'} MMIO */\n", 
               hex($dest_proc->{'mmio'}->{'globalAddr'}) + 
               $dest_proc->{'mmio'}->{'size'} - 1;
      }
    } else {
      # Another XNNE
      my $dest_xnne = $xnneIdMap->{$dest_pid};
      printf xtsc_xnne_routing_tab_file 
             "    $port     $dest_xnne->{'globalAddr'}      ".
             "0x%x           /* $dest_xnne->{'name'} */\n", 
             hex($dest_xnne->{'globalAddr'}) + 
             $dest_xnne->{'size'} - 1;
    }

    $port++;
  }

  close xtsc_xnne_routing_tab_file;
}

# Generate routing tables for the inbound router that routes to the MMIO
# and/or the PIF
sub generateXTSCInboundRoutingTables {
  my ($xtsc_run_gen_dir, $proc, $axi_type) = @_;
  my $axi_type_str = ($axi_type ne "" ? "${axi_type}_" : $axi_type);

  my $xtsc_inbound_routing_tab_file = 
     "$xtsc_run_gen_dir/$proc->{'name'}_inbound_${axi_type_str}rte.tab";

  open(xtsc_inbound_routing_tab_file, ">$xtsc_inbound_routing_tab_file") or 
    sysBuildError("Could not open $xtsc_inbound_routing_tab_file\n");

  print xtsc_inbound_routing_tab_file 
        "/* <Port>  <LowAddr>   <HighAddr>  <NewBaseAddr>  */\n\n";

  # Note, the port numbers should match the port assignment of the
  # inbound router. Connect the inbound PIF, if defined to first port and
  # the local MMIO (if defined) to next port
  my $port = 0;
  if ($proc->{'inBound'}) {
    # InstRAM0
    if (defined $proc->{'instRam0'} and
        defined $proc->{'instRam0'}->{'globalAddr'}) {
      printf xtsc_inbound_routing_tab_file 
             "    $port     $proc->{'instRam0'}->{'globalAddr'}     ".
             "0x%x    $proc->{'instRam0'}->{'localAddr'}    ".
             "/* $proc->{'name'} INSTRAM0 */\n", 
              hex($proc->{'instRam0'}->{'globalAddr'}) + 
              $proc->{'instRam0'}->{'size'} - 1;
    }

    # InstRAM1
    if (defined $proc->{'instRam1'} and
        defined $proc->{'instRam1'}->{'globalAddr'}) {
      printf xtsc_inbound_routing_tab_file 
             "    $port     $proc->{'instRam1'}->{'globalAddr'}     ".
             "0x%x    $proc->{'instRam1'}->{'localAddr'}    ".
             "/* $proc->{'name'} INSTRAM1 */\n", 
             hex($proc->{'instRam1'}->{'globalAddr'}) + 
             $proc->{'instRam1'}->{'size'} - 1;
    }

    # For NX, inst and data have separate slave ports
    if (defined $proc->{'instRam0'} and $proc->{'pipeline'} eq 'NX' and
        defined $proc->{'slaveInstWidth'}) {
      $port++;
    }

    # DataRAM0
    if (defined $proc->{'dataRam0'} and
        defined $proc->{'dataRam0'}->{'globalAddr'}) {
      printf xtsc_inbound_routing_tab_file 
             "    $port     $proc->{'dataRam0'}->{'globalAddr'}     ".
             "0x%x    $proc->{'dataRam0'}->{'localAddr'}    ".
             "/* $proc->{'name'} DATARAM0 */\n", 
             hex($proc->{'dataRam0'}->{'globalAddr'}) + 
             $proc->{'dataRam0'}->{'size'} - 1;
    }

    # DataRAM1
    if (defined $proc->{'dataRam1'} and
        defined $proc->{'dataRam1'}->{'globalAddr'}) {
      printf xtsc_inbound_routing_tab_file 
             "    $port     $proc->{'dataRam1'}->{'globalAddr'}     ".
             "0x%x    $proc->{'dataRam1'}->{'localAddr'}    ".
             "/* $proc->{'name'} DATARAM1 */\n", 
             hex($proc->{'dataRam1'}->{'globalAddr'}) + 
             $proc->{'dataRam1'}->{'size'} - 1;
    }

    if (defined $proc->{'dataRam0'} and
        defined $proc->{'dataRam0'}->{'globalAddr'}) {
      $port++;
    }
  }

  # Local MMIO
  if (defined $proc->{'mmio'}) {
    printf xtsc_inbound_routing_tab_file 
           "    $port     $proc->{'mmio'}->{'globalAddr'}     ".
           "0x%x                  /* $proc->{'name'} MMIO */\n", 
           hex($proc->{'mmio'}->{'globalAddr'}) + $proc->{'mmio'}->{'size'} - 1;
    $port++;
  }

  # Local external xtsc dma
  if (defined $proc->{'sdma'}) {
    printf xtsc_inbound_routing_tab_file 
           "    $port     $proc->{'sdma'}->{'globalAddr'}     ".
           "0x%x                  /* $proc->{'name'} sDMA */\n", 
           hex($proc->{'sdma'}->{'globalAddr'}) + $proc->{'sdma'}->{'size'} - 1;
  }

  close xtsc_inbound_routing_tab_file;
}

# SystemDMA routing tables
sub generateXTSCSystemDMAChannelRoutingTables {
  my $xtsc_run_gen_dir = shift;

  my $xtsc_system_dma_ch_routing_tab_file = 
     "$xtsc_run_gen_dir/SystemDMA_channel_rte.tab";
  open(xtsc_system_dma_ch_routing_tab_file, 
       ">$xtsc_system_dma_ch_routing_tab_file") or
    sysBuildError("Could not open $xtsc_system_dma_ch_routing_tab_file\n");

  print xtsc_system_dma_ch_routing_tab_file 
        "/* <Port>  <LowAddr>   <HighAddr>  <NewBaseAddr>  */\n\n";

  my $size = $SystemDMA->{'size'}/$SystemDMA->{'numChannels'};
  foreach my $ch (0..$SystemDMA->{'numChannels'}-1) {
    my $start_addr = hex($SystemDMA->{'baseAddr'})+$ch*$size;
    printf xtsc_system_dma_ch_routing_tab_file 
           "    $ch    0x%x     0x%x            /* Channel %d */\n", 
           $start_addr, ($start_addr + $size - 1), $ch;
  }

  my $xtsc_system_dma_out_routing_tab_file = 
     "$xtsc_run_gen_dir/SystemDMA_out_rte.tab";
  open(xtsc_system_dma_out_routing_tab_file, 
       ">$xtsc_system_dma_out_routing_tab_file") or
    sysBuildError("Could not open $xtsc_system_dma_out_routing_tab_file\n");

  print xtsc_system_dma_out_routing_tab_file 
        "/* <Port>  <LowAddr>   <HighAddr>  <NewBaseAddr>  */\n\n";

  # First port is to the bus.
  my $port = 1;

  # SubSystemMMIOs
  foreach my $smmio_name (keys %$subSystemMMIOs) {
    my $smmio = $subSystemMMIOs->{$smmio_name};
    foreach my $car (@{$smmio->{'intrRegs'}}) {
      printf xtsc_system_dma_out_routing_tab_file 
             "    $port     $car->{'localAddr'}     ".
             "0x%x            /* $smmio_name */\n", 
             hex($car->{'localAddr'}) + 4 - 1;
    }
    foreach my $car (@{$smmio->{'controlRegs'}}) {
      printf xtsc_system_dma_out_routing_tab_file 
             "    $port     $car->{'localAddr'}     ".
             "0x%x            /* $smmio_name */\n", 
             hex($car->{'localAddr'}) + 4 - 1;
    }
    $port++;
  }
}

# Generate routing tables for inbound from external interface
sub generateXTSCSubSystemInboundRoutingTables {
  my ($xtsc_run_gen_dir, $id) = @_;

  # Find procs in the interface set that have a connection from Bus
  my @procs;
  foreach my $pid (@{$subSysInterconnectTo->{$COMMON_BUS_ID}}) {
    if (isProcId($pid) and $procIdMap->{$pid}->{'extIntfId'} == $id) {
      push @procs, $pid;
    }
  }

  # Find XNNEs in the interface set that have a connection from Bus
  my @xnnes;
  foreach my $xid (@{$subSysInterconnectTo->{$COMMON_BUS_ID}}) {
    if (isXNNEId($xid) and $xnneIdMap->{$xid}->{'extIntfId'} == $id) {
      push @xnnes, $xid;
    }
  }

  if (!scalar @procs and !scalar @xnnes) {
    return;
  }

  my $xtsc_routing_tab_file = 
     "$xtsc_run_gen_dir/SubSystem_inbound_rte${id}.tab";

  open(xtsc_routing_tab_file, ">$xtsc_routing_tab_file") or 
    sysBuildError("Could not open $xtsc_routing_tab_file\n");

  print xtsc_routing_tab_file 
        "/* <Port>  <LowAddr>   <HighAddr>  <NewBaseAddr>  */\n\n";

  # Routing to each proc's (sorted in pid order) local memories (if they
  # are connected. Note, this should match with the port ordering of the 
  # SubSystem inbound router
  my $router_port = 0;
  foreach my $dest_pid (sort {$a<=>$b} @procs) {
    my $proc = $procIdMap->{$dest_pid};
    if ($proc->{'inBound'}) {
      # InstRAM0
      if (defined $proc->{'instRam0'} and 
          defined $proc->{'instRam0'}->{'globalAddr'}) {
        printf xtsc_routing_tab_file 
               "    $router_port     $proc->{'instRam0'}->{'globalAddr'}     ".
               "0x%x            /* $proc->{'name'} INSTRAM0 */\n", 
               hex($proc->{'instRam0'}->{'globalAddr'}) + 
               $proc->{'instRam0'}->{'size'} - 1;
      }

      # InstRAM1
      if (defined $proc->{'instRam1'} and 
          defined $proc->{'instRam1'}->{'globalAddr'}) {
        printf xtsc_routing_tab_file 
               "    $router_port     $proc->{'instRam1'}->{'globalAddr'}     ".
               "0x%x            /* $proc->{'name'} INSTRAM1 */\n", 
               hex($proc->{'instRam1'}->{'globalAddr'}) + 
               $proc->{'instRam1'}->{'size'} - 1;
      }

      # DataRAM0
      if (defined $proc->{'dataRam0'} and 
          defined $proc->{'dataRam0'}->{'globalAddr'}) {
        printf xtsc_routing_tab_file 
               "    $router_port     $proc->{'dataRam0'}->{'globalAddr'}     ".
               "0x%x            /* $proc->{'name'} DATARAM0 */\n", 
               hex($proc->{'dataRam0'}->{'globalAddr'}) + 
               $proc->{'dataRam0'}->{'size'} - 1;
      }

      # DataRAM1
      if (defined $proc->{'dataRam1'} and
          defined $proc->{'dataRam1'}->{'globalAddr'}) {
        printf xtsc_routing_tab_file 
               "    $router_port     $proc->{'dataRam1'}->{'globalAddr'}     ".
               "0x%x            /* $proc->{'name'} DATARAM1 */\n", 
               hex($proc->{'dataRam1'}->{'globalAddr'}) + 
               $proc->{'dataRam1'}->{'size'} - 1;
      }
    }

    # Local MMIO
    if (defined $proc->{'mmio'}) {
      printf xtsc_routing_tab_file 
             "    $router_port     $proc->{'mmio'}->{'globalAddr'}     ".
             "0x%x            /* $proc->{'name'} MMIO */\n", 
             hex($proc->{'mmio'}->{'globalAddr'}) + 
             $proc->{'mmio'}->{'size'} - 1;
    }


    # Local external xtsc dma
    if (defined $proc->{'sdma'}) {
      printf xtsc_routing_tab_file 
             "    $router_port     $proc->{'sdma'}->{'globalAddr'}     ".
             "0x%x            /* $proc->{'name'} sDMA */\n", 
             hex($proc->{'sdma'}->{'globalAddr'}) + 
             $proc->{'sdma'}->{'size'} - 1;
    }

    $router_port++;
  }

  # Routing to each XNNE's (sorted in id order) slave interface (if they
  # are connected. Note, this should match with the port ordering of the 
  # SubSystem inbound router
  foreach my $dest_xid (sort {$a<=>$b} @xnnes) {
    my $xnne = $xnneIdMap->{$dest_xid};
    printf xtsc_routing_tab_file 
           "    $router_port     $xnne->{'globalAddr'}     ".
           "0x%x            /* $xnne->{'name'} */\n", 
           hex($xnne->{'globalAddr'}) + 
           $xnne->{'size'} - 1;
    $router_port++;
  }
}

# Generate routing tables for the Bus router
sub generateXTSCBusRoutingTables {
  my $xtsc_run_gen_dir = shift;

  my $xtsc_bus_routing_tab_file = "$xtsc_run_gen_dir/BUS_rte.tab";

  open(xtsc_bus_routing_tab_file, ">$xtsc_bus_routing_tab_file") or 
    sysBuildError("Could not open $xtsc_bus_routing_tab_file\n");

  print xtsc_bus_routing_tab_file 
        "/* <Port>  <LowAddr>   <HighAddr>  <NewBaseAddr>  */\n\n";

  # Routing to each proc's (sorted in pid order) local memories (if they
  # are connected. Note, this should match with the port ordering of the 
  # bus router
  my $bus_router_port = 0;
  foreach my $extIntf (@subSystemExternalInterfaces) {
    # Find procs in the interface set that have a connection from Bus
    my @procs;
    foreach my $pid (@{$subSysInterconnectTo->{$COMMON_BUS_ID}}) {
      if (isProcId($pid) and 
          $procIdMap->{$pid}->{'extIntfId'} == $extIntf->{'id'}) {
        push @procs, $pid;
      }
    }
    # Find XNNEs in the interface set that have a connection from Bus
    my @xnnes;
    foreach my $xid (@{$subSysInterconnectTo->{$COMMON_BUS_ID}}) {
      if (isXNNEId($xid) and 
          $xnneIdMap->{$xid}->{'extIntfId'} == $extIntf->{'id'}) {
        push @xnnes, $xid;
      }
    }
    if (!scalar @procs and !scalar @xnnes) {
      next;
    }
    foreach my $dest_pid (sort {$a<=>$b} @procs) {
      my $proc = $procIdMap->{$dest_pid};
      if ($proc->{'inBound'}) {
        # InstRAM0
        if (defined $proc->{'instRam0'} and 
            defined $proc->{'instRam0'}->{'globalAddr'}) {
          printf xtsc_bus_routing_tab_file 
                 "    $bus_router_port     ".
                 "$proc->{'instRam0'}->{'globalAddr'}     ".
                 "0x%x                  /* $proc->{'name'} INSTRAM0 */\n", 
                 hex($proc->{'instRam0'}->{'globalAddr'}) + 
                 $proc->{'instRam0'}->{'size'} - 1;
        }

        # InstRAM1
        if (defined $proc->{'instRam1'} and 
            defined $proc->{'instRam1'}->{'globalAddr'}) {
          printf xtsc_bus_routing_tab_file 
                 "    $bus_router_port     ".
                 "$proc->{'instRam1'}->{'globalAddr'}     ".
                 "0x%x                  /* $proc->{'name'} INSTRAM1 */\n", 
                 hex($proc->{'instRam1'}->{'globalAddr'}) + 
                 $proc->{'instRam1'}->{'size'} - 1;
        }

        # DataRAM0
        if (defined $proc->{'dataRam0'} and 
            defined $proc->{'dataRam0'}->{'globalAddr'}) {
          printf xtsc_bus_routing_tab_file 
                 "    $bus_router_port     ".
                 "$proc->{'dataRam0'}->{'globalAddr'}     ".
                 "0x%x                  /* $proc->{'name'} DATARAM0 */\n", 
                 hex($proc->{'dataRam0'}->{'globalAddr'}) + 
                 $proc->{'dataRam0'}->{'size'} - 1;
        }

        #  DataRAM1
        if (defined $proc->{'dataRam1'} and
            defined $proc->{'dataRam1'}->{'globalAddr'}) {
          printf xtsc_bus_routing_tab_file 
                 "    $bus_router_port     ".
                 "$proc->{'dataRam1'}->{'globalAddr'}     ".
                 "0x%x                  /* $proc->{'name'} DATARAM1 */\n", 
                 hex($proc->{'dataRam1'}->{'globalAddr'}) + 
                 $proc->{'dataRam1'}->{'size'} - 1;
        }
      }

      # Local MMIO
      if (defined $proc->{'mmio'}) {
        printf xtsc_bus_routing_tab_file 
               "    $bus_router_port     ".
               "$proc->{'mmio'}->{'globalAddr'}     ".
               "0x%x                  /* $proc->{'name'} MMIO */\n", 
               hex($proc->{'mmio'}->{'globalAddr'}) + 
               $proc->{'mmio'}->{'size'} - 1;
      }

      # Local external xtsc dma
      if (defined $proc->{'sdma'}) {
        printf xtsc_bus_routing_tab_file 
               "    $bus_router_port     $proc->{'sdma'}->{'globalAddr'}     ".
               "0x%x                  /* $proc->{'name'} sDMA */\n", 
               hex($proc->{'sdma'}->{'globalAddr'}) + 
               $proc->{'sdma'}->{'size'} - 1;
      }
    }
    # Add XNNE
    foreach my $dest_xid (sort {$a<=>$b} @xnnes) {
      my $xnne = $xnneIdMap->{$dest_xid};
      printf xtsc_bus_routing_tab_file 
             "    $bus_router_port     $xnne->{'globalAddr'}     ".
             "0x%x                  /* $xnne->{'name'} */\n", 
             hex($xnne->{'globalAddr'}) + 
             $xnne->{'size'} - 1;
    }
    $bus_router_port++;
  }

  # SystemRAM
  printf xtsc_bus_routing_tab_file 
         "    $bus_router_port     $systemRAM->{'globalAddr'}     ".
         "0x%x                  /* System RAM */\n", 
         hex($systemRAM->{'globalAddr'}) + $systemRAM->{'size'} - 1;
  $bus_router_port++;

  # Optional SystemROM
  if (defined $systemROM->{'globalAddr'}) {
    printf xtsc_bus_routing_tab_file 
           "    $bus_router_port     $systemROM->{'globalAddr'}     ".
           "0x%x                  /* System ROM */\n", 
           hex($systemROM->{'globalAddr'}) + $systemROM->{'size'} - 1;
    $bus_router_port++;
  }

  # Device memories
  foreach my $devMem (@DeviceMemories) {
    # Skip routing table entry for the the special __DefaultMem__
    # If present, it is the default port
    if ($devMem->{'name'} eq '__DefaultMem__') {
      next;
    }
    printf xtsc_bus_routing_tab_file 
           "    $bus_router_port     $devMem->{'globalAddr'}     ".
           "0x%x                  /* DeviceMemory: $devMem->{'name'} */\n", 
           hex($devMem->{'globalAddr'}) + $devMem->{'size'} - 1;
    $bus_router_port++;
  }

  # L2
  foreach my $l2 (values %$subSystemL2s) {
    printf xtsc_bus_routing_tab_file 
           "    $bus_router_port     $l2->{'globalAddr'}     ".
           "0x%x                  /* $l2->{'name'} */\n", 
           hex($l2->{'globalAddr'}) + $l2->{'size'} - 1;
    $bus_router_port++;
  }

  # SystemDMA
  if (defined $SystemDMA->{'baseAddr'}) {
    printf xtsc_bus_routing_tab_file 
           "    $bus_router_port     $SystemDMA->{'baseAddr'}     ".
           "0x%x                  /* SystemDMA */\n", 
           hex($SystemDMA->{'baseAddr'}) + $SystemDMA->{'size'} - 1;
    $bus_router_port++;
  }

  # SubSystemMMIO mmio
  foreach my $smmio_name (keys %$subSystemMMIOs) {
    my $smmio = $subSystemMMIOs->{$smmio_name};
    foreach my $car (@{$smmio->{'intrRegs'}}) {
      printf xtsc_bus_routing_tab_file 
             "    $bus_router_port     $car->{'globalAddr'}     ".
             "0x%x    $car->{'localAddr'}    /* $smmio_name */\n", 
             hex($car->{'globalAddr'}) + 4 - 1;
    }
    foreach my $car (@{$smmio->{'controlRegs'}}) {
      printf xtsc_bus_routing_tab_file 
             "    $bus_router_port     $car->{'globalAddr'}     ".
             "0x%x    $car->{'localAddr'}    /* $smmio_name */\n", 
             hex($car->{'globalAddr'}) + 4 - 1;
    }
    $bus_router_port++;
  }
  close xtsc_bus_routing_tab_file;
}

# Routing table for the first level uDMA router that routes requests to 
# dataram0/dataram1
sub generateXTSCuDMARoutingTable {
  my ($xtsc_run_gen_dir, $proc) = @_;

  my $xtsc_udma_routing_tab_file = 
     "$xtsc_run_gen_dir/$proc->{'name'}_udma_rte.tab";

  open(xtsc_udma_routing_tab_file, ">$xtsc_udma_routing_tab_file") or 
    sysBuildError("Could not open $xtsc_udma_routing_tab_file\n");

 print xtsc_udma_routing_tab_file 
       "/* <Port>  <LowAddr>   <HighAddr>  <NewBaseAddr>  */\n\n";

  printf xtsc_udma_routing_tab_file 
         "    0      0x%x  0x%x                    ".
         "/* $proc->{'name'} DATARAM0 */\n", 
         hex($proc->{'dataRam0'}->{'localAddr'}), 
         hex($proc->{'dataRam0'}->{'localAddr'}) + 
         $proc->{'dataRam0'}->{'size'} - 1;

  if (defined $proc->{'dataRam1'}) {
    printf xtsc_udma_routing_tab_file 
           "    1      0x%x  0x%x                    ".
           "/* $proc->{'name'} DATARAM1 */\n", 
           hex($proc->{'dataRam1'}->{'localAddr'}), 
           hex($proc->{'dataRam1'}->{'localAddr'}) + 
           $proc->{'dataRam1'}->{'size'} - 1;
  }

  close xtsc_udma_routing_tab_file;
}

# Top level function to generate different xtsc-run components
sub generateXTSCrun {
  my $xtsc_run_gen_dir = shift;

  printLog($logDebugLevel2, "In generateXTSCrun()\n");

  my $xtsc_run_inc_file = "$xtsc_run_gen_dir/$subSystemName.inc";

  if (-d $xtsc_run_gen_dir) {
    rmtree($xtsc_run_gen_dir);
    $? == 0 or sysBuildError("Cannot delete $xtsc_run_gen_dir\n");
  }
  mkpath($xtsc_run_gen_dir);
  $? == 0 || die sysBuildError("Cannot create $xtsc_run_gen_dir\n");

  open(xtsc_run_inc_file, ">$xtsc_run_inc_file") or 
    sysBuildError("Could not open $xtsc_run_inc_file\n");

  my @header;
  my @body;
  # Initial stuff
  # push @header, 
  # "// Auto-generated by $thisScript from $subSysFile on ".localtime()."\n\n";
  push @header, "// Copyright (c) 2005-2020 by Cadence Design Systems, Inc.  ".
                "ALL RIGHTS RESERVED.\n";
  push @header, "// These coded instructions, statements, and ".
                "computer programs are the\n";
  push @header, "// copyrighted works and confidential proprietary ".
                 "information of\n";
  push @header, "// Cadence Design Systems, Inc. They may not be modified, ".
                 "copied, reproduced,\n";
  push @header, "// distributed, or disclosed to third parties in ".
                "any manner, medium, or form,\n";
  push @header, "// in whole or in part, without the prior ".
                "written consent of Cadence Design\n";
  push @header, "// Systems, Inc.\n";
  push @header, "\n";

  # Generate memory latency parameters
  foreach my $mem ($systemRAM, $systemROM, @DeviceMemories) {
    if (!defined $mem->{'globalAddr'}) {
      next;
    }
    push @header, "// Defines for latencies for $mem->{'name'}\n";
    push @header, "#ifndef ".uc($mem->{'name'})."_READ_DELAY\n";
    push @header, "#define ".uc($mem->{'name'})."_READ_DELAY " . 
                  $mem->{'read_delay'} . "\n";
    push @header, "#endif\n";
    push @header, "\n";
    push @header, "#ifndef ".uc($mem->{'name'})."_WRITE_DELAY\n";
    push @header, "#define ".uc($mem->{'name'})."_WRITE_DELAY " . 
                  $mem->{'write_delay'} . "\n";
    push @header, "#endif\n";
    push @header, "\n";
    push @header, "#ifdef ".uc($mem->{'name'})."_DELAY\n";
    push @header, "#define ".uc($mem->{'name'})."_READ_DELAY " . 
                  "\$(".uc($mem->{'name'})."_DELAY)\n";
    push @header, "#define ".uc($mem->{'name'})."_WRITE_DELAY " . 
                  "\$(".uc($mem->{'name'})."_DELAY)\n";
    push @header, "#endif\n";
    push @header, "\n";
    push @header, "#ifndef ".uc($mem->{'name'})."_WRITE_RESPONSE\n";
    push @header, "#define ".uc($mem->{'name'})."_WRITE_RESPONSE " . 
                  $mem->{'write_response'} . "\n";
    push @header, "#endif\n";
    push @header, "\n";
    push @header, "#ifndef ".uc($mem->{'name'})."_REQUEST_FIFO_DEPTH\n";
    push @header, "#define ".uc($mem->{'name'})."_REQUEST_FIFO_DEPTH " . 
                  $mem->{'request_fifo_depth'} . "\n";
    push @header, "#endif\n";
    push @header, "\n";
    push @header, "#ifndef ".uc($mem->{'name'})."_CLOCK\n";
    push @header, "#define ".uc($mem->{'name'})."_CLOCK 0xffffffff\n" ;
    push @header, "#endif\n";
    push @header, "\n";
    push @header, "#ifndef ".uc($mem->{'name'})."_PROFILE_INTERVAL\n";
    push @header, "#define ".uc($mem->{'name'})."_PROFILE_INTERVAL 1000000\n" ;
    push @header, "#endif\n";
    push @header, "\n";
  }

  # For L2 RAM
  foreach my $l2 (values %$subSystemL2s) {
    if (!$l2->{'isL2CC'}) {
      push @header, "// Defines for latencies for $l2->{'name'} RAM\n";
      push @header, "#ifndef ".uc($l2->{'name'})."_READ_DELAY\n";
      push @header, "#define ".uc($l2->{'name'})."_READ_DELAY " . 
                    $l2->{'read_delay'} . "\n";
      push @header, "#endif\n";
      push @header, "\n";
      push @header, "#ifndef ".uc($l2->{'name'})."_WRITE_DELAY\n";
      push @header, "#define ".uc($l2->{'name'})."_WRITE_DELAY " . 
                    $l2->{'write_delay'} . "\n";
      push @header, "#endif\n";
      push @header, "\n";
      push @header, "#ifdef ".uc($l2->{'name'})."_DELAY\n";
      push @header, "#define ".uc($l2->{'name'})."_READ_DELAY " . 
                    "\$(".uc($l2->{'name'})."_DELAY)\n";
      push @header, "#define ".uc($l2->{'name'})."_WRITE_DELAY " . 
                    "\$(".uc($l2->{'name'})."_DELAY)\n";
      push @header, "#endif\n";
      push @header, "\n";

      push @header, "#ifndef ".uc($l2->{'name'})."_WRITE_RESPONSE\n";
      push @header, "#define ".uc($l2->{'name'})."_WRITE_RESPONSE " . 
                    $l2->{'write_response'} . "\n";
      push @header, "#endif\n";
      push @header, "\n";
      push @header, "#ifndef ".uc($l2->{'name'})."_REQUEST_FIFO_DEPTH\n";
      push @header, "#define ".uc($l2->{'name'})."_REQUEST_FIFO_DEPTH " . 
                    $l2->{'request_fifo_depth'} . "\n";
      push @header, "#endif\n";
      push @header, "\n";
    push @header, "#ifndef ".uc($l2->{'name'})."_PROFILE_INTERVAL\n";
    push @header, "#define ".uc($l2->{'name'})."_PROFILE_INTERVAL 1000000\n" ;
    push @header, "#endif\n";
    push @header, "\n";
    }
  }

  # Generate define for parameters passed to the core
  foreach my $pid (sort {$a<=>$b} keys %$procIdMap) {
    my $proc = $procIdMap->{$pid};
    push @header, "// Defines for $proc->{'name'}\n";
    push @header, "#ifndef $proc->{'name'}_CONFIG\n";
    push @header, "#define $proc->{'name'}_CONFIG $proc->{'config'}\n";
    push @header, "#endif\n";
    push @header, "\n";

    push @header, "#ifndef $proc->{'name'}_XTENSA_PARAMS\n";
    push @header, "#define $proc->{'name'}_XTENSA_PARAMS\n";
    push @header, "#endif\n";
    push @header, "\n";

    push @header, "#ifndef $proc->{'name'}_SIM_CLIENT_FILE\n";
    push @header, "#define $proc->{'name'}_SIM_CLIENT_FILE\n";
    push @header, "#endif\n";
    push @header, "\n";

    push @header, "#ifndef $proc->{'name'}_SIM_STATIC_VECTOR_SEL\n";
    push @header, "#define $proc->{'name'}_SIM_STATIC_VECTOR_SEL ".
                  "$proc->{'staticVectorSel'}\n";
    push @header, "#endif\n";
    push @header, "\n";

    push @header, "#ifndef $proc->{'name'}_SIM_PREFETCH\n";
    push @header, "#define $proc->{'name'}_SIM_PREFETCH\n";
    push @header, "#endif\n";
    push @header, "\n";

    if (defined $proc->{'altResetVecAddr'}) {
      push @header, "#ifndef $proc->{'name'}_ALT_RESET_VEC\n";
      push @header, "#define $proc->{'name'}_ALT_RESET_VEC ".
                    "$proc->{'altResetVecAddr'}\n";
      push @header, "#endif\n";
    }

    if (defined $proc->{'sdma'}) {
      push @header, 
           "#ifndef $proc->{'name'}_SDMA_MAX_OUTSTANDING_SYS_DMA_REQ\n";
      push @header, "#define $proc->{'name'}_SDMA_MAX_OUTSTANDING_SYS_DMA_REQ ".
                    "$proc->{'sdma'}->{'numRequests'}\n";
      push @header, "#endif\n";
    }
    push @header, "\n";
  }

  # Generate SystemDMA paramters
  if (defined $SystemDMA->{'baseAddr'}) {
    push @header, "// Defines for System DMA\n";
    push @header, "#ifndef MAX_OUTSTANDING_SYS_DMA_REQ\n";
    push @header, "#define MAX_OUTSTANDING_SYS_DMA_REQ 16\n";
    push @header, "#endif\n";
    push @header, "\n";
  }

  push @header, "#ifdef ".uc($systemRAM->{'name'})."_PROFILE\n";
  push @header, "--user_state=ReportSysMemSummary=\$(".
                uc($systemRAM->{'name'})."_PROFILE)\n";
  push @header, "#else\n";
  push @header, "--user_state=ReportSysMemSummary=0\n";
  push @header, "#endif\n";
  push @header, "\n";

  foreach my $xnne (values %$xnneNameMap) {
    push @header, "// Defines for XNNE $xnne->{'name'}\n";
    push @header, "#ifndef ".uc($xnne->{'name'})."_BASE_ADDRESS\n";
    push @header, "#define ".uc($xnne->{'name'})."_BASE_ADDRESS ".
                  "$xnne->{'globalAddr'}\n";
    push @header, "#endif\n";
    push @header, "#ifndef ".uc($xnne->{'name'})."_VPU_CONFIG\n";
    push @header, "#define ".uc($xnne->{'name'})."_VPU_CONFIG ".
                  "$xnne->{'vpu'}\n";
    push @header, "#endif\n";
    push @header, "#ifndef ".uc($xnne->{'name'})."_LOAD_FILE\n";
    push @header, "#define ".uc($xnne->{'name'})."_LOAD_FILE\n";
    push @header, "#endif\n";
    push @header, "#ifndef ".uc($xnne->{'name'})."_SBLK_COMPARE\n";
    push @header, "#define ".uc($xnne->{'name'})."_SBLK_COMPARE 0\n";
    push @header, "#endif\n";
    push @header, "#ifndef ".uc($xnne->{'name'})."_NUM_SBLKS\n";
    push @header, "#define ".uc($xnne->{'name'})."_NUM_SBLKS 1\n";
    push @header, "#endif\n";
    push @header, "#ifndef ".uc($xnne->{'name'})."_NUM_MBLKS\n";
    push @header, "#define ".uc($xnne->{'name'}).
                  "_NUM_MBLKS $xnne->{'numMBLKS'}\n";
    push @header, "#endif\n";
    push @header, "#ifndef ".uc($xnne->{'name'})."_UBUF_SIZE\n";
    push @header, "#define ".uc($xnne->{'name'}).
                  "_UBUF_SIZE $xnne->{'ubufSize'}\n";
    push @header, "#endif\n";
    push @header, "#ifndef ".uc($xnne->{'name'})."_IBUF_SIZE\n";
    push @header, "#define ".uc($xnne->{'name'})."_IBUF_SIZE 0\n";
    push @header, "#endif\n";
    push @header, "#ifndef ".uc($xnne->{'name'})."_OBUF_SIZE\n";
    push @header, "#define ".uc($xnne->{'name'})."_OBUF_SIZE 0\n";
    push @header, "#endif\n";
    push @header, "#ifndef ".uc($xnne->{'name'})."_CBUF_SIZE\n";
    push @header, "#define ".uc($xnne->{'name'})."_CBUF_SIZE 0\n";
    push @header, "#endif\n";
    push @header, "#ifndef ".uc($xnne->{'name'})."_DEBUG_VPU\n";
    push @header, "#define ".uc($xnne->{'name'})."_DEBUG_VPU 0\n";
    push @header, "#endif\n";
    push @header, "#ifndef ".uc($xnne->{'name'})."_FIRMWARE_SIMCALL\n";
    push @header, "#define ".uc($xnne->{'name'})."_FIRMWARE_SIMCALL ".
                  "\$(XTSC_SCRIPT_FILE_PATH)/XNNE_firmware_simcall.vec\n";
    push @header, "#endif\n";
    push @header, "\n";
  }
  
  # Generate define for the xtsc logger
  push @header, "// Define the XTSC logger\n";
  push @header, "#ifdef XTSC_LOG\n";
  push @header, 
       "--logging=\$(XTSC_SCRIPT_FILE_PATH)/$subSystemName.logger.txt\n";
  push @header, "#endif\n";
  push @header, "\n";

  # Check if there are any NX proc, and use that for setting up mem ports
  # else use default master proc
  my $mem_config = $subSysMasterProc;
  my $has_nx = 0;
  foreach my $proc (values %$procNameMap) {
    if ($proc->{'pipeline'} eq 'NX') {
      $mem_config = $proc;
      $has_nx = 1;
      last;
    }
  }

  # Use ISS internal models for NX

  push @header, "--no_default_local_mem\n";
  push @header, "\n";

  push @header, "--xtensa_core=\$($mem_config->{'name'}_CONFIG)\n";
  push @header, "\n";

  foreach my $devMem (@DeviceMemories) {
    if ($devMem->{'host_shared'} == 1) {
      push @header, "// Host shared memory name\n";
      push @header, "#ifndef " . uc($devMem->{'name'}) . "_NAME\n";
      push @header, "#define " . uc($devMem->{'name'}) . 
                    "_NAME " . $devMem->{'host_name'} . "\n";
      push @header, "#endif\n";
      push @header, "\n";
      push @header, "--user_state=" . 
                    uc($devMem->{'name'}). "_FILE=\$(".
                    uc($devMem->{'name'})."_NAME)\n\n";
    }
  }

  foreach my $l2 (values %$subSystemL2s) {
    if ((!$l2->{'isL2CC'} or $l2->{'ramOnly'}) and $l2->{'host_shared'}) {
      push @header, "// Host shared memory name\n";
      push @header, "#ifndef " . uc($l2->{'name'}). "_NAME\n";
      push @header, "#define " . uc($l2->{'name'}). "_NAME " . 
                    $l2->{'name'} . "\n";
      push @header, "#endif\n";
      push @header, "\n";
    }
  }

  push @header, "// Set proxy Lua script polling interval\n";
  push @header, "#ifndef PROXY_POLL_INTERVAL\n";
  push @header, "#define PROXY_POLL_INTERVAL 1000000\n";
  push @header, "#endif\n";
  push @header, "\n";
  push @header, "--user_state=PROXY_POLL_INTERVAL=\$(PROXY_POLL_INTERVAL)\n";

  generateXTSCLogger($xtsc_run_gen_dir);

  generateXTSCXNNEFirmware($xtsc_run_gen_dir);

  generateXTSCProfileCmds($xtsc_run_gen_dir);

  generateXTSCTestBenchMasterVecAndRoutingTable($xtsc_run_gen_dir);

  # Create system ram, system rom, DeviceMemories, and arbiter
  generateXTSCSystemMemory(\@body, $systemRAM->{'name'}, $systemRAM, 
                           $mem_config);

  if (defined $systemROM->{'globalAddr'}) {
    generateXTSCSystemMemory(\@body, $systemROM->{'name'}, $systemROM, 
                             $mem_config);
  }

  foreach my $devMem (@DeviceMemories) {
    generateXTSCSystemMemory(\@body, $devMem->{'name'}, $devMem, $mem_config);
  }

  # Generate all L2s
  foreach my $l2 (values %$subSystemL2s) {
    generateXTSCL2(\@body, $l2, $mem_config, $xtsc_run_gen_dir);
  }

  if (defined $SystemDMA->{'baseAddr'}) {
    generateXTSCSystemDMA(\@body);
  }

  # Generate the xtsc components for the processor node. This consists
  # of the proc, the local memories and the assoicated routers and arbiters,
  # udma and its routers, the outbound arbiter (proc vs. udma), and inbound
  # router
  foreach my $pid (sort {$a<=>$b} keys %$procIdMap) {
    my $proc = $procIdMap->{$pid};
    my @proc_body;
    push @proc_body, "// Build $proc->{'name'}'s components\n";
    push @proc_body, "\n";

    generateXTSCproc(\@proc_body, $proc);

    if (defined $proc->{'udma'}) {
      generateXTSCudma(\@proc_body, $proc);
    }

    if (defined $proc->{'sdma'}) {
      generateXTSCsdma(\@proc_body, $proc);
    }

    if (defined $proc->{'instRam0'}) {
      generateXTSCInstRam(\@proc_body, $proc, $IRAM0);
      generateXTSCInstRamArbiters(\@proc_body, $proc, $IRAM0,
                                  $INSTRAM_ARB_ROUTE_ID_LSB);
    }

    if (defined $proc->{'instRam1'}) {
      generateXTSCInstRam(\@proc_body, $proc, $IRAM1);
      generateXTSCInstRamArbiters(\@proc_body, $proc, $IRAM1,
                                  $INSTRAM_ARB_ROUTE_ID_LSB);
    }

    if (defined $proc->{'dataRam0'}) {
      generateXTSCDataRam(\@proc_body, $proc, $DRAM0);
      generateXTSCDataRamArbiters(\@proc_body, $proc, $DRAM0, 
                                  $DATARAM_ARB_ROUTE_ID_LSB);
    }

    if (defined $proc->{'dataRam1'}) {
      generateXTSCDataRam(\@proc_body, $proc, $DRAM1);
      generateXTSCDataRamArbiters(\@proc_body, $proc, $DRAM1,
                                  $DATARAM_ARB_ROUTE_ID_LSB);
    }

    if (defined $proc->{'sharedLmemCid'}) {
      my $cid = $proc->{'sharedLmemCid'};
      my $cluster_proc = ${$sharedLocalMemClusterMap->{$cid}}[0];
      if ($proc != $cluster_proc) {
        if (defined $cluster_proc->{'dataRam0'}) {
          generateXTSCSharedLmemDataRamArbiterInterconnect(
                                       \@proc_body, $proc, $cluster_proc, $cid,
                                       $DRAM0, $DATARAM_ARB_ROUTE_ID_LSB);
        }
        if (defined $cluster_proc->{'dataRam1'}) {
          generateXTSCSharedLmemDataRamArbiterInterconnect(
                                       \@proc_body, $proc, $cluster_proc, $cid,
                                       $DRAM1, $DATARAM_ARB_ROUTE_ID_LSB);
        }
      }
    }

    if (defined $proc->{'mmio'}) {
      generateXTSClocalMMIO(\@proc_body, $proc);
      if ($proc->{'axi'}) {
        generateXTSClocalMMIOArbiter(\@proc_body, $proc);
      }
    }

    if (defined $proc->{'udma'}) {
      connectXTSCudma(\@proc_body, $proc);
    }

    if ($proc->{'axi'} && $proc->{'pipeline'} eq 'LX') {
      push @proc_body, "// Instantiate the AXI <-> PIF transactors\n";
      push @proc_body, "--set_xtsc_pif2axi_transactor_parm=pif_byte_width=".
                       "$proc->{'pifWidth'}\n";
      push @proc_body, "--set_xtsc_pif2axi_transactor_parm=axi_byte_width=".
                       "$proc->{'pifWidth'}\n";
      push @proc_body, "--create_xtsc_pif2axi_transactor=".
                       "$proc->{'name'}_PIF2AXI_xtor\n";
      push @proc_body, "\n";
      push @proc_body, "// Connect the pif to the PIF2AXI transactors\n";
      push @proc_body, "--connect=$proc->{'name'},pif,slave_port,".
                       "$proc->{'name'}_PIF2AXI_xtor\n";
      push @proc_body, "\n";
    }

    if ($proc->{'axi'} && $proc->{'pipeline'} eq 'LX' && 
        defined $proc->{'idma'}) {
      push @proc_body, "// Instantiate the AXI <-> PIF transactors (idma)\n";
      push @proc_body, "--set_xtsc_pif2axi_transactor_parm=pif_byte_width=".
                       "$proc->{'dmaWidth'}\n";
      push @proc_body, "--set_xtsc_pif2axi_transactor_parm=axi_byte_width=".
                       "$proc->{'dmaWidth'}\n";
      push @proc_body, "--create_xtsc_pif2axi_transactor=".
                       "$proc->{'name'}_idma_PIF2AXI_xtor\n";
      push @proc_body, "\n";
      push @proc_body, "// Connect the idma to the PIF2AXI transactors ".
                       "and split to read/write\n";
      push @proc_body, "--connect=$proc->{'name'},idma0,slave_port,".
                       "$proc->{'name'}_idma_PIF2AXI_xtor\n";
      push @proc_body, "\n";
    }

    if ($proc->{'axi'} && $proc->{'pipeline'} eq 'LX' &&
        $proc->{'inBound'}) {
      push @proc_body, "// Instantiate the AXI <-> PIF transactors (inbound)\n";

      push @proc_body, "--set_xtsc_axi2pif_transactor_parm=axi_byte_width=".
                       "$proc->{'pifWidth'}\n";
      push @proc_body, "--create_xtsc_axi2pif_transactor=".
                       "$proc->{'name'}_inbound_AXI2PIF_xtor\n";
      push @proc_body, "\n";

      push @proc_body, "// Connect inbound AXI arbiter to $proc->{'name'} ".
                       "inbound PIF through the transactors\n";
      push @proc_body, "--connect=$proc->{'name'}_inbound_AXI2PIF_xtor,".
                       "master_port,inbound_pif,$proc->{'name'}\n";
      push @proc_body, "\n";
    }

    if ($subSysInterconnectFrom->{$proc->{'id'}}) {
      generateXTSCInboundRouter(\@proc_body, $proc, 
                               ($proc->{'axi'} ? "rd" : ""));
      if ($proc->{'axi'}) {
        generateXTSCInboundRouter(\@proc_body, $proc, "wr");
      }
    }

    # Define the arbiter when there is shared IDMA or UDMA or using AXI
    if ((defined $proc->{'idma'} and $proc->{'idma'}->{'shared'}) || 
        defined $proc->{'udma'} ||
        (defined $proc->{'sdma'} and $proc->{'sdma'}->{'shared'}) ||
        $proc->{'axi'}) {
      generateXTSCOutboundArbiter(\@proc_body, $proc, 
                                  $OUTBOUND_PROC_ARB_ROUTE_ID_LSB,
                                  ($proc->{'axi'} ? "rd" : ""));
    }
    if ($proc->{'axi'} and 
        ((defined $proc->{'idma'} and $proc->{'idma'}->{'shared'}) || 
         defined $proc->{'udma'} ||
         (defined $proc->{'sdma'} and $proc->{'sdma'}->{'shared'}))) {
      generateXTSCOutboundArbiter(\@proc_body, $proc,
                                  $OUTBOUND_PROC_ARB_ROUTE_ID_LSB, "wr");
    }

    # Create an arbiter between sDMA and iDMA
    if (defined $proc->{'idma'} and defined $proc->{'sdma'}) {
      generateXTSCDMAArbiter(\@proc_body, $proc, 
                             $OUTBOUND_PROC_ARB_ROUTE_ID_LSB,
                             ($proc->{'axi'} ? "rd" : ""));
      if ($proc->{'axi'}) {
        generateXTSCDMAArbiter(\@proc_body, $proc, 
                               $OUTBOUND_PROC_ARB_ROUTE_ID_LSB, "wr");
      }
    }

    # Generate per-processor inc file
    my $proc_inc_file = "$xtsc_run_gen_dir/$proc->{'name'}.inc";
    open(proc_inc_file, ">$proc_inc_file") or 
      sysBuildError("Could not open $proc_inc_file\n");
    foreach my $l (@proc_body) {
      print proc_inc_file $l;
    }
    close proc_inc_file;

    push @body, "// Instantiate $proc->{'name'}'s components\n";
    push @body, "#include \"\$(XTSC_SCRIPT_FILE_PATH)/$proc->{'name'}.inc\"\n";
    push @body, "\n";
  }

  # Connect XNNE
  foreach my $xnneId (sort {$a<=>$b} keys %$xnneIdMap) {
    generateXTSCXNNE(\@body, $xnneIdMap->{$xnneId}, $xtsc_run_gen_dir);
    generateXTSCXNNEInterConnect(\@body, $xnneIdMap->{$xnneId});
  }

  # Inter-processor interconnect consisting of the per-proc inbound arbiter
  # and outbound router

  push @body, "// Instantiate inter-processor interconnect\n";
  push @body, "\n";

  foreach my $pid (sort {$a<=>$b} keys %$procIdMap) {
    my $proc = $procIdMap->{$pid};
    if ($subSysInterconnectFrom->{$proc->{'id'}}) {
      generateXTSCInboundArbiter(\@body, $proc,
                                 $INBOUND_ARB_ROUTE_ID_LSB,
                                 ($proc->{'axi'} ? "rd" : ""));
      if ($proc->{'axi'}) {
        generateXTSCInboundArbiter(\@body, $proc,
                                   $INBOUND_ARB_ROUTE_ID_LSB, "wr");
      }
    }
    generateXTSCOutboundRouter(\@body, $proc, ($proc->{'axi'} ? "rd" : ""));
    if ($proc->{'axi'}) {
      generateXTSCOutboundRouter(\@body, $proc, "wr");
    }
  }

  generateTestBenchMaster(\@body);

  my $idx = 0;
  foreach my $smmio (values %$subSystemMMIOs) {
    createXTSCSubSystemMMIO(\@body, 
                            $SUBSYSTEM_MMIO_ARB_ROUTE_ID_LSB,
                            $xtsc_run_gen_dir, $smmio);
    generateSubSystemMMIOInterconnect($xtsc_run_gen_dir, \@body, $smmio, $idx);
    $idx++;
  }

  createXTSCSubSystemIO(\@body, $xtsc_run_gen_dir);

  # Generate the subsystem interfaces
  my $arbId = 0;
  foreach my $extIntf (@subSystemExternalInterfaces) {
    generateXTSCSubSystemInboundRouter(\@body, 
                                ($subSysMasterProc->{'axi'} ? "rd" : ""), 
                                $extIntf->{'id'});
    generateXTSCSubsystemOutboundArbiter(\@body, 
        $OUTBOUND_SUBSYS_ARB_ROUTE_ID_LSB,
        $subSysMasterProc->{'axi'} ? "rd" : "",
        $arbId,
        $extIntf->{'procs'},
        $extIntf->{'xnnes'},
        $extIntf->{'numPorts'},
        $extIntf->{'rob'});
    $arbId += $extIntf->{'numPorts'};
  }
  if ($subSysMasterProc->{'axi'}) {
    my $arbId = 0;
    foreach my $extIntf (@subSystemExternalInterfaces) {
      generateXTSCSubSystemInboundRouter(\@body, "wr", $extIntf->{'id'});
      generateXTSCSubsystemOutboundArbiter(\@body, 
        $OUTBOUND_SUBSYS_ARB_ROUTE_ID_LSB, "wr",
        $arbId,
        $extIntf->{'procs'},
        $extIntf->{'xnnes'},
        $extIntf->{'numPorts'},
        $extIntf->{'rob'});
      $arbId += $extIntf->{'numPorts'};
    }
  }

  foreach my $extIntf (@subSystemExternalInterfaces) {
    connectXTSCSubSystemInboundRouter(\@body, 
      ($subSysMasterProc->{'axi'} ? "rd" : ""), $extIntf);
  }

  if ($subSysMasterProc->{'axi'}) {
    foreach my $extIntf (@subSystemExternalInterfaces) {
      connectXTSCSubSystemInboundRouter(\@body, "wr", $extIntf);
    }
  }

  # Generate the bus
  generateXTSCBusArbiterRouter(\@body, $BUS_ARB_ROUTE_ID_LSB,
                               ($subSysMasterProc->{'axi'} ? "rd" : ""));
  if ($subSysMasterProc->{'axi'}) {
    generateXTSCBusArbiterRouter(\@body, $BUS_ARB_ROUTE_ID_LSB, "wr");
  }

  connectXTSCBusRouter(\@body, ($subSysMasterProc->{'axi'} ? "rd" : ""));
  connectXTSCBusArbiter(\@body, ($subSysMasterProc->{'axi'} ? "rd" : ""));
  if ($subSysMasterProc->{'axi'}) {
    connectXTSCBusRouter(\@body, "wr");
    connectXTSCBusArbiter(\@body, "wr");
  }
  connectXTSCInterDevRouterArbiter(\@body, 
                                   ($subSysMasterProc->{'axi'} ? "rd" : ""));
  if ($subSysMasterProc->{'axi'}) {
    connectXTSCInterDevRouterArbiter(\@body, "wr");
  }

  # Connect proc to SubSystemMMIO arbiter
  foreach my $smmio (values %$subSystemMMIOs) {
    connectXTSCDevToSubSystemMMIOArb(\@body, 
                                     ($subSysMasterProc->{'axi'} ? "rd" : ""), 
                                     $smmio);
    if ($subSysMasterProc->{'axi'}) {
      connectXTSCDevToSubSystemMMIOArb(\@body, "wr", $smmio);
    }
  }
 
  # Connect proc to L2
  foreach my $l2 (values %$subSystemL2s) {
    connectXTSCProcToL2(\@body, ($subSysMasterProc->{'axi'} ? "rd" : ""), $l2);
    if ($subSysMasterProc->{'axi'}) {
      connectXTSCProcToL2(\@body, "wr", $l2);
    }
  }

  # MMIO definitions
  foreach my $smmio (values %$subSystemMMIOs) {
    generateSubSystemMMIOMMIODef($xtsc_run_gen_dir, $smmio);
  }

  foreach my $l (@header) {
    print xtsc_run_inc_file $l;
  }
  print xtsc_run_inc_file "\n";
  foreach my $l (@body) {
    print xtsc_run_inc_file $l;
  }

  close xtsc_run_inc_file;

  foreach my $pid (sort {$a<=>$b} keys %$procIdMap) {
    my $proc = $procIdMap->{$pid};
    if (defined $proc->{'mmio'}) {
      generateLocalMMIODef($xtsc_run_gen_dir, $proc);
    }
  }

  # Generate the routing table entries
  foreach my $pid (sort {$a<=>$b} keys %$procIdMap) {
    my $proc = $procIdMap->{$pid};
    if (defined $proc->{'udma'}) {
      generateXTSCuDMARoutingTable($xtsc_run_gen_dir, $proc);
    }
    generateXTSCOutboundRoutingTables($xtsc_run_gen_dir, $proc,
                                      ($proc->{'axi'} ? "rd" : ""));
    generateXTSCDMAOutboundRoutingTables($xtsc_run_gen_dir, $proc,
                                         ($proc->{'axi'} ? "rd" : ""));
    if ($proc->{'axi'}) {
      generateXTSCOutboundRoutingTables($xtsc_run_gen_dir, $proc, "wr");
      generateXTSCDMAOutboundRoutingTables($xtsc_run_gen_dir, $proc, "wr");
    }
    if ($subSysInterconnectFrom->{$proc->{'id'}}) {
      generateXTSCInboundRoutingTables($xtsc_run_gen_dir, $proc,
                                       ($proc->{'axi'} ? "rd" : ""));
      if ($proc->{'axi'}) {
        generateXTSCInboundRoutingTables($xtsc_run_gen_dir, $proc, "wr");
      }
    }
  }

  foreach my $extIntf (@subSystemExternalInterfaces) {
    generateXTSCSubSystemInboundRoutingTables($xtsc_run_gen_dir,
                                              $extIntf->{'id'});
  }
  generateXTSCBusRoutingTables($xtsc_run_gen_dir);

  if (defined $SystemDMA->{'baseAddr'}) {
    generateXTSCSystemDMAChannelRoutingTables($xtsc_run_gen_dir);
  }

  foreach my $xnneId (sort {$a<=>$b} keys %$xnneIdMap) {
    my $xnne = $xnneIdMap->{$xnneId};
    my $portMap = $xnne->{'masterPortMap'};
    my $port = 0;
    foreach (sort keys %$portMap) {
      generateXTSCXNNERoutingTables($xtsc_run_gen_dir, $xnne, $port, "rd");
      generateXTSCXNNERoutingTables($xtsc_run_gen_dir, $xnne, $port, "wr");
      $port++;
    }
  }

  printLog($logDebugLevel1, "Leaving generateXTSCrun()\n");
}

# Generate Makefile for compiling xipc sys files
sub generateSysLibMakefile {
  my ($target_dir, $proc) = @_;

  my $syslib_makefile = "$target_dir/Makefile";

  open(syslib_makefile, ">$syslib_makefile") or 
    sysBuildError("Could not open $syslib_makefile\n");

  my $ltime = localtime();

  # Temporary hack to add path to libxipc, libudma in the Xtensa sources
  my $extraInc = "";
  if (defined $cvsRoot) {
    # Add TargetLibs
    $extraInc = "-I$cvsRoot/Xtensa/Target-libs/libxipc";
  }

  my $xt_clang = File::Spec->catfile($swtools, 'bin/xt-clang');
  my $xt_ar = File::Spec->catfile($swtools, 'bin/xt-ar');
  my $subsys_inc = File::Spec->catfile("..", "include");

  print syslib_makefile <<EOF;
# Copyright (c) 2005-2020 by Cadence Design Systems, Inc.  ALL RIGHTS RESERVED.
# These coded instructions, statements, and computer programs are the
# copyrighted works and confidential proprietary information of 
# Cadence Design Systems, Inc. They may not be modified, copied, reproduced, 
# distributed, or disclosed to third parties in any manner, medium, or form, 
# in whole or in part, without the prior written consent of Cadence Design 
# Systems, Inc.

default: all

LIB = lib\$(CFILE).a

CC =  $xt_clang
AR =  $xt_ar

INCLUDES = -I $subsys_inc $extraInc

CFLAGS = -g -O0 -Wall -Werror

.PHONY: all clean

\$(CFILE).o : \$(CFILE).c
\t\$(CC) --xtensa-system=$xtensaSystem --xtensa-core=\$(XTENSA_CORE) \$(INCLUDES) \$(CFLAGS) -c -o \$@ \$<

all: \$(LIB)

\$(LIB) : \$(CFILE).o
\t\$(AR) --xtensa-system=$xtensaSystem rc \$@ \$^
EOF

  close syslib_makefile;
}

# Compile the xipc_sys files for each target
sub compileSysLib {
  my ($target_dir, $config, $cfile) = @_;

  my $cwd = getcwd();
  chdir($target_dir);
  my $make = File::Spec->catfile($swtools, 'Tools/bin/make');
  system("$make -f Makefile XTENSA_CORE=$config CFILE=$cfile");
  $? == 0 or sysBuildError("Error compiling under $target_dir\n");
  chdir($cwd);
}

# Round to next power of 2
sub next_pow_of_2 {
  local $_ = shift;
  $_ |= $_ >> 1; $_ |= $_ >> 2; $_ |= $_ >> 4; $_ |= $_ >> 8; $_ |= $_ >> 16;
  return ++$_;
}

# Generate xipc_sys for each of the target proc in the subsystem
sub generateXIPCSysLib {
  my ($xipc_sys_lib_gen_dir, $proc) = @_;

  printLog($logDebugLevel2, "In generateXIPCSysLib()\n");

  my $xipc_sys_c = "$xipc_sys_lib_gen_dir/xipc_sys.$proc->{'name'}.c";

  my $procList;
  if (defined $subSystemSoftware->{'xipcProcs'}) {
    $procList = [ map {$procIdMap->{$_}} 
                  sort {$a<=>$b} @{$subSystemSoftware->{'xipcProcs'}} ];
  } else {
    $procList = [ map {$procIdMap->{$_}} sort {$a<=>$b} (keys %$procIdMap) ];
  }

  open(xipc_sys_c, ">$xipc_sys_c") or 
    sysBuildError("Could not open $xipc_sys_c\n");

  my $xipc_path_prefix = "";
  if (!defined $cvsRoot) {
    $xipc_path_prefix = "xtensa/xipc/";
  }

  print xipc_sys_c "/* Copyright (c) 2005-2020 by Cadence Design Systems, Inc.  ALL RIGHTS RESERVED.
 * These coded instructions, statements, and computer programs are the
 * copyrighted works and confidential proprietary information of 
 * Cadence Design Systems, Inc. They may not be modified, copied, reproduced, 
 * distributed, or disclosed to third parties in any manner, medium, or form, 
 * in whole or in part, without the prior written consent of Cadence Design 
 * Systems, Inc.*/\n";

  print xipc_sys_c "\n";
 
  print xipc_sys_c "#include <string.h>\n";
  print xipc_sys_c "#include <xtensa/system/xmp_subsystem.h>\n";
  print xipc_sys_c "#include <${xipc_path_prefix}xipc_addr.h>\n";
  print xipc_sys_c "#include <${xipc_path_prefix}xipc_intr.h>\n";
  print xipc_sys_c "#include <${xipc_path_prefix}xipc_common.h>\n";
  print xipc_sys_c "#include <${xipc_path_prefix}xipc_barrier.h>\n";
  print xipc_sys_c "#include <${xipc_path_prefix}xipc_msg_channel.h>\n";
  print xipc_sys_c "\n";

  if (defined $proc->{'dataRam0'}) {
    if (defined $proc->{'dataRam1'} && 
        hex($proc->{'dataRam1'}->{'localAddr'}) < 
        hex($proc->{'dataRam0'}->{'localAddr'})) {
      print xipc_sys_c 
        "#define DRAM_ATTR    __attribute__((section(\".dram1.data\")))\n";
      print xipc_sys_c 
        "#define DRAM_RO_ATTR __attribute__((section(\".dram1.rodata\")))\n";
    } else {
      print xipc_sys_c 
        "#define DRAM_ATTR    __attribute__((section(\".dram0.data\")))\n";
      print xipc_sys_c 
        "#define DRAM_RO_ATTR __attribute__((section(\".dram0.rodata\")))\n";
    }
  } else {
    print xipc_sys_c "#define DRAM_ATTR\n";
    print xipc_sys_c "#define DRAM_RO_ATTR\n";
  }

  if (defined $proc->{'instRam0'}) {
    print xipc_sys_c 
     "#define IRAM0_ATTR   __attribute__((section(\".iram0.text\")))\n";
  } else {
    print xipc_sys_c "#define IRAM0_ATTR\n";
  }
  print xipc_sys_c "#define WEAK_ATTR    __attribute__((weak))\n";
  print xipc_sys_c "\n";

  print xipc_sys_c "/* Unique name for each processor in the subsystem */\n";
  print xipc_sys_c 
        "const char *xmp_xipc_proc_names[XMP_XIPC_NUM_PROCS] DRAM_ATTR = {\n";
  print xipc_sys_c join(",\n", map("  \"".$_->{'name'}."\"", @$procList))."\n";
  print xipc_sys_c "};\n";
  print xipc_sys_c "\n";

  # Find max of all PRIDs
  my $max_prid = 0;
  foreach my $proc (@$procList) {
    if ($proc->{'prid'} gt $max_prid) {
      $max_prid = $proc->{'prid'};
    }
  }

  print xipc_sys_c "/* Processor ids of all processors in the subsystem ".
                   "indexed using the PRID */\n";
  print xipc_sys_c "const xipc_pid_t xmp_xipc_pids[".($max_prid+1).
                   "] DRAM_RO_ATTR = {\n";
  foreach my $id (0..$max_prid) {
    my @p = grep { $_->{'prid'} eq $id } @$procList;
    if (scalar @p) {
      print xipc_sys_c "  $p[0]->{'id'},\n";
    } else { 
      print xipc_sys_c "  255,\n";
    }
  }
  print xipc_sys_c "};\n";
  print xipc_sys_c "\n";

  print xipc_sys_c "/* PRID mask */\n";
  print xipc_sys_c "const unsigned xmp_xipc_prid_mask DRAM_RO_ATTR = ".
                   ($max_prid == 0 ? 1 : (next_pow_of_2($max_prid)-1)).";\n";
  print xipc_sys_c "\n";

  print xipc_sys_c "/* Number of processors in the subsystem */\n";
  print xipc_sys_c "const xipc_pid_t xmp_xipc_num_procs DRAM_RO_ATTR = ".
                   "XMP_XIPC_NUM_PROCS;\n";
  print xipc_sys_c "\n";

  print xipc_sys_c "/* Id of the master XIPC processor in the subsystem */\n";
  print xipc_sys_c "const xipc_pid_t xmp_xipc_master_pid DRAM_RO_ATTR = ".
                   "XMP_XIPC_MASTER_PID;\n";
  print xipc_sys_c "\n";

  print xipc_sys_c "/* Max dcache linesize across all processors */\n";
  print xipc_sys_c "const uint32_t xmp_xipc_max_dcache_linesize ".
                   "DRAM_RO_ATTR = XMP_MAX_DCACHE_LINESIZE;\n";
  print xipc_sys_c "\n";

  print xipc_sys_c "/* Default interrupt for inter-processor notification */\n";
  print xipc_sys_c "const int32_t xmp_xipc_interrupt_ids[XMP_XIPC_NUM_PROCS] ".
                   "DRAM_RO_ATTR = {\n";
  print xipc_sys_c join(",\n", 
                   map((defined $_->{'mmio'}->{'intrReg'}->{'xipcIntrOffset'} or
                        defined $_->{'xipcSubSystemMMIO'}) 
                          ? "  XMP_$_->{'name'}_XIPC_INTR_ID"
                          : "  -1", @$procList))."\n";
  print xipc_sys_c "};\n";
  print xipc_sys_c "\n";

  print xipc_sys_c 
        "/* MMIO address of the per processor default interrupt register */\n";
  print xipc_sys_c 
        "const uintptr_t xmp_mmio_addrs_xipc_intr[XMP_XIPC_NUM_PROCS] ".
        "DRAM_RO_ATTR = {\n";
  print xipc_sys_c join(",\n", 
                   map((defined $_->{'mmio'}->{'intrReg'}->{'xipcIntrOffset'} or
                        defined $_->{'xipcSubSystemMMIO'}) 
                          ? "  XMP_$_->{'name'}_MMIO_ADDR_XIPC_INTR" 
                          : "  0", @$procList))."\n";
  print xipc_sys_c "};\n";
  print xipc_sys_c "\n";

  print xipc_sys_c "/* Offset within the per-processor interrupt ".
                   "register that triggers the\n";
  print xipc_sys_c " * default interrupt */\n";
  print xipc_sys_c 
        "const uint8_t xmp_mmio_offsets_xipc_intrs[XMP_XIPC_NUM_PROCS] ".
        "DRAM_RO_ATTR = {\n";
  print xipc_sys_c join(",\n", 
                   map((defined $_->{'mmio'}->{'intrReg'}->{'xipcIntrOffset'} or
                        defined $_->{'xipcSubSystemMMIO'}) 
                          ? "  XMP_$_->{'name'}_MMIO_OFFSET_XIPC_INTR" 
                          : "  0", @$procList))."\n";
  print xipc_sys_c "};\n";
  print xipc_sys_c "\n";

  print xipc_sys_c 
        "/* Bitmask corresponding to above offset that triggers the\n";
  print xipc_sys_c " * default interrupt */\n";
  print xipc_sys_c "const uint32_t xmp_mask_xipc_intrs[XMP_XIPC_NUM_PROCS] ".
                   "DRAM_RO_ATTR = {\n";
  print xipc_sys_c join(",\n", 
                   map((defined $_->{'mmio'}->{'intrReg'}->{'xipcIntrOffset'} or
                        defined $_->{'xipcSubSystemMMIO'}) 
                          ? "  1 << XMP_$_->{'name'}_MMIO_OFFSET_XIPC_INTR" 
                          : "  0", @$procList))."\n";
  print xipc_sys_c "};\n";
  print xipc_sys_c "\n";

  print xipc_sys_c "/* Structure describing the local address spaces, ".
                   "sizes, and their\n";
  print xipc_sys_c 
        " * corresponding map within the subsystem address space */\n";

  
  # DataRAM0, DataRAM1, InstRAM0, InstRAM1, L2s
  my $num_entries = 4 + (scalar (keys %$subSystemL2s));

  # Find number of SubSystemMMIO registers
  my $num_smmio_regs = 0;
  foreach my $smmio (values %$subSystemMMIOs) {
    if (defined $smmio->{'globalAddr'}) {
      $num_smmio_regs++;
    } else {
      $num_smmio_regs += (scalar (@{$smmio->{'intrRegs'}}) + 
                          scalar (@{$smmio->{'controlRegs'}}));
    }
  }
  $num_entries += $num_smmio_regs;

  printf xipc_sys_c "const unsigned xmp_xipc_max_addr_descs_per_proc = ".
                      ($num_entries+1).";\n";
  printf xipc_sys_c "\n";

  print xipc_sys_c 
        "const xipc_proc_addr_desc_t ".
        "xmp_xipc_proc_addr_descs[XMP_XIPC_NUM_PROCS][".($num_entries+1)."] ".
        "= {\n";

  foreach my $proc (@$procList) {
    print xipc_sys_c "  {\n";
    print xipc_sys_c "    // Local address, Global address, size\n";

    # DataRAM0
    if (defined $proc->{'dataRam0'}) {
      printf xipc_sys_c "    {XMP_$proc->{'name'}_LOCAL_BASE_ADDR_DATARAM0, ".
                        "XMP_$proc->{'name'}_GLOBAL_BASE_ADDR_DATARAM0, ".
                        "XMP_$proc->{'name'}_DATARAM0_SIZE},\n";
    } else {
      printf xipc_sys_c "    {0, 0, 0},\n";
    }

    # DataRAM1
    if (defined $proc->{'dataRam1'}) {
      printf xipc_sys_c "    {XMP_$proc->{'name'}_LOCAL_BASE_ADDR_DATARAM1, ".
                        "XMP_$proc->{'name'}_GLOBAL_BASE_ADDR_DATARAM1, ".
                        "XMP_$proc->{'name'}_DATARAM1_SIZE},\n";
    } else {
      printf xipc_sys_c "    {0, 0, 0},\n";
    }

    # InstRAM0
    if (defined $proc->{'instRam0'}) {
      printf xipc_sys_c "    {XMP_$proc->{'name'}_LOCAL_BASE_ADDR_INSTRAM0, ".
                        "XMP_$proc->{'name'}_GLOBAL_BASE_ADDR_INSTRAM0, ".
                        "XMP_$proc->{'name'}_INSTRAM0_SIZE},\n";
    } else {
      printf xipc_sys_c "    {0, 0, 0},\n";
    }
    
    # InstRAM1
    if (defined $proc->{'instRam1'}) {
      printf xipc_sys_c "    {XMP_$proc->{'name'}_LOCAL_BASE_ADDR_INSTRAM1, ".
                        "XMP_$proc->{'name'}_GLOBAL_BASE_ADDR_INSTRAM1, ".
                        "XMP_$proc->{'name'}_INSTRAM1_SIZE},\n";
    } else {
      printf xipc_sys_c "    {0, 0, 0},\n";
    }

    # L2
    foreach my $l2 (values %$subSystemL2s) {
      if (grep { $_ eq $proc->{'id'} } 
          @{$subSysInterconnectFrom->{$l2->{'id'}}}) {
        printf xipc_sys_c "    {XMP_$l2->{'name'}_RAM_ADDR, ".
                          "XMP_$l2->{'name'}_RAM_GLOBAL_ADDR, ".
                          "XMP_$l2->{'name'}_RAM_SIZE},\n";
      } else {
        printf xipc_sys_c "    {0, 0, 0},\n";
      }
    }

    # SubSystemMMIO
    printf xipc_sys_c "    // SubSystemMMIO registers\n";
    foreach my $smmio (values %$subSystemMMIOs) {
      if (defined $smmio->{'globalAddr'}) {
          if (grep { $_ eq $smmio->{'id'} } 
              @{$subSysInterconnectTo->{$proc->{'id'}}}) {
            printf xipc_sys_c "    {$smmio->{'localAddr'}, ".
                              "$smmio->{'globalAddr'}, $smmio->{'size'}},\n";
          } else {
            printf xipc_sys_c "    {0, 0, 0},\n";
          }
      } else {
        foreach my $car (@{$smmio->{'intrRegs'}}) {
          if (grep { $_ eq $smmio->{'id'} } 
              @{$subSysInterconnectTo->{$proc->{'id'}}}) {
            printf xipc_sys_c "    {$car->{'localAddr'}, ".
                              "$car->{'globalAddr'}, 4},\n";
          } else {
            printf xipc_sys_c "    {0, 0, 0},\n";
          }
        }
        foreach my $car (@{$smmio->{'controlRegs'}}) {
          if (grep { $_ eq $smmio->{'id'} } 
              @{$subSysInterconnectTo->{$proc->{'id'}}}) {
            printf xipc_sys_c "    {$car->{'localAddr'}, ".
                              "$car->{'globalAddr'}, 4},\n";
          } else {
            printf xipc_sys_c "    {0, 0, 0},\n";
          }
        }
      }
    }
      
    printf xipc_sys_c "    {0xffffffff, 0xffffffff, 0xffffffff},\n";
    printf xipc_sys_c "  },\n";
  }
  print xipc_sys_c "};\n";
  print xipc_sys_c "\n";
 
  my $proc_bintr_map = {};
  my $proc_bintr_count = {};
  foreach my $smmio (values %$subSystemMMIOs) {
    foreach my $car (@{$smmio->{'intrRegs'}}) {
      my $h = $car->{'bIntrMap'};
      foreach my $bitOffset (sort {$a<=>$b} keys %$h) {
        my $bInterrupt = $h->{$bitOffset};
        my $proc = $car->{'procMap'}->{$bitOffset};
        my $pid = $procNameMap->{$proc}->{'id'};
        push @{$proc_bintr_map->{$pid}}, $bInterrupt;
        push @{$proc_bintr_map->{$pid}}, "XMP_${proc}_BINTR${bInterrupt}_MASK";
        push @{$proc_bintr_map->{$pid}}, "XMP_${proc}_BINTR${bInterrupt}_ADDR";
        my $edge = $car->{'intrTypeMap'}->{$bitOffset} eq 'Edge';
        push @{$proc_bintr_map->{$pid}}, $edge ? 'XIPC_INTR_TYPE_EDGE' 
                                               : 'XIPC_INTR_TYPE_LEVEL';
        $proc_bintr_count->{$pid}++;
      }
    }
  } 

  foreach my $pid (sort {$a<=>$b} (keys %$procIdMap)) {
    my $proc = $procIdMap->{$pid};
    if (defined $proc->{'mmio'}->{'intrReg'}->{'bIntrMap'}) {
      my $h = $proc->{'mmio'}->{'intrReg'}->{'bIntrMap'};
      foreach my $bitOffset (sort {$a<=>$b} keys %$h) {
        my $bInterrupt = $h->{$bitOffset};
        push @{$proc_bintr_map->{$pid}}, $bInterrupt;
        push @{$proc_bintr_map->{$pid}}, 
             "XMP_$proc->{'name'}_BINTR${bInterrupt}_MASK";
        push @{$proc_bintr_map->{$pid}}, 
             "XMP_$proc->{'name'}_BINTR${bInterrupt}_ADDR";
        my $edge = $proc->{'mmio'}->{'intrReg'}->{'intrTypeMap'}->{$bitOffset}
                   eq 'Edge';
        push @{$proc_bintr_map->{$pid}}, $edge ? 'XIPC_INTR_TYPE_EDGE' 
                                               : 'XIPC_INTR_TYPE_LEVEL';
        $proc_bintr_count->{$pid}++;
      }
    }
  }

  if (%$proc_bintr_map) {
    my $max_count = 0;
    foreach my $pid (keys %$proc_bintr_count) {
      if ($proc_bintr_count->{$pid} > $max_count) {
        $max_count = $proc_bintr_count->{$pid};
      }
    }
    print xipc_sys_c 
          "/* Map of interrupt mask for all processors x interrupts */\n";
    # Dummy entry at end to denote end of interrupts
    printf xipc_sys_c "const unsigned xmp_xipc_max_intrs_per_proc = ".
                      ($max_count+1).";\n";
    printf xipc_sys_c "\n";
    printf xipc_sys_c "const xipc_proc_intr_desc_t ".
                      "xmp_xipc_proc_intr_descs[XMP_NUM_PROCS][".
                      ($max_count+1)."] DRAM_RO_ATTR = {\n";
    foreach my $pid (sort {$a<=>$b} (keys %$procIdMap)) {
      my $i = 0;
      printf xipc_sys_c "  {\n";
      foreach my $e (@{$proc_bintr_map->{$pid}}) {
        if ($i%4 == 0) {
          printf xipc_sys_c "    {";
        }
        if ($i%4 == 3) {
          printf xipc_sys_c "%s},\n", $e;
        } else {
          printf xipc_sys_c "%s, ", $e;
        }
        $i++;
      }
      # Add dummy entries at the end for padding
      for (my $j = $i/4; $j < $max_count; ++$j) {
        printf xipc_sys_c "    {-1, 0x0, 0x0, 0},\n";
      }
      printf xipc_sys_c "    {-1, 0x0, 0x0, 0}\n";
      printf xipc_sys_c "  },\n";
    }
    print xipc_sys_c "};\n";
  }

  if (keys %$procNameMap > 1) {
    print xipc_sys_c <<EOF;

/* Pre-defined input ports for inter-processor messages. There exists one 
 * input port for each processor in the subsystem from which this proc can 
 * receive a message. Default placement in processor local memory, but can be
 * re-defined to be placed in custom location in user code */
xipc_msg_channel_input_port_t
xmp_xipc_msg_channel_my_input_ports[XMP_XIPC_NUM_PROCS-1] DRAM_ATTR WEAK_ATTR;

/* Pre-defined output ports for inter-processor messages. There exists one 
 * output port for each processor in the subsystem to which this proc can 
 * send a message. Default placement in processor local memory, but can be
 * re-defined to be placed in custom location in user code */
xipc_msg_channel_output_port_t
xmp_xipc_msg_channel_my_output_ports[XMP_XIPC_NUM_PROCS-1] DRAM_ATTR WEAK_ATTR;

/* Pre-defined set of buffers for the message channels. There exists one 
 * per input port for each processor in the subsystem from which this proc 
 * can receive a message. Default placement in processor local memory, but can 
 * be re-defined to be placed in custom location in user code */
int32_t xmp_xipc_msg_channel_my_buffer[(XMP_XIPC_MSG_CHANNEL_DEFAULT_NUM_MSGS+1)*(XMP_XIPC_NUM_PROCS-1)] DRAM_ATTR WEAK_ATTR;

/* Number of messages in the pre-defined message channels */
const uint32_t 
xmp_xipc_msg_channel_num_msgs DRAM_RO_ATTR WEAK_ATTR = XMP_XIPC_MSG_CHANNEL_DEFAULT_NUM_MSGS+1;
EOF
  }

  print xipc_sys_c "\n";

  # Check if it is a hex; if yes have xmp_xipc_shared_data point to the 
  # hard coded hex address, else declare an extern symbol and have 
  # xmp_xipc_shared_data point to that.
  print xipc_sys_c "/* Buffer to hold the xipc shared structures */\n";
  if ($subSystemSoftware->{'xipcSharedDataBuffer'} =~ m/^0x/) {
    print xipc_sys_c "char *xmp_xipc_shared_data = (char *)".
                     "$subSystemSoftware->{'xipcSharedDataBuffer'};\n";
  } else {
    print xipc_sys_c
          "extern char ".
          $subSystemSoftware->{'xipcSharedDataBuffer'}."[] WEAK_ATTR;\n";
    print xipc_sys_c 
          "char *xmp_xipc_shared_data = (char *)".
          "$subSystemSoftware->{'xipcSharedDataBuffer'};\n";
  }

  close xipc_sys_c;

  generateSysLibMakefile($xipc_sys_lib_gen_dir, $proc);

  printLog($logDebugLevel1, "Leaving generateXIPCSysLib()\n");
}

sub generateXmpLogFile {
  my $sys_header_gen_dir = shift;
  printLog($logDebugLevel2, "In generateSysHeaderFile()\n");

  my $xmp_log_h = "$sys_header_gen_dir/xmp_log.h";

  open(xmp_log_h, ">$xmp_log_h") or 
    sysBuildError("Could not open $xmp_log_h\n");

  print xmp_log_h "#ifndef __XMP_LOG_H__\n";
  print xmp_log_h "#define __XMP_LOG_H__\n";
  print xmp_log_h "\n";

  print xmp_log_h "#include <time.h>\n";
  print xmp_log_h "#include <stdio.h>\n";
  print xmp_log_h "#include <stdlib.h>\n";
  print xmp_log_h "#include <stdint.h>\n";
  print xmp_log_h "#include <xtensa/tie/xt_core.h>\n";
  print xmp_log_h "\n";

  print xmp_log_h "static const char *xmp_proc_names[XMP_NUM_PROCS] = {\n";
  print xmp_log_h join(",\n", 
                  map("  \"".$procIdMap->{$_}->{'name'}."\"", 
                      sort {$a<=>$b} (keys %$procIdMap)))."\n";
  print xmp_log_h "};\n";
  print xmp_log_h "\n";

  print xmp_log_h 
        "#define XMP_CORELOG   fprintf(stdout, \"XMP_LOG: \%s: \", ".
        "xmp_proc_names[XT_RSR_PRID()]);\n";
  print xmp_log_h 
        "#define XMP_TIMESTAMP fprintf(stdout, \"(%10d) \", ".
        "(int)clock());\n";
  print xmp_log_h 
        "#define XMP_SPACING   fprintf(stdout, \"%*s\", ".
        "XT_RSR_PRID()*10, \"\");\n";
  print xmp_log_h 
        "#define XMP_LOG(...)  { XMP_TIMESTAMP; XMP_SPACING; XMP_CORELOG ; ".
        "fprintf(stdout, __VA_ARGS__); fflush(stdout); };\n";
  print xmp_log_h "\n";

  print xmp_log_h "#endif /* __XMP_LOG_H__ */\n";

  close xmp_log_h;

  printLog($logDebugLevel1, "Leaving generateXmpLogFile()\n");
}

# Generate xmp_subsystem.h header file
sub generateSysHeaderFile {
  my $sys_header_gen_dir = shift;

  printLog($logDebugLevel2, "In generateSysHeaderFile()\n");

  my $xmp_subsystem_h = "$sys_header_gen_dir/xmp_subsystem.h";

  if (-d $sys_header_gen_dir) {
    rmtree($sys_header_gen_dir);
    $? == 0 or sysBuildError("Cannot delete $sys_header_gen_dir\n");
  }
  mkpath($sys_header_gen_dir);
  $? == 0 || die sysBuildError("Cannot create $sys_header_gen_dir\n");

  open(xmp_subsystem_h, ">$xmp_subsystem_h") or 
    sysBuildError("Could not open $xmp_subsystem_h\n");

  my $procList;
  $procList = [ map {$_} sort {$a<=>$b} (keys %$procIdMap) ];

  print xmp_subsystem_h "/* Copyright (c) 2005-2020 by Cadence Design Systems, Inc.  ALL RIGHTS RESERVED.
 * These coded instructions, statements, and computer programs are the
 * copyrighted works and confidential proprietary information of 
 * Cadence Design Systems, Inc. They may not be modified, copied, reproduced, 
 * distributed, or disclosed to third parties in any manner, medium, or form, 
 * in whole or in part, without the prior written consent of Cadence Design 
 * Systems, Inc.*/\n";
  print xmp_subsystem_h "\n";

  print xmp_subsystem_h "#ifndef __XMP_SUBSYSTEM_H__\n";
  print xmp_subsystem_h "#define __XMP_SUBSYSTEM_H__\n";
  print xmp_subsystem_h "\n";

  printf xmp_subsystem_h 
         "#define %-58s %d\n", "XMP_NUM_PROCS", scalar @$procList;
  if (defined $subSystemSoftware->{'xipcProcs'}) {
    printf xmp_subsystem_h "#define %-58s %d\n", "XMP_XIPC_NUM_PROCS", 
                           scalar @{$subSystemSoftware->{'xipcProcs'}};
  } else {
    printf xmp_subsystem_h "#define %-58s %d\n", "XMP_XIPC_NUM_PROCS", 
                           scalar @$procList;
  }
  print xmp_subsystem_h "\n";

  print xmp_subsystem_h 
        "/* Processor ID of each processor in the subsystem */\n";
  foreach my $pid (@$procList) {
    my $proc = $procIdMap->{$pid};
    printf xmp_subsystem_h 
           "#define %-58s $proc->{'id'}\n", "XMP_$proc->{'name'}_PID";
  }
  print xmp_subsystem_h "\n";

  print xmp_subsystem_h 
        "/* Processor ID of the master processor in the subsystem */\n";
  printf xmp_subsystem_h 
         "#define %-58s XMP_$subSysMasterProc->{'name'}_PID\n", 
         "XMP_MASTER_PID";
  printf xmp_subsystem_h 
         "#define %-58s XMP_".
         $procIdMap->{$subSystemSoftware->{'xipcMasterProc'}}->{'name'}.
         "_PID\n", "XMP_XIPC_MASTER_PID";
  print xmp_subsystem_h "\n";

  print xmp_subsystem_h 
        "/* Processor name string of each processor in the subsystem */\n";
  foreach my $pid (@$procList) {
    my $proc = $procIdMap->{$pid};
    printf xmp_subsystem_h 
           "#define %-58s \"$proc->{'name'}\"\n", 
           "XMP_$proc->{'name'}_NAME_STR";
  }
  print xmp_subsystem_h "\n";

  foreach my $pid (@$procList) {
    my $proc = $procIdMap->{$pid};
    print xmp_subsystem_h "/* $proc->{'name'}'s local memory definition */\n";
    printf xmp_subsystem_h "#define %-58s ", "XMP_$proc->{'name'}_HAS_INSTRAM0";
    printf xmp_subsystem_h (defined $proc->{'instRam0'} ? "1" : "0") . "\n";
    printf xmp_subsystem_h "#define %-58s ", "XMP_$proc->{'name'}_HAS_INSTRAM1";
    printf xmp_subsystem_h (defined $proc->{'instRam1'} ? "1" : "0") . "\n";
    printf xmp_subsystem_h "#define %-58s ", "XMP_$proc->{'name'}_HAS_DATARAM0";
    printf xmp_subsystem_h (defined $proc->{'dataRam0'} ? "1" : "0") . "\n";
    printf xmp_subsystem_h "#define %-58s ", "XMP_$proc->{'name'}_HAS_DATARAM1";
    printf xmp_subsystem_h (defined $proc->{'dataRam1'} ? "1" : "0") . "\n";
    print xmp_subsystem_h "\n";

    print xmp_subsystem_h "/* $proc->{'name'}'s address map */\n";
    print xmp_subsystem_h "\n";
    if (defined $proc->{'dataRam0'}) {
      print xmp_subsystem_h "/* $proc->{'name'}'s DATARAM0 base address */\n";
      printf xmp_subsystem_h 
             "#define %-58s $proc->{'dataRam0'}->{'localAddr'}\n", 
             "XMP_$proc->{'name'}_LOCAL_BASE_ADDR_DATARAM0";
      print xmp_subsystem_h 
            "/* $proc->{'name'}'s DATARAM0 base address in the ".
            "global address space */\n";
      if (defined $proc->{'dataRam0'}->{'globalAddr'}) { 
        printf xmp_subsystem_h 
               "#define %-58s $proc->{'dataRam0'}->{'globalAddr'}\n", 
               "XMP_$proc->{'name'}_GLOBAL_BASE_ADDR_DATARAM0";
      } else {
        printf xmp_subsystem_h 
               "#define %-58s 0\n", 
               "XMP_$proc->{'name'}_GLOBAL_BASE_ADDR_DATARAM0";
      }
      print xmp_subsystem_h "/* $proc->{'name'}'s DataRAM0 size */\n";
      printf xmp_subsystem_h 
             "#define %-58s $proc->{'dataRam0'}->{'size'}\n", 
             "XMP_$proc->{'name'}_DATARAM0_SIZE";
      print xmp_subsystem_h "\n";
    } else {
      printf xmp_subsystem_h "#define %-58s 0\n", 
                             "XMP_$proc->{'name'}_LOCAL_BASE_ADDR_DATARAM0";
      printf xmp_subsystem_h "#define %-58s 0\n", 
                             "XMP_$proc->{'name'}_GLOBAL_BASE_ADDR_DATARAM0";
      printf xmp_subsystem_h "#define %-58s 0\n", 
                             "XMP_$proc->{'name'}_DATARAM0_SIZE";
      print xmp_subsystem_h "\n";
    }

    if (defined $proc->{'dataRam1'}) {
      print xmp_subsystem_h "/* $proc->{'name'}'s DATARAM1 base address */\n";
      printf xmp_subsystem_h 
             "#define %-58s $proc->{'dataRam1'}->{'localAddr'}\n", 
             "XMP_$proc->{'name'}_LOCAL_BASE_ADDR_DATARAM1";
      print xmp_subsystem_h 
            "/* $proc->{'name'}'s DATARAM1 base address in the global ".
            "address space */\n";
      if (defined $proc->{'dataRam1'}->{'globalAddr'}) { 
        printf xmp_subsystem_h 
               "#define %-58s $proc->{'dataRam1'}->{'globalAddr'}\n", 
               "XMP_$proc->{'name'}_GLOBAL_BASE_ADDR_DATARAM1";
      } else {
        printf xmp_subsystem_h 
               "#define %-58s 0\n", 
               "XMP_$proc->{'name'}_GLOBAL_BASE_ADDR_DATARAM1";
      }
      print xmp_subsystem_h "/* $proc->{'name'}'s DataRAM1 size */\n";
      printf xmp_subsystem_h 
             "#define %-58s $proc->{'dataRam1'}->{'size'}\n", 
             "XMP_$proc->{'name'}_DATARAM1_SIZE";
      print xmp_subsystem_h "\n";
    } else {
      printf xmp_subsystem_h "#define %-58s 0\n", 
                             "XMP_$proc->{'name'}_LOCAL_BASE_ADDR_DATARAM1";
      printf xmp_subsystem_h "#define %-58s 0\n", 
                             "XMP_$proc->{'name'}_GLOBAL_BASE_ADDR_DATARAM1";
      printf xmp_subsystem_h "#define %-58s 0\n", 
                             "XMP_$proc->{'name'}_DATARAM1_SIZE";
      print xmp_subsystem_h "\n";
    }

    if (defined $proc->{'instRam0'}) {
      print xmp_subsystem_h "/* $proc->{'name'}'s INSTRAM0 base address */\n";
      printf xmp_subsystem_h 
             "#define %-58s $proc->{'instRam0'}->{'localAddr'}\n", 
             "XMP_$proc->{'name'}_LOCAL_BASE_ADDR_INSTRAM0";
      print xmp_subsystem_h 
            "/* $proc->{'name'}'s INSTRAM0 base address in the ".
            "global address space */\n";
      if (defined $proc->{'instRam0'}->{'globalAddr'}) {
        printf xmp_subsystem_h 
               "#define %-58s $proc->{'instRam0'}->{'globalAddr'}\n", 
               "XMP_$proc->{'name'}_GLOBAL_BASE_ADDR_INSTRAM0";
      } else {
        printf xmp_subsystem_h "#define %-58s 0\n", 
                               "XMP_$proc->{'name'}_GLOBAL_BASE_ADDR_INSTRAM0";
      }
      print xmp_subsystem_h "/* $proc->{'name'}'s INSTRAM0 size */\n";
      printf xmp_subsystem_h "#define %-58s $proc->{'instRam0'}->{'size'}\n", 
                             "XMP_$proc->{'name'}_INSTRAM0_SIZE";
      print xmp_subsystem_h "\n";
    } else {
      printf xmp_subsystem_h "#define %-58s 0\n", 
                             "XMP_$proc->{'name'}_LOCAL_BASE_ADDR_INSTRAM0";
      printf xmp_subsystem_h "#define %-58s 0\n", 
                             "XMP_$proc->{'name'}_GLOBAL_BASE_ADDR_INSTRAM0";
      printf xmp_subsystem_h "#define %-58s 0\n", 
                             "XMP_$proc->{'name'}_INSTRAM0_SIZE";
      print xmp_subsystem_h "\n";
    }

    if (defined $proc->{'instRam1'}) {
      print xmp_subsystem_h "/* $proc->{'name'}'s INSTRAM1 base address */\n";
      printf xmp_subsystem_h 
             "#define %-58s $proc->{'instRam1'}->{'localAddr'}\n", 
             "XMP_$proc->{'name'}_LOCAL_BASE_ADDR_INSTRAM1";
      print xmp_subsystem_h 
            "/* $proc->{'name'}'s INSTRAM1 base address in the ".
            "global address space */\n";
      if (defined $proc->{'instRam1'}->{'globalAddr'}) {
        printf xmp_subsystem_h 
               "#define %-58s $proc->{'instRam1'}->{'globalAddr'}\n", 
               "XMP_$proc->{'name'}_GLOBAL_BASE_ADDR_INSTRAM1";
      } else {
        printf xmp_subsystem_h "#define %-58s 0\n", 
                               "XMP_$proc->{'name'}_GLOBAL_BASE_ADDR_INSTRAM1";
      }
      print xmp_subsystem_h "/* $proc->{'name'}'s INSTRAM1 size */\n";
      printf xmp_subsystem_h "#define %-58s $proc->{'instRam1'}->{'size'}\n", 
                             "XMP_$proc->{'name'}_INSTRAM1_SIZE";
      print xmp_subsystem_h "\n";
    } else {
      printf xmp_subsystem_h "#define %-58s 0\n", 
                             "XMP_$proc->{'name'}_LOCAL_BASE_ADDR_INSTRAM1";
      printf xmp_subsystem_h "#define %-58s 0\n", 
                             "XMP_$proc->{'name'}_GLOBAL_BASE_ADDR_INSTRAM1";
      printf xmp_subsystem_h "#define %-58s 0\n", 
                             "XMP_$proc->{'name'}_INSTRAM1_SIZE";
      print xmp_subsystem_h "\n";
    }
  }

  foreach my $pid (sort {$a<=>$b} (keys %$procIdMap)) {
    my $proc = $procIdMap->{$pid};
    print xmp_subsystem_h 
          "/* External uDMA specifc constants for $proc->{'name'} */\n";
    printf xmp_subsystem_h "#define %-58s ", "XMP_$proc->{'name'}_HAS_EXT_UDMA";
    printf xmp_subsystem_h (defined $proc->{'udma'} ? "1" : "0") . "\n";
    if (defined $proc->{'udma'}) {
      printf xmp_subsystem_h 
             "#define %-58s $proc->{'udma'}->{'syncProcIntr'}\n", 
             "XMP_$proc->{'name'}_EXT_UDMA_SYNC_INTR";
      printf xmp_subsystem_h 
            "#define %-58s $proc->{'udma'}->{'errorProcIntr'}\n", 
            "XMP_$proc->{'name'}_EXT_UDMA_ERROR_INTR";
    }
    print xmp_subsystem_h "\n";
  }

  foreach my $pid (sort {$a<=>$b} (keys %$procIdMap)) {
    my $proc = $procIdMap->{$pid};
    print xmp_subsystem_h "/* Pipeline type for $proc->{'name'} */\n";
    printf xmp_subsystem_h "#define %-58s ", "XMP_$proc->{'name'}_IS_NX";
    printf xmp_subsystem_h ($proc->{'pipeline'} eq 'NX' ? "1" : "0") . "\n";
    printf xmp_subsystem_h "#define %-58s ", "XMP_$proc->{'name'}_IS_LX";
    printf xmp_subsystem_h ($proc->{'pipeline'} eq 'LX' ? "1" : "0") . "\n";
    print xmp_subsystem_h "\n";
  }

  foreach my $pid (sort {$a<=>$b} (keys %$procIdMap)) {
    my $proc = $procIdMap->{$pid};
    print xmp_subsystem_h "/* $proc->{'name'}'s XIPC interrupt definition */\n";
    printf xmp_subsystem_h "#define %-58s ", 
           "XMP_$proc->{'name'}_HAS_XIPC_INTR";
    my $has_xipc = 0;
    if ((defined $proc->{'mmio'} && 
         defined $proc->{'mmio'}->{'intrReg'}->{'xipcIntrOffset'}) or
        defined $proc->{'xipcSubSystemMMIO'}) {
      $has_xipc = 1;
    }
    printf xmp_subsystem_h $has_xipc  ? "1" : "0" . "\n";
    print xmp_subsystem_h "\n";
    if (!defined $proc->{'mmio'} and !defined $proc->{'xipcSubSystemMMIO'}) {
      next;
    }

    # If XIPC interrupt is present define them.
    print xmp_subsystem_h 
          "/* Default interrupt used by the XIPC components */\n";
    my $xipc_intr_off = 0;
    my $xipc_intr = 0;
    if (defined $proc->{'mmio'}->{'intrReg'}->{'xipcIntrOffset'}) {
      $xipc_intr_off = $proc->{'mmio'}->{'intrReg'}->{'xipcIntrOffset'};
      $xipc_intr = $proc->{'mmio'}->{'intrReg'}->{'pIntrMap'}->{$xipc_intr_off};
    } elsif (defined $proc->{'xipcSubSystemMMIO'}) {
      my $car = @{$proc->{'xipcSubSystemMMIO'}}[0];
      $xipc_intr_off = @{$proc->{'xipcSubSystemMMIO'}}[1];
      if (defined $car->{'pIntrMap'}) {
        $xipc_intr = $car->{'pIntrMap'}->{$xipc_intr_off};
      } else {
        $xipc_intr = $car->{'bIntrMap'}->{$xipc_intr_off};
      }
    }
    printf xmp_subsystem_h 
           "#define %-58s $xipc_intr\n", "XMP_$proc->{'name'}_XIPC_INTR_ID";
    print xmp_subsystem_h 
          "/* Offset of the default XIPC interrupt within the ".
          "memory mapped register */\n";
    printf xmp_subsystem_h "#define %-58s $xipc_intr_off\n", 
                           "XMP_$proc->{'name'}_MMIO_OFFSET_XIPC_INTR";

    print xmp_subsystem_h 
          "/* Global address of the memory mapped XIPC interrupt register */\n";
    if (defined $proc->{'mmio'}->{'intrReg'}->{'xipcIntrOffset'}) {
      printf xmp_subsystem_h 
             "#define %-58s $proc->{'mmio'}->{'intrReg'}->{'globalAddr'}\n", 
             "XMP_$proc->{'name'}_MMIO_ADDR_XIPC_INTR";
    } elsif (defined $proc->{'xipcSubSystemMMIO'}) {
      printf xmp_subsystem_h 
        "#define %-58s @{$proc->{'xipcSubSystemMMIO'}}[0]->{'globalAddr'}\n", 
        "XMP_$proc->{'name'}_MMIO_ADDR_XIPC_INTR";
    } else {
      printf xmp_subsystem_h "#define %-58s 0\n", 
                             "XMP_$proc->{'name'}_MMIO_ADDR_XIPC_INTR";
    }
    print xmp_subsystem_h "\n";
  }

  foreach my $pid (sort {$a<=>$b} (keys %$procIdMap)) {
    my $proc = $procIdMap->{$pid};
    if (defined $proc->{'sdma'}) {
      printf xmp_subsystem_h "/* $proc->{'name'}'s sDMA definitions */\n";
      printf xmp_subsystem_h 
             "#define %-58s ".
             sprintf("0x%x", hex($proc->{'sdma'}->{'globalAddr'})).
             "\n", "XMP_$proc->{'name'}_SDMA_ADDR";
      printf xmp_subsystem_h 
             "#define %-58s ".
             sprintf("%d", $proc->{'sdma'}->{'size'}).
             "\n", "XMP_$proc->{'name'}_SDMA_SIZE";
      print xmp_subsystem_h "\n";
    }
  }

  print xmp_subsystem_h 
        "/* Map the processors's BInterrupts to a MMIO register address ".
        "bitmask */\n";

  # mask and address for the SubSystemMMIO interrupts
  foreach my $smmio (values %$subSystemMMIOs) {
    foreach my $car (@{$smmio->{'intrRegs'}}) {
      my $h = $car->{'bIntrMap'};
      foreach my $bitOffset (sort {$a<=>$b} keys %$h) {
        my $bInterrupt = $h->{$bitOffset};
        my $proc = $car->{'procMap'}->{$bitOffset};
        printf xmp_subsystem_h "#define %-58s (1<<$bitOffset)\n", 
                               "XMP_${proc}_BINTR${bInterrupt}_MASK";
        printf xmp_subsystem_h "#define %-58s $car->{'globalAddr'}\n", 
                               "XMP_${proc}_BINTR${bInterrupt}_ADDR";
        print xmp_subsystem_h "\n";
      }
    }
  }

  # mask and address for the local mmio interrupts
  foreach my $pid (sort {$a<=>$b} (keys %$procIdMap)) {
    my $proc = $procIdMap->{$pid};
    if (defined $proc->{'mmio'}->{'intrReg'}->{'bIntrMap'}) {
      my $h = $proc->{'mmio'}->{'intrReg'}->{'bIntrMap'};
      foreach my $bitOffset (sort {$a<=>$b} keys %$h) {
        my $bInterrupt = $h->{$bitOffset};
        printf xmp_subsystem_h "#define %-58s (1<<$bitOffset)\n", 
                               "XMP_$proc->{'name'}_BINTR${bInterrupt}_MASK";
        printf xmp_subsystem_h 
               "#define %-58s $proc->{'mmio'}->{'intrReg'}->{'globalAddr'}\n", 
               "XMP_$proc->{'name'}_BINTR${bInterrupt}_ADDR";
        print xmp_subsystem_h "\n";
      }
    }
  }

  my $max_dcache_line_size = computeMaxDCacheLineSize();
  print xmp_subsystem_h "/* Max DACHE line size across all processors */\n";
  printf xmp_subsystem_h "#define %-58s $max_dcache_line_size\n", 
                         "XMP_MAX_DCACHE_LINESIZE";
  print xmp_subsystem_h "\n";

  print xmp_subsystem_h 
        "/* Default number of messages for the pre-defined ".
        "message channels */\n";
  printf xmp_subsystem_h "#define %-58s %d\n", 
                         "XMP_XIPC_MSG_CHANNEL_DEFAULT_NUM_MSGS", 
                         $subSystemSoftware->{'xipcMsgChannelDefaultNumMsgs'};
  print xmp_subsystem_h "\n";

  print xmp_subsystem_h "/* System RAM definition */\n";
  printf xmp_subsystem_h "#define %-58s $systemRAM->{'globalAddr'}\n", 
                         "XMP_SYSTEM_RAM_ADDR";
  printf xmp_subsystem_h "#define %-58s $systemRAM->{'size'}\n", 
                         "XMP_SYSTEM_RAM_SIZE";
  print xmp_subsystem_h "\n";

  if (defined $systemROM->{'globalAddr'}) {
    print xmp_subsystem_h "/* System ROM definition */\n";
    printf xmp_subsystem_h "#define %-58s $systemROM->{'globalAddr'}\n", 
                           "XMP_SYSTEM_ROM_ADDR";
    printf xmp_subsystem_h "#define %-58s $systemROM->{'size'}\n", 
                           "XMP_SYSTEM_ROM_SIZE";
    print xmp_subsystem_h "\n";
  }

  foreach my $l2 (values %$subSystemL2s) {
    print xmp_subsystem_h "/* L2 '$l2->{'name'}' RAM defintion */\n";
    printf xmp_subsystem_h "#define %-58s $l2->{'localAddr'}\n", 
                           "XMP_".uc($l2->{'name'})."_RAM_ADDR";
    printf xmp_subsystem_h "#define %-58s $l2->{'globalAddr'}\n", 
                           "XMP_".uc($l2->{'name'})."_RAM_GLOBAL_ADDR";
    printf xmp_subsystem_h "#define %-58s $l2->{'size'}\n", 
                           "XMP_".uc($l2->{'name'})."_RAM_SIZE";
    print xmp_subsystem_h "\n";
  }

  print xmp_subsystem_h "/* Device Memory definitions */\n";
  foreach my $devMem (@DeviceMemories) {
    printf xmp_subsystem_h "/* %s */\n", $devMem->{'name'};
    printf xmp_subsystem_h "#define %-58s $devMem->{'globalAddr'}\n", 
                           "XMP_".$devMem->{'name'}."_ADDR";
    printf xmp_subsystem_h "#define %-58s $devMem->{'size'}\n", 
                           "XMP_".$devMem->{'name'}."_SIZE";
    printf xmp_subsystem_h "\n";
  }
  printf xmp_subsystem_h "\n";

  print xmp_subsystem_h "/* System DMA definitions */\n";
  if (defined $SystemDMA->{'baseAddr'}) {
    my $size = $SystemDMA->{'size'}/$SystemDMA->{'numChannels'};
    foreach my $ch (0..$SystemDMA->{'numChannels'}-1) {
      printf xmp_subsystem_h "// SystemDMA channel $ch\n";
      printf xmp_subsystem_h 
             "#define %-58s ".
             sprintf("0x%x", (hex($SystemDMA->{'baseAddr'})+$ch*$size)).
             "\n", "SYSTEM_DMA_CH${ch}_ADDR";
      printf xmp_subsystem_h "#define %-58s ".sprintf("%d", $size)."\n", 
                             "SYSTEM_DMA_CH${ch}_SIZE";
    }
    printf xmp_subsystem_h "\n";
  }
  
  print xmp_subsystem_h 
        "/* Macro for creating processor-indexed arrays of parameters: */\n";
  print xmp_subsystem_h "#define XMP_PROC_ARRAY_P(param) \\\n";
  print xmp_subsystem_h 
        join(",  \\\n", map("  XMP_$procIdMap->{$_}->{'name'}_ ## param", 
                            sort {$a<=>$b} (keys %$procIdMap)));
  print xmp_subsystem_h "\n";

  print xmp_subsystem_h "\n";
  print xmp_subsystem_h 
        "#define __XIPC_PROC_INTERRUPT(TARGET_PROC_NAME, TARGET_PROC_INTR) { ".
        "\\\n";
  print xmp_subsystem_h "  *((volatile unsigned *) \\\n";
  print xmp_subsystem_h 
        "    XMP_ ## TARGET_PROC_NAME ## _BINTR ## TARGET_PROC_INTR ## _ADDR) ".
        "= \\\n";
  print xmp_subsystem_h 
        "    XMP_ ## TARGET_PROC_NAME ## _BINTR ## TARGET_PROC_INTR ## _MASK; ".
        "\\\n";
  print xmp_subsystem_h "  *((volatile unsigned *) \\\n";
  print xmp_subsystem_h 
        "   XMP_ ## TARGET_PROC_NAME ## _BINTR ## TARGET_PROC_INTR ## _ADDR) ".
        "= 0; \\\n";
  print xmp_subsystem_h "}\n";

  print xmp_subsystem_h "\n";
  print xmp_subsystem_h "/* Send a specific interrupt ".
                        "(assumes edge triggered) to a target processor.\n";
  print xmp_subsystem_h " *\n";
  print xmp_subsystem_h 
        " * TARGET_PROC_NAME: Target processor name to send interrupt to.\n";
  print xmp_subsystem_h 
        " * TARGET_PROC_INTR: Interrupt on the target processor\n";
  print xmp_subsystem_h " *\n";
  print xmp_subsystem_h " * Eg: XIPC_PROC_INTERRUPT(" . 
                        $subSysMasterProc->{'name'} . ", <BInterruptNum>);\n";
  print xmp_subsystem_h " *\n";
  print xmp_subsystem_h " * Note, you need to enable the interrupt ".
                        "and register an interrupt handler\n";
  print xmp_subsystem_h " * at the target processor\n";
  
  print xmp_subsystem_h " */\n";
  print xmp_subsystem_h 
        "#define XIPC_PROC_INTERRUPT(TARGET_PROC_NAME, TARGET_PROC_INTR) \\\n";
  print xmp_subsystem_h 
        "        __XIPC_PROC_INTERRUPT(TARGET_PROC_NAME, TARGET_PROC_INTR)\n";

  print xmp_subsystem_h "\n";
  print xmp_subsystem_h "#endif /* __XMP_SUBSYSTEM_H__ */\n";

  close xmp_subsystem_h;

  printLog($logDebugLevel1, "Leaving generateSysHeaderFile()\n");
}

sub printProcParams {
  foreach my $proc (values %$procParamsNameMap) {
    print "Printing config params for: $proc->{'config'}\n";
    print "  NX: " . $proc->{'NX'}. "\n";
    print "  DataMasterWidth: " . $proc->{'DataMasterWidth'}. "\n" 
      if (defined $proc->{'DataMasterWidth'});
    print "  InstMasterWidth: " . $proc->{'InstMasterWidth'}. "\n" 
      if (defined $proc->{'InstMasterWidth'});
    print "  DataSlaveWidth: " . $proc->{'DataSlaveWidth'}. "\n" 
      if (defined $proc->{'DataSlaveWidth'});
    print "  InstSlaveWidth: " . $proc->{'InstSlaveWidth'}. "\n" 
      if (defined $proc->{'InstSlaveWidth'});
    print "  iDMAWidth: " . $proc->{'iDMAWidth'}. "\n" 
      if (defined $proc->{'iDMAWidth'});
    print "  APB " . $proc->{'APB'}. "\n" 
      if (defined $proc->{'APB'});
  }
}

sub getCompName {
  my $comp = shift;
  if (defined $subSystemL2Ids->{$comp}) {
    return $subSystemL2Ids->{$comp}->{'name'};
  }
  if (defined $subSystemMMIOIds->{$comp}) {
    return $subSystemMMIOIds->{$comp}->{'name'};
  }
  if (defined $xnneIdMap->{$comp}) {
    return $xnneIdMap->{$comp}->{'name'};
  }
  if (defined $procIdMap->{$comp}) {
    return $procIdMap->{$comp}->{'name'};
  }
  if (defined $subSystemMMIOIds->{$comp}) {
    return $subSystemMMIOIds->{$comp}->{'name'};
  }
  if (defined $subSystemL2Ids->{$comp}) {
    return $subSystemL2Ids->{$comp}->{'name'};
  }
  if ($comp == $COMMON_BUS_ID) {
    return "CommonBus";
  }
}

# Print subsystem summary
sub printSubSystem {
  
  printLog($logDebugLevel1, 
           "  ** Printing contents of Subsystem $subSystemName **\n");

  # Print the proc definitions
  foreach my $pid (sort {$a<=>$b} (keys %$procIdMap)) {
    my $proc = $procIdMap->{$pid};
    printProc($proc);
  }

  printLog($logDebugLevel1, 
           "  Master processor: $subSysMasterProc->{'name'}\n");

  # Print interconnect definition
  printLog($logDebugLevel1, "  Interconnect\n");
  foreach my $pid (sort {$a<=>$b} (keys %$subSysInterconnectTo)) {
    my $src;
    if ($pid == $COMMON_BUS_ID) {
      $src = "Bus";
    } elsif (defined $subSystemL2Ids->{$pid}) {
      $src = $subSystemL2Ids->{$pid}->{'name'};
    } elsif (defined $subSystemMMIOIds->{$pid}) {
      $src = $subSystemMMIOIds->{$pid}->{'name'};
    } elsif (defined $xnneIdMap->{$pid}) {
      $src = $xnneIdMap->{$pid}->{'name'};
    } else {
      $src = $procIdMap->{$pid}->{'name'};
    }
 
    printLog($logDebugLevel1, 
             "    - Src: $src -> [".
             join(",", map(getCompName($_), @{$subSysInterconnectTo->{$pid}})).
             "]\n");

    # Print XNNE port map
    if (isXNNEId($pid)) {
      my $pmap = $xnneIdMap->{$pid}->{'masterPortMap'};
      foreach my $port (keys %$pmap)  {
        print "    - $src Port:$port -> {".
              join(",",map(getCompName($_),@{$pmap->{$port}}))."}\n";
      }
    }
  }

  printLog($logDebugLevel1, "      CommonBusWidth: $subSysBusWidth\n");

  # Print the system RAM/ROM definitions
  printLog($logDebugLevel1, 
           "  SystemRAM : {Size:  $systemRAM->{'size'}, GlobalAddr: ".
           "$systemRAM->{'globalAddr'}, ReadDelay: ".
           "$systemRAM->{'read_delay'},\n");
  printLog($logDebugLevel1, "               RequestFIFODepth : ".
           "$systemRAM->{'request_fifo_depth'}, ".
           "ReadRepeat: $systemRAM->{'read_repeat'},\n");
  printLog($logDebugLevel1, 
           "               WriteDelay : $systemRAM->{'write_delay'}, ".
           "WriteRepeat: $systemRAM->{'write_repeat'}}\n");

  if (defined $systemROM->{'globalAddr'}) {
    printLog($logDebugLevel1, 
             "  SystemROM : {Size:  $systemROM->{'size'}, ".
             "GlobalAddr: $systemROM->{'globalAddr'}, ReadDelay: ".
             "$systemRAM->{'read_delay'},\n");
    printLog($logDebugLevel1, 
             "               RequestFIFODepth : ".
             "$systemROM->{'request_fifo_depth'}, ReadRepeat: ".
             "$systemROM->{'read_repeat'},\n");
    printLog($logDebugLevel1, 
             "               WriteDelay : $systemROM->{'write_delay'}, ".
             "WriteRepeat: $systemROM->{'write_repeat'}}\n");
  }

  foreach my $devMem (@DeviceMemories) {
    printLog($logDebugLevel1, 
             "  DeviceMemory : {Name: $devMem->{'name'}, Size:  ".
             "$devMem->{'size'}, GlobalAddr: $devMem->{'globalAddr'},\n");
  printLog($logDebugLevel1, 
           "                  ReadDelay: $devMem->{'read_delay'}, ".
           "RequestFIFODepth : $devMem->{'request_fifo_depth'},  ".
           "ReadRepeat: $devMem->{'read_repeat'},\n");
  printLog($logDebugLevel1, 
           "                  WriteDelay : $devMem->{'write_delay'}, ".
           "WriteRepeat: $devMem->{'write_repeat'}}\n");
  }
}

# Verify and process the SubSystemInterconnect section
sub processInterconnect {
  my $subSys = shift;

  $subSysInterconnectTo->{$COMMON_BUS_ID} = [];
  $subSysInterconnectFrom->{$COMMON_BUS_ID} = [];

  # If there is no SubSystemInterconnect section, 
  # assume all procs are connected
  # to the common bus and and the bus is connected to none
  if (!defined $subSys->{'SubSystemInterconnect'}) {
    !scalar (values %$subSystemL2s) or
      die "L2 requires interconnect specification\n";
    foreach my $proc (values %$procNameMap) {
      push @{$subSysInterconnectTo->{$proc->{'id'}}}, $COMMON_BUS_ID;
      push @{$subSysInterconnectFrom->{$COMMON_BUS_ID}}, $proc->{'id'};

      # All processors with local MMIO/sDMA assumes, by default, 
      # to have a connection from the bus
      if (defined $proc->{'mmio'} or defined $proc->{'sdma'}) {
        push @{$subSysInterconnectTo->{$COMMON_BUS_ID}}, $proc->{'id'};
        push @{$subSysInterconnectFrom->{$proc->{'id'}}}, $COMMON_BUS_ID;
      }

      # Connect to SubSystemMMIO
      scalar (values %$subSystemMMIOs) == 0 or
      scalar (values %$subSystemMMIOs) == 1 or
        die "No interconnect spec; Cannot have more than one SubSystemMMIO\n";

      foreach my $smmio (values %$subSystemMMIOs) {
        # Add if apb specs match
        if ((defined $smmio->{'apb'} and $proc->{'apbMaster'}) or
            (!defined $smmio->{'apb'} and !$proc->{'apbMaster'})) {
          push @{$subSysInterconnectTo->{$proc->{'id'}}}, $smmio->{'id'};
          push @{$subSysInterconnectFrom->{$smmio->{'id'}}}, $proc->{'id'};
        }
      }
    }

    # All XNNEs are always connected to the bus
    foreach my $xnne (values %$xnneNameMap) {
      push @{$subSysInterconnectTo->{$xnne->{'id'}}}, $COMMON_BUS_ID;
      push @{$subSysInterconnectFrom->{$COMMON_BUS_ID}}, $xnne->{'id'};
      # Add connection to subsystem mmio if not apb
      foreach my $smmio (values %$subSystemMMIOs) {
        if (!defined $smmio->{'apb'}) {
          push @{$subSysInterconnectTo->{$xnne->{'id'}}}, $smmio->{'id'};
          push @{$subSysInterconnectFrom->{$smmio->{'id'}}}, $xnne->{'id'};
        }
      }
      # Add connection from bus to xnne
      push @{$subSysInterconnectTo->{$COMMON_BUS_ID}}, $xnne->{'id'};
      push @{$subSysInterconnectFrom->{$xnne->{'id'}}}, $COMMON_BUS_ID;
      # Populate the masterPortMap and masterCompMap for xnne
      my $port = 0;
      foreach my $mw (@{$xnne->{'masterWidths'}}) {
        push @{$xnne->{'masterPortMap'}->{$port}}, 
             @{$subSysInterconnectTo->{$xnne->{'id'}}}; 
        $port++;
      }
      my $pmap = $xnne->{'masterPortMap'};
      foreach my $port (keys %$pmap)  {
        foreach my $comp (@{$pmap->{$port}}) {
          push @{$xnne->{'masterCompMap'}->{$comp}}, $port;
        }
      }
    }

    return;
  }

  printLog($logDebugLevel2, "In processInterconnect()\n");

  my $connections = $subSys->{'SubSystemInterconnect'};
  ref($connections) eq 'ARRAY' or 
    die "Error : Subsystem interconnect needs to have an array ".
        "of connections defined\n";

  foreach my $conn (@$connections) {
    ref($conn) eq 'HASH' or 
      die "Error: Subsystem interconnect connection has to be a map\n";

    defined $conn->{'Src'} or
      die "Src not defined in subsystem interconnect connection\n";

    # The source of the connection has to be a CommonBus or a processor name
    $conn->{'Src'} eq 'CommonBus' or 
    defined $procNameMap->{$conn->{'Src'}} or
    defined $xnneNameMap->{$conn->{'Src'}} or
      die "Src component $conn->{'Src'} has to be a processor name or " .
          "XNNE or the 'CommonBus'\n";

    defined $conn->{'Dests'} or
      die "Dests not defined in subsystem interconnect connection\n";

    my $dests = $conn->{'Dests'};
    ref($dests) eq 'ARRAY' or 
      die "Error : Dests needs to have an array of components defined\n";

    # The list of destination components that the src is connected to 
    # has to be a processor name
    foreach my $dcomp (@$dests) {
      # XNNE with port spec can have CommonBus as destination
      if (defined $xnneNameMap->{$conn->{'Src'}} and
          defined $conn->{'Port'} and $dcomp eq 'CommonBus') {
        next;
      }
      # Dest cannot be CommonBus
      $dcomp ne 'CommonBus' or 
        die "Dest component of Src component $conn->{'Src'} ".
            "cannot be the CommonBus\n";
      # Dest could be an L2
      if (defined $subSystemL2s->{$dcomp}) {
        !defined $subSysHostProc or 
        $procNameMap->{$conn->{'Src'}} != $subSysHostProc or 
          die "$conn->{'Src'} which is connected to ".
              "$subSystemL2s->{$dcomp}->{'name'} cannot be a host\n";
        next;
      }
      # Check if it is a SubSystemMMIO
      if (defined $subSystemMMIOs->{$dcomp}) {
        if (defined $procNameMap->{$conn->{'Src'}}) {
          (defined $subSystemMMIOs->{$dcomp}->{'apb'} and
           $procNameMap->{$conn->{'Src'}}->{'apbMaster'} == 1) or
          (!defined $subSystemMMIOs->{$dcomp}->{'apb'} and
           $procNameMap->{$conn->{'Src'}}->{'apbMaster'} == 0) or
          die "Inconsistent apb usage of proc ".
              "$procNameMap->{$conn->{'Src'}}->{'name'} and ".
              "SubSystemMMIO $dcomp\n";
        }
        next;
      }
      # Check if it is an XNNE
      if (defined $xnneNameMap->{$dcomp}) {
        next;
      }
      # If not, it has to be a proc
      defined $procNameMap->{$dcomp} or
        die "Dest component of Src component $conn->{'Src'} ".
            "has to be a processor, XNNE, an L2, or a SubSystemMMIO\n";
      if ($conn->{'Src'} eq $dcomp) {
        die "$dcomp src cannot have itself in its dest component list\n";
      }

      $procNameMap->{$dcomp}->{'inBound'} = 1;

      # If the destination is part of a local memory cluster, do
      # the checks for the first core in the cluster
      my $check_dcomp = $dcomp;
      if (defined $procNameMap->{$dcomp}->{'sharedLmemCid'}) {
        my $cid = $procNameMap->{$dcomp}->{'sharedLmemCid'};
        $check_dcomp = ${$sharedLocalMemClusterMap->{$cid}}[0]->{'name'};
      }
      if (!defined $procNameMap->{$check_dcomp}->{'instRam0'} and
          !defined $procNameMap->{$check_dcomp}->{'dataRam0'}) {
        die "${dcomp} needs either a InstRAM or DataRAM for a ".
            "direct connect from src component $conn->{'Src'}\n";
      }
      if ($procNameMap->{$check_dcomp}->{'pipeline'} eq 'NX') {
        (defined $procNameMap->{$check_dcomp}->{'slaveWidth'} and
         $procNameMap->{$check_dcomp}->{'slaveDataInstMerged'}) or
        defined $procNameMap->{$check_dcomp}->{'slaveInstWidth'} or
        defined $procNameMap->{$check_dcomp}->{'slaveDataWidth'} or
            die "${dcomp} has inbound, but ".
                "SlaveWidth/SlaveDataWidth/SlaveInstWidth is not specified\n";
        if (defined $procNameMap->{$check_dcomp}->{'instRam0'} and
            defined 
                $procNameMap->{$check_dcomp}->{'instRam0'}->{'globalAddr'}) {
           (defined $procNameMap->{$check_dcomp}->{'slaveWidth'} and
            $procNameMap->{$check_dcomp}->{'slaveDataInstMerged'}) or
          defined $procNameMap->{$check_dcomp}->{'slaveInstWidth'} or
            die "${dcomp} has inbound and InstRAM with global address map, ".
                "but SlaveWidth/SlaveInstWidth is not specified\n";
        }
        if (defined $procNameMap->{$check_dcomp}->{'dataRam0'} and
            defined 
                $procNameMap->{$check_dcomp}->{'dataRam0'}->{'globalAddr'}) {
          defined $procNameMap->{$check_dcomp}->{'slaveWidth'} or
          defined $procNameMap->{$check_dcomp}->{'slaveDataWidth'} or
            die "${dcomp} has inbound and DataRAM with global address map, ".
                "but SlaveWidth/SlaveDataWidth is not specified\n";
        }
        if (defined $procNameMap->{$check_dcomp}->{'slaveInstWidth'}) {
          defined $procNameMap->{$check_dcomp}->{'instRam0'} or
            die "${dcomp} has inbound and SlaveInstWidth, ".
                "but InstRAM is missing\n";
          defined 
                $procNameMap->{$check_dcomp}->{'instRam0'}->{'globalAddr'} or
            die "${dcomp} has inbound and SlaveInstWidth, ".
                "but InstRAM has no global address map\n";
        }
        if (defined $procNameMap->{$check_dcomp}->{'slaveDataWidth'}) {
          defined $procNameMap->{$check_dcomp}->{'dataRam0'} or
            die "${dcomp} has inbound and SlaveDataWidth, ".
                "but DataRAM is missing\n";
            defined 
                $procNameMap->{$check_dcomp}->{'dataRam0'}->{'globalAddr'} or
            die "${dcomp} has inbound and SlaveDataWidth, ".
                "but DataRAM has no global address map\n";
        }
      }
      my $hasGlobalAddrMap = 0;
      if (defined $procNameMap->{$check_dcomp}->{'instRam0'}) {
        $hasGlobalAddrMap |=
          defined $procNameMap->{$check_dcomp}->{'instRam0'}->{'globalAddr'};
      }
      if (defined $procNameMap->{$check_dcomp}->{'instRam1'}) {
        $hasGlobalAddrMap |=
          defined $procNameMap->{$check_dcomp}->{'instRam1'}->{'globalAddr'};
      }
      if (defined $procNameMap->{$check_dcomp}->{'dataRam0'}) {
        $hasGlobalAddrMap |=
          defined $procNameMap->{$check_dcomp}->{'dataRam0'}->{'globalAddr'};
      }
      if (defined $procNameMap->{$check_dcomp}->{'dataRam1'}) {
        $hasGlobalAddrMap |=
          defined $procNameMap->{$check_dcomp}->{'dataRam1'}->{'globalAddr'};
      }
      $hasGlobalAddrMap or 
        die "$check_dcomp does not have global address map ".
            "specified for its local memories\n";
    }

    # Add dests to subSysInterconnectTo[src] and
    # add src to subSysInterconnectFrom[dest]
    my $src_pid;
    if ($conn->{'Src'} eq 'CommonBus') {
      $src_pid = $COMMON_BUS_ID;
    } elsif (defined $procNameMap->{$conn->{'Src'}}) {
      $src_pid = $procNameMap->{$conn->{'Src'}}->{'id'};
    } else {
      $src_pid = $xnneNameMap->{$conn->{'Src'}}->{'id'};
    }

    # Check for ports
    if (defined $xnneIdMap->{$src_pid} and defined $conn->{'Port'}) {
      ($conn->{'Port'} =~ /^\d+$/) or 
        die "Port field for XNNE $xnneIdMap->{$src_pid}->{'name'} ".
            "has to be an integer\n";
      my $port = $conn->{'Port'};
      !defined $xnneIdMap->{$src_pid}->{'masterPortMap'}->{$port} or
        die "Port $port for XNNE $xnneIdMap->{$src_pid}->{'name'} ".
            "is already mapped\n";
      $port < @{$xnneIdMap->{$src_pid}->{'masterWidths'}} or 
        die "Port number for xnne $xnneIdMap->{$src_pid}->{'name'} ".
            "has to be between 0..".
            (@{$xnneIdMap->{$src_pid}->{'masterWidths'}}-1)."\n";
    }

    foreach my $d (@$dests) {
      my $dest_pid;
      if (defined $subSystemL2s->{$d}) {
        $dest_pid = $subSystemL2s->{$d}->{'id'};
      } elsif (defined $subSystemMMIOs->{$d}) {
        $dest_pid = $subSystemMMIOs->{$d}->{'id'};
      } elsif (defined $xnneNameMap->{$d}) {
        $dest_pid = $xnneNameMap->{$d}->{'id'};
      } elsif ($d eq 'CommonBus') {
        $dest_pid = $COMMON_BUS_ID;
      } else {
        $dest_pid = $procNameMap->{$d}->{'id'};
      }
      # If Port spec present for XNNE
      if (defined $xnneIdMap->{$src_pid} and defined $conn->{'Port'}) {
        my $port = $conn->{'Port'};
        push @{$xnneIdMap->{$src_pid}->{'masterPortMap'}->{$port}},
             $dest_pid;
        if (! grep { $_ eq $dest_pid } @{$subSysInterconnectTo->{$src_pid}}) {
          push @{$subSysInterconnectTo->{$src_pid}}, $dest_pid;
          push @{$subSysInterconnectFrom->{$dest_pid}}, $src_pid;
        }
      } else {
        !defined $subSysInterconnectTo->{$src_pid} or 
          ! grep { $_ eq $dest_pid } @{$subSysInterconnectTo->{$src_pid}} or
          die "Error: Duplicate definition of $conn->{'Src'}'s interconnect\n";
        push @{$subSysInterconnectTo->{$src_pid}}, $dest_pid;
        push @{$subSysInterconnectFrom->{$dest_pid}}, $src_pid;
      }
    }
  }

  if (scalar (keys %$subSystemMMIOs) > 1) {
    # For more than one subsystem mmio, if apb specified, it needs to be
    # connected to a proc
    foreach my $smmio (values %$subSystemMMIOs) {
      !defined $smmio->{'apb'} or
       defined $subSysInterconnectFrom->{$smmio->{'id'}} or
        die "SubSystemMMIO $smmio->{'name'} not connected to any processor\n";
    }
  } elsif (scalar (keys %$subSystemMMIOs)) { 
    # If only 1 subsystem mmio, add to mapping if not already present
    my ($smmio) = keys %$subSystemMMIOs;
    if (!defined $subSysInterconnectFrom->{$subSystemMMIOs->{$smmio}->{'id'}}) {
      foreach my $proc (values %$procNameMap) {
        # Add if apb specs match
        if ((defined $subSystemMMIOs->{$smmio}->{'apb'} and
             $proc->{'apbMaster'}) or
            (!defined $subSystemMMIOs->{$smmio}->{'apb'} and
             !$proc->{'apbMaster'})) {
          push @{$subSysInterconnectFrom->{$subSystemMMIOs->{$smmio}->{'id'}}},
               $proc->{'id'};
          push @{$subSysInterconnectTo->{$proc->{'id'}}}, 
               $subSystemMMIOs->{$smmio}->{'id'};
        }
      }
      # Add XNNE
      foreach my $xnne (values %$xnneNameMap) {
        if (!defined $subSystemMMIOs->{$smmio}->{'apb'}) {
          push @{$subSysInterconnectFrom->{$subSystemMMIOs->{$smmio}->{'id'}}},
               $xnne->{'id'};
          push @{$subSysInterconnectTo->{$xnne->{'id'}}}, 
               $subSystemMMIOs->{$smmio}->{'id'};
        }
      }
    }
  }

  # All processors are assumed by default to connect to the common bus
  foreach my $proc (values %$procNameMap) {
    if ((!grep { $_ eq $COMMON_BUS_ID } 
          @{$subSysInterconnectTo->{$proc->{'id'}}})) {
      # If proc is connected to L2-CC and has no dma, avoid connecting to bus
      my @l2s = grep { defined $subSystemL2Ids->{$_} }
                @{$subSysInterconnectTo->{$proc->{'id'}}};
      if (scalar @l2s and $subSystemL2Ids->{$l2s[0]}->{'isL2CC'} and 
         !defined $proc->{'idma'} and !defined $proc->{'sdma'}) {
        next;
      }
      push @{$subSysInterconnectTo->{$proc->{'id'}}}, $COMMON_BUS_ID;
      push @{$subSysInterconnectFrom->{$COMMON_BUS_ID}}, $proc->{'id'};
    }
  }

  # All XNNES are assumed by default to connect to the common bus
  foreach my $xnne (values %$xnneNameMap) {
    if ((!grep { $_ eq $COMMON_BUS_ID } 
          @{$subSysInterconnectTo->{$xnne->{'id'}}})) {
      push @{$subSysInterconnectTo->{$xnne->{'id'}}}, $COMMON_BUS_ID;
      push @{$subSysInterconnectFrom->{$COMMON_BUS_ID}}, $xnne->{'id'};
    }
  }

  # All processors with local MMIO/sDMA assumes, by default, 
  # to have a connection from the bus
  foreach my $proc (values %$procNameMap) {
    if (defined $proc->{'mmio'} or defined $proc->{'sdma'}) {
      # Add bus to proc, if not already present
      if (!grep { $_ eq $proc->{'id'} } 
          @{$subSysInterconnectTo->{$COMMON_BUS_ID}}) {
        push @{$subSysInterconnectTo->{$COMMON_BUS_ID}}, $proc->{'id'};
        push @{$subSysInterconnectFrom->{$proc->{'id'}}}, $COMMON_BUS_ID;
      }
    }
  }

  # Add bus to XNNE, if no other connection to XNNE is already present
  foreach my $xnne (values %$xnneNameMap) {
    if (defined $subSysInterconnectFrom->{$xnne->{'id'}}) {
      next;
    }
    push @{$subSysInterconnectTo->{$COMMON_BUS_ID}}, $xnne->{'id'};
    push @{$subSysInterconnectFrom->{$xnne->{'id'}}}, $COMMON_BUS_ID;
  }

  # If the bus is not specified, it is assumed to connect to none
  if (!defined $subSysInterconnectTo->{$COMMON_BUS_ID}) {
    $subSysInterconnectTo->{$COMMON_BUS_ID} = [];
  }

  # Verify that if there is a port specification, it matches the number
  # of master ports
  foreach my $xnne (values %$xnneNameMap) {
    # All ports connect to all connected components
    if (!defined $xnne->{'masterPortMap'}) {
      my $port = 0;
      foreach my $mw (@{$xnne->{'masterWidths'}}) {
        push @{$xnne->{'masterPortMap'}->{$port}}, 
             @{$subSysInterconnectTo->{$xnne->{'id'}}}; 
        $port++;
      }
    }
    my $pmap = $xnne->{'masterPortMap'};
    scalar(@{$xnne->{'masterWidths'}}) == scalar(keys %$pmap) or
      die "Masterwidths ".scalar(@{$xnne->{'masterWidths'}}).
          " and number of ports ".scalar(keys %$pmap).
          " do not match for xnne $xnne->{'name'}\n";

    # Create a reverse map of target component to list of ports
    foreach my $port (keys %$pmap)  {
      foreach my $comp (@{$pmap->{$port}}) {
        # XNNE can connect to a proc or another xnne only via one of the ports
        if (isXNNEId($comp) || isProcId($comp)) {
          !defined $xnne->{'masterCompMap'}->{$comp} or
            die "XNNE $xnne->{'name'} cannot have more than 1 port to ".
                (isProcId($comp) ? $procIdMap->{$comp}->{'name'}
                                 : $xnneIdMap->{$comp}->{'name'})."\n";
        }
        push @{$xnne->{'masterCompMap'}->{$comp}}, $port;
      }
    }
  }


  foreach my $l2id (keys %$subSystemL2Ids) {
    defined $subSysInterconnectFrom->{$l2id} or 
      die "L2 '$subSystemL2Ids->{$l2id}->{'name'}' ".
          "requires an interconnect specification of ".
          "which cores are connected to L2\n";
  }

  # Check if all configs attached to the L2 to be the same config type
  my $check_l2_config;
  foreach my $l2 (values %$subSystemL2Ids) {
    foreach my $pid (@{$subSysInterconnectFrom->{$l2->{'id'}}}) {
      defined $procIdMap->{$pid} or defined $xnneIdMap->{$pid} or 
        die "L2 '$l2->{'name'}' can connect only from a proc or XNNE\n";
      !defined $check_l2_config or 
      !defined $procIdMap->{$pid} or
       $procIdMap->{$pid}->{'config'} eq $check_l2_config->{'config'} or
        die "All configs connected to L2 '$l2->{'name'}' are ".
            "expected to be the same\n";
      if (defined $procIdMap->{$pid}) {
        $check_l2_config = $procIdMap->{$pid};
      }
      if ($l2->{'isL2CC'}) {
        defined $procIdMap->{$pid} or
          die "L2 '$l2->{'name'}' can connect only from a proc\n";
        !defined $procIdMap->{$pid}->{'idma'} or
        !$procIdMap->{$pid}->{'idma'}->{'shared'} or
          die "IDMA cannot be shared on configs ".
              "connected to L2 '$l2->{'name'}'\n";
        !defined $procIdMap->{$pid}->{'sdma'} or
        !$procIdMap->{$pid}->{'sdma'}->{'shared'} or
          die "SDMA cannot be shared on configs connected to L2 ".
              "'$l2->{'name'}'\n";
      }
    }

    if (!$l2->{'isL2CC'} and $l2->{'numBanks'} == 1) {
      if (!defined $l2->{'numPorts'}) {
        # Need atleast one for the inbound from bus
        $l2->{'numPorts'} = 1;
        foreach my $pid (@{$subSysInterconnectFrom->{$l2->{'id'}}}) {
          if (isProcId($pid) and (defined $procIdMap->{$pid}->{'idma'} or 
                                  defined $procIdMap->{$pid}->{'sdma'})) {
            $l2->{'numPorts'}++;
          } elsif (isXNNEId($pid)) {
            $l2->{'numPorts'} += 
                 @{$xnneIdMap->{$pid}->{'masterCompMap'}->{$l2->{'id'}}};
          }
        }
      } else {
        my $nc = 0;
        foreach my $pid (@{$subSysInterconnectFrom->{$l2->{'id'}}}) {
          if (isProcId($pid) and
              ((defined $procIdMap->{$pid}->{'idma'} and 
                !$procIdMap->{$pid}->{'idma'}->{'shared'}) or 
               (defined $procIdMap->{$pid}->{'sdma'} and
                !$procIdMap->{$pid}->{'sdma'}->{'shared'}))) {
            $nc++;
          } elsif (isXNNEId($pid)) {
            $nc += @{$xnneIdMap->{$pid}->{'masterCompMap'}->{$l2->{'id'}}};
          }
        }
        $l2->{'numPorts'} <= ($nc == 0 ? 1 : $nc) or
          die "Num L2 RAM ports for '$l2->{'name'}' ".
              "($l2->{'numPorts'}) has to <= ".($nc == 0 ? 1 : $nc)."\n";
        $nc % $l2->{'numPorts'} == 0 or
          die "Number of procs/xnnes connected to L2 '$l2->{'name'}' ".
              "($nc) has to be a multiple of number of ports ".
              "($l2->{'numPorts'})\n";
      }
      if (!defined $l2->{'numCorePorts'}) {
        $l2->{'numCorePorts'} = 
            scalar (grep { isProcId($_) } 
                    @{$subSysInterconnectFrom->{$l2->{'id'}}});
      } else {
        my $nc = scalar (grep { isProcId($_) }
                         @{$subSysInterconnectFrom->{$l2->{'id'}}});
        $l2->{'numCorePorts'} <= $nc or
          die "Cannot have more than $nc L2 RAM core ports for ".
              "'$l2->{'name'}'\n";
        $nc % $l2->{'numCorePorts'} == 0 or
          die "Number of cores connected to L2 '$l2->{'name'} ".
              "($nc) has to be a multiple of number of core ports ".
              "($l2->{'numCorePorts'})\n";
      }
    }

    if ($l2->{'isL2CC'}) {
      my $nc = 0;
      foreach my $pid (@{$subSysInterconnectFrom->{$l2->{'id'}}}) {
        my $proc = $procIdMap->{$pid};
        if (defined $proc->{'idma'} or defined $proc->{'sdma'}) {
          $nc++;
        }
      }
      if ($nc == 0) {
        # If no dma, set numPorts to 1 for the inbound from bus
        $l2->{'numPorts'} = 1;
      } else {
        $nc % $l2->{'numPorts'} == 0 or
          die "Number of cores connected to L2CC ($nc) ".
              "$l2->{'name'} has to be a multiple of number of ".
              "slave ports ($l2->{'numPorts'})\n";
      }
    }
  }

  # Proc should be connected to only 1 L2 and SubSystemMMIO
  foreach my $proc (values %$procNameMap) {
    my $has_l2 = 0;
    my $has_smmio = 0;
    foreach my $id (@{$subSysInterconnectTo->{$proc->{'id'}}}) {
      if (defined $subSystemL2Ids->{$id}) {
        $has_l2 == 0 or
          die "Proc $proc->{'name'} can only be connected to a single L2\n";
        $has_l2 = 1;
      }
      if (defined $subSystemMMIOIds->{$id}) {
        $has_smmio == 0 or
          die "Proc $proc->{'name'} can only be connected to a ".
              "single SubSystemMMIO\n";
        $has_smmio = 1;
      }
    }
  }

  # XNNE should be connected to only 1 L2 and SubSystemMMIO
  foreach my $xnne (values %$xnneNameMap) {
    my $has_l2 = 0;
    my $has_smmio = 0;
    foreach my $id (@{$subSysInterconnectTo->{$xnne->{'id'}}}) {
      if (defined $subSystemL2Ids->{$id}) {
        $has_l2 == 0 or
          die "XNNE $xnne->{'name'} can only be connected to a single L2\n";
        $has_l2 = 1;
      }
      if (defined $subSystemMMIOIds->{$id}) {
        $has_smmio == 0 or
          die "XNNE $xnne->{'name'} can only be connected to a ".
              "single SubSystemMMIO\n";
        $has_smmio = 1;
      }
    }
  }

  printLog($logDebugLevel2, "Leaving processInterconnect()\n");
}

# SystemRAM, SysemROM, DeviceMemories
sub processSystemMemory {
  my ($mem, $memName, $memDef) = @_;

  defined $mem->{'GlobalAddr'} or 
    die "Error: $memName GlobalAddr undefined\n";

  defined $mem->{'Size'} or 
    die "Error: $memName Size undefined\n";

  isValidHex($mem->{'GlobalAddr'}) or
    die "Error: $memName GlobalAddr has to be in hex\n";

  isValidSize($mem->{'Size'}) or
    die "Error: $memName Size has to be <num>(b|Kb|Mb)\n";

  if (defined $mem->{'ReadDelay'}) {
    ($mem->{'ReadDelay'} =~ /^\d+$/) or
    die "Error: $memName ReadDelay has to be an integer\n";
  }

  if (defined $mem->{'ReadRepeat'}) {
    ($mem->{'ReadRepeat'} =~ /^\d+$/) or
    die "Error: $memName ReadRepeat has to be an integer\n";
  }

  if (defined $mem->{'WriteDelay'}) {
    ($mem->{'WriteDelay'} =~ /^\d+$/) or
    die "Error: $memName WriteDelay has to be an integer\n";
  }

  if (defined $mem->{'WriteRepeat'}) {
    ($mem->{'WriteRepeat'} =~ /^\d+$/) or
    die "Error: $memName WriteRepeat has to be an integer\n";
  }

  if (defined $mem->{'WriteResponse'}) {
    ($mem->{'WriteResponse'} =~ /^\d+$/) or
    die "Error: $memName WriteResponse has to be an integer\n";
  }

  if (defined $mem->{'RequestFIFODepth'}) {
    ($mem->{'RequestFIFODepth'} =~ /^\d+$/) or
    die "Error: $memName RequestFIFODepth has to be an integer\n";
  }

  if (defined $mem->{'HostShared'}) {
    ($mem->{'HostShared'} == 1) or
      die "Error: HostShared flag on $memName needs to be true\n";
    defined $mem->{'HostName'} or 
      die "Error HostShared memory needs a HostName\n";
  }

  # Optional name
  if (defined $mem->{'Name'}) {
    ($mem->{'Name'} =~ /^[a-zA-Z][a-zA-Z0-9_]+$/) or 
      die "Error: Memory name has to be a alpha numerical ".
          "(underscores allowed) beginning with a letter \n";
    $memName = $mem->{'Name'};
  }

  $memDef->{'name'} = $memName;
  $memDef->{'size'} = computeSize($mem->{'Size'});
  $memDef->{'globalAddr'} = $mem->{'GlobalAddr'};

  if (!defined $mem->{'ReadDelay'}) {
    $memDef->{'read_delay'} = 1;
  } else {
    $memDef->{'read_delay'} = $mem->{'ReadDelay'};
  }

  if (!defined $mem->{'WriteDelay'}) {
    $memDef->{'write_delay'} = 1;
  } else {
    $memDef->{'write_delay'} = $mem->{'WriteDelay'};
  }

  if (!defined $mem->{'ReadRepeat'}) {
    $memDef->{'read_repeat'} = 1;
  } else {
    $memDef->{'read_repeat'} = $mem->{'ReadRepeat'};
  }

  if (!defined $mem->{'WriteRepeat'}) {
    $memDef->{'write_repeat'} = 1;
  } else {
    $memDef->{'write_repeat'} = $mem->{'WriteRepeat'};
  }

  if (!defined $mem->{'WriteResponse'}) {
    $memDef->{'write_response'} = 1;
  } else {
    $memDef->{'write_response'} = $mem->{'WriteResponse'};
  }
  
  if (!defined $mem->{'RequestFIFODepth'}) {
    $memDef->{'request_fifo_depth'} = 2;
  } else {
    $memDef->{'request_fifo_depth'} = $mem->{'RequestFIFODepth'};
  }

  if (defined $mem->{'HostShared'}) {
    $memDef->{'host_shared'} = 1;
    $memDef->{'host_name'} = $mem->{'HostName'};
  } else {
    $memDef->{'host_shared'} = 0;
  }

  verifyAddressRange($mem->{'GlobalAddr'}, 
                     $mem->{'Size'});
}

# DTS
sub processXRPDeviceTreeSpec {
  my $xrpDTSDef = shift;

  ref ($xrpDTSDef) eq 'HASH' or 
    die "Error: XRPDeviceTreeSpec specification has to be a map\n";

  $xrpDTS = new XRPDeviceTreeSpec;

  if (!defined $xrpDTSDef->{'XRPSharedMem'}) {
    die "Error Processing XRPDeviceTreeSpec: ".
        "Host shared device memory not specified\n";
  }

  my $xrpSharedMemName = $xrpDTSDef->{'XRPSharedMem'};
  
  my $xrpSharedMem;
  foreach my $devMem (@DeviceMemories) {
    if ($devMem->{'name'} eq $xrpDTSDef->{'XRPSharedMem'}) {
      !defined $xrpSharedMem or 
        die "Only one device memory can be a XRPSharedMem\n";
      $xrpSharedMem = $devMem;
    }
  }

  $xrpDTS->{'shared_mem'} = $xrpSharedMem;

  # Setup queues
  if (defined $xrpDTSDef->{'Queues'}) {
    ref ($xrpDTSDef->{'Queues'}) eq 'ARRAY' or 
      die "Error: XRPDeviceTreeSpec Queues specification has to be a list\n";

    foreach my $queue (@{$xrpDTSDef->{'Queues'}}) {
      ref ($queue) eq 'HASH' or 
        die "Error: XRPDeviceTreeSpec each queue specification ".
            "has to be a map\n";
      defined $queue->{'Proc'} or 
        die "Error: XRPDeviceTreeSpec queue spec needs a proc name\n";
      defined $queue->{'Priorities'} or 
        die "Error: XRPDeviceTreeSpec queue spec needs a priority list\n";
      ref ($queue->{'Priorities'}) eq 'ARRAY' or
        die "Error: XRPDeviceTreeSpec queue priorities has to be a list\n";

      my $proc = $queue->{'Proc'};

      defined $procNameMap->{$proc} or
        die "Proc $proc of XRPDeviceTreeSpec proc has to be a processor name\n";
      
      foreach my $pri (@{$queue->{'Priorities'}}) {
        ($pri =~ /^\d+$/) or 
          die "Error: XRPDeviceTreeSpec queue priority for proc $proc ".
              "has to be an integer\n";
        push @{$xrpDTS->{'queues'}->{$proc}}, $pri;
      }
    }
  }
}

# Process a SubSystemIO
sub processSubSystemIO {
  my ($ssIOComp, $subSysIOMap) = @_;

  my $ssio = new SubSystemIO;

  defined $ssIOComp->{'Name'} or
    die "SubSystemIO spec needs a name\n";

  ($ssIOComp->{'Name'} =~ /^[a-zA-Z][a-zA-Z0-9_]+$/) or 
    die "Error: SubSystemIO name has to be a alpha numerical ".
        "(underscores allowed) beginning with a letter \n";

  !defined $subSysIOMap->{$ssIOComp->{'Name'}} or
    die "SubSystemIO '$ssIOComp->{'Name'}' already defined\n";
  $subSysIOMap->{$ssIOComp->{'Name'}} = 1;

  $ssio->{'name'} = $ssIOComp->{'Name'};

  defined $ssIOComp->{'Width'} or die "SubSystemIO spec needs a Width\n";

  ($ssIOComp->{'Width'} =~ /^\d+$/) or 
    die "Error: Width of SubSystemIO $ssIOComp->{'Name'} ".
        "has to be an integer\n";
  ($ssIOComp->{'Width'} > 0 and $ssIOComp->{'Width'} <= 32) or
    die "Width for SubSystemIO $ssIOComp->{'Name'} width ".
        "should be between 1..32\n";

  $ssio->{'width'} = $ssIOComp->{'Width'};

  if (defined $ssIOComp->{'InitValue'}) {
    $ssio->{'initValue'} = $ssIOComp->{'InitValue'};
  } else {
    $ssio->{'initValue'} = 0;
  }

  defined $ssIOComp->{'ControlMap'} or
    die "Error: ControlMap undefined for SubSystemIO $ssIOComp->{'Name'}\n";
  ref ($ssIOComp->{'ControlMap'}) eq 'ARRAY' or
    die "Error. ControlMap specification for SubSystemIO ".
        "$ssIOComp->{'Name'} has to be a list\n";
  scalar @{$ssIOComp->{'ControlMap'}} > 0 or 
    die "Error: No controls mapped in SubSystemIO control ".
        "$ssIOComp->{'Name'}\n";

  my $ctrl_map = $ssIOComp->{'ControlMap'};

  foreach my $cmap (@$ctrl_map) {
    my $ctrl_spin = new ControlSubReg;

    ref($cmap) eq 'HASH' or 
      die "Error: ControlMap entry for SubSystemIO $ssIOComp->{'Name'} ",
          "expected to be a map\n";

    if (defined $cmap->{'BitOffsetStart'}) {
      ($cmap->{'BitOffsetStart'} =~ /^\d+$/) or 
        die "Error: Bit start offset in SubSystemIO $ssIOComp->{'Name'} ".
            "has to be an integer\n";
    } else {
      $cmap->{'BitOffsetStart'} = 0;
    }

    if (defined $cmap->{'BitOffsetEnd'}) {
      ($cmap->{'BitOffsetEnd'} =~ /^\d+$/) or 
        die "Error: Bit end offset in SubSystemMMIO $ssIOComp->{'Name'} ".
            "has to be an integer\n";
    } else {
      $cmap->{'BitOffsetEnd'} = 0;
    }

    # If Proc is defined, check for control map
    if (defined $cmap->{'Proc'}) {
      my $proc = $cmap->{'Proc'};
      defined $procNameMap->{$proc} or
        die "Proc of SubSystemIO $ssIOComp->{'Name'} ".
            "$proc has to be a processor name\n";

      # Check for unique processor control across all SubSystemMMIOs
      !defined $gProcControlMap->{$proc} or
      !grep { $cmap->{'Name'} eq $_ } @{$gProcControlMap->{$proc}} or
        die "Duplicate control $cmap->{'Name'} for Proc $proc in ".
            "SubSystemIO $ssIOComp->{'Name'}\n";

      push @{$gProcControlMap->{$proc}}, $cmap->{'Name'};

      $ctrl_spin->{'comp'} = $proc;
    }

    if (defined $cmap->{'L2'}) {
      my $l2 = $cmap->{'L2'};
      defined $subSystemL2s->{$l2} or
        die "$l2 of SubSystemIO $ssIOComp->{'Name'} is not a L2 name\n";

      # Check for unique L2 control across all SubSystemMMIOs
      !defined $gProcControlMap->{$l2} or
      !grep { $cmap->{'Name'} eq $_ } @{$gProcControlMap->{$l2}} or
        die "Duplicate control $cmap->{'Name'} for L2 $l2 in ".
            "SubSystemIO $ssIOComp->{'Name'}\n";

      push @{$gProcControlMap->{$l2}}, $cmap->{'Name'};

      $ctrl_spin->{'comp'} = $l2;
    }

#    if (defined $cmap->{'Dir'}) {
#      $cmap->{'Dir'} eq 'in' or $cmap->{'Dir'} eq 'out' or 
#        die "Direction for control $cmap->{'Name'} has to be ".
#            "'in' or 'out'\n";
#      $ctrl_spin->{'dir'} = $cmap->{'Dir'};
#    } else {
#      $ctrl_spin->{'dir'} = 'out';
#    }
     $ctrl_spin->{'dir'} = 'out';

    $cmap->{'BitOffsetStart'} <= $cmap->{'BitOffsetEnd'} or
      die "Bit offset start of control $cmap->{'Name'} should be ".
          "less than bit offset end of the SubSystemIO $ssIOComp->{'Name'}\n";

    $cmap->{'BitOffsetEnd'} < $ssio->{'width'} or
      die "Bit offset end of control $cmap->{'Name'} should be less ".
          "than width ($ssio->{'width'}) of the SubSystemIO ".
          "$ssIOComp->{'Name'}\n";

    $ctrl_spin->{'name'} = $cmap->{'Name'};
    $ctrl_spin->{'bitStart'} = $cmap->{'BitOffsetStart'};
    $ctrl_spin->{'bitEnd'} = $cmap->{'BitOffsetEnd'};

    push @{$ssio->{'subPins'}}, $ctrl_spin;
  }

  push @subSystemIOs, $ssio;
}

# Process a SubSystemMMIO
sub processSubSystemMMIO {
  my ($subSystemMMIOComp) = @_;

  if (defined $subSystemMMIOComp->{'InterruptRegisters'}) {
    ref ($subSystemMMIOComp->{'InterruptRegisters'}) eq 'ARRAY' or
      die "Error. InterruptRegisters specification for SubSystemMMIO ".
          "has to be a list\n";
  }

  # Verify the components
  defined $subSystemMMIOComp->{'Name'} or die "SubSystemMMIO needs a name\n";

  ($subSystemMMIOComp->{'Name'} =~ /^[a-zA-Z][a-zA-Z0-9_]+$/) or 
    die "Error: SubSystemMMIO name has to be a alpha numerical ".
        "(underscores allowed) beginning with a letter \n";

  !defined $subSystemMMIOs->{$subSystemMMIOComp->{'Name'}} or
    die "SubSystemMMIO $subSystemMMIOComp->{'Name'} already defined\n";

  my $subSystemMMIO = new SubSystemMMIO;

  # Get a unique component id for this SubSystemMMIO
  my $id = getNewComponentID();

  $subSystemMMIO->{'id'} = $id;
  $subSystemMMIO->{'name'} = $subSystemMMIOComp->{'Name'};

  $subSystemMMIOs->{$subSystemMMIO->{'name'}} = $subSystemMMIO;
  $subSystemMMIOIds->{$subSystemMMIO->{'id'}} = $subSystemMMIO;

  if (defined $subSystemMMIOComp->{'APB'}) {
    ($subSystemMMIOComp->{'APB'} == 0 || 
     $subSystemMMIOComp->{'APB'} == 1) or
      die "Error: SubSystemMMIO APB flag has to be true/false\n";
    if ($subSystemMMIOComp->{'APB'} == 1) {
      $subSystemMMIO->{'apb'} = 1;
    }
  } 

  if (defined $subSystemMMIOComp->{'GlobalAddr'}) {
    isValidHex($subSystemMMIOComp->{'GlobalAddr'}) or
        die "Error: SubSytemMMIO $subSystemMMIO->{'name'} GlobalAddr ".
            "has to be in hex\n";
    $subSystemMMIO->{'globalAddr'} = $subSystemMMIOComp->{'GlobalAddr'};
    defined $subSystemMMIOComp->{'Size'} or 
      die "Error: SubSytemMMIO $subSystemMMIO->{'name'} Size undefined\n";

    $subSystemMMIO->{'size'} = computeSize($subSystemMMIOComp->{'Size'});

    verifyAddressRange($subSystemMMIO->{'globalAddr'}, 
                       $subSystemMMIO->{'size'});

    if (defined $subSystemMMIOComp->{'LocalAddr'}) {
      isValidHex($subSystemMMIOComp->{'LocalAddr'}) or
        die "Error: SubSytemMMIO $subSystemMMIO->{'name'} LocalAddr ".
            "has to be in hex\n";
      $subSystemMMIO->{'localAddr'} = $subSystemMMIOComp->{'LocalAddr'};
    } else {
      $subSystemMMIO->{'localAddr'} = $subSystemMMIOComp->{'GlobalAddr'};
    }
  }

  # Map from proc to list of binterrupts for verification
  my $procBIntrMap = {};

  # Map from proc to list of proc interrupts for verification
  my $procPIntrMap = {};

  # Map from proc to xipc/xrp interrupt for verification
  my $procXIPCIntrMap;
  my $procXRPIntrMap;

  # Map to check unique interrupt register address
  my $intrCtrlRegAddrMap = {};

  foreach my $intrRegSpec (@{$subSystemMMIOComp->{'InterruptRegisters'}}) {
    defined $intrRegSpec->{'GlobalAddr'} or
      die "Error: GlobalAddr undefined for interrupt register ".
          "in SubSystemMMIO\n";
    isValidHex($intrRegSpec->{'GlobalAddr'}) or
      die "Error: InterruptRegister GlobalAddr in SubSystemMMIO ".
          "has to be in hex\n";

    # Check for unique interrupt register address mapping
    !defined $intrCtrlRegAddrMap->{$intrRegSpec->{'GlobalAddr'}} or 
      die "Duplicate mapping for for interrupt register at GlobalAddr ".
          "$intrRegSpec->{'GlobalAddr'}\n";
     $intrCtrlRegAddrMap->{$intrRegSpec->{'GlobalAddr'}} = 1;

    defined $intrRegSpec->{'InterruptMap'} or
      die "Error: InterruptMap undefined for interrupt register at ".
          "$intrRegSpec->{'GlobalAddr'} in SubSystemMMIO\n";
    ref ($intrRegSpec->{'InterruptMap'}) eq 'ARRAY' or
        die "Error. InterruptMap specification for interrupt register at ".
            "$intrRegSpec->{'GlobalAddr'} in SubSystemMMIO has to be a list\n";
    scalar @{$intrRegSpec->{'InterruptMap'}} > 0 
      or die "Error: No interrupts mapped in interrupt register at ".
             "$intrRegSpec->{'GlobalAddr'} in SubSystemMMIO\n";

    my $intr_reg = new SubSystemMMIOInterruptReg;
    $intr_reg->{'globalAddr'} = $intrRegSpec->{'GlobalAddr'};

    if (defined $intrRegSpec->{'LocalAddr'}) {
      isValidHex($intrRegSpec->{'LocalAddr'}) or
        die "Error: InterruptRegister LocalAddr in SubSystemMMIO ".
            "has to be in hex\n";
      $intr_reg->{'localAddr'} = $intrRegSpec->{'LocalAddr'};
    } else {
      $intr_reg->{'localAddr'} = $intrRegSpec->{'GlobalAddr'};
    }

    if (!defined $subSystemMMIO->{'globalAddr'}) {
      verifyAddressRange($intr_reg->{'globalAddr'}, 4);
    } else {
      ((hex($intr_reg->{'globalAddr'}) >= 
        hex($subSystemMMIO->{'globalAddr'})) and
       ((hex($intr_reg->{'globalAddr'}) + 4) <=
        (hex($subSystemMMIO->{'globalAddr'}) + $subSystemMMIO->{'size'}))) or
      die "Ctrl register at address $intr_reg->{'globalAddr'} " .
          "not in address space of SubSystemMMIO at " .
          "$subSystemMMIO->{'globalAddr'}\n";
    }

    my $interrupt_map = $intrRegSpec->{'InterruptMap'};

    my $bitOffsetToBIntrProcMap = {};
    my $bitOffsetToPIntrProcMap = {};

    # Validate and process the interrupt map definition
    foreach my $imap (@$interrupt_map) {
      ref($imap) eq 'HASH' or 
        die "Error: InterruptMap entry for SubSystemMMIO interrupt register ".
            "at GlobalAddr $intr_reg->{'globalAddr'} expected to be a map\n";

      defined $imap->{'BitOffset'} or 
        die "Error: Bit offset not defined for interrupt register at ".
            "GlobalAddr $intr_reg->{'globalAddr'}\n";
      ($imap->{'BitOffset'} =~ /^\d+$/) or 
        die "Error: Bit offset in interrupt register at GlobalAddr ".
            "$intr_reg->{'globalAddr'} has to be an integer\n";

      ($imap->{'BitOffset'} >= 0 and $imap->{'BitOffset'} < 32) or
        die "Bit offset for interrupt register at GlobalAddr ".
            "$intr_reg->{'globalAddr'} has to be between 0..31\n";

      # Check for unique bit offset to interrupt mapping
      !defined $intr_reg->{'bIntrMap'}{$imap->{'BitOffset'}} or 
        die "Duplicate mapping for bitoffset $imap->{'BitOffset'} in ".
            "interrupt register at GlobalAddr $intr_reg->{'globalAddr'}\n";

      defined $imap->{'BInterrupt'} or 
        die "Error: BInterrupt not defined for interrupt register at ".
            "GlobalAddr $intr_reg->{'globalAddr'}\n";
      ($imap->{'BInterrupt'} =~ /^\d+$/) or 
        die "Error: BInterrupt in interrupt register at GlobalAddr ".
            "$intr_reg->{'globalAddr'} has to be an integer\n";

      if (defined $imap->{'ProcInterrupt'}) {
        ($imap->{'ProcInterrupt'} =~ /^\d+$/) or 
          die "Error: ProcInterrupt in interrupt register at GlobalAddr ".
              "$intr_reg->{'globalAddr'} has to be an integer\n";
      }

      defined $imap->{'Proc'} or 
        die "Error: Proc name not defined for interrupt register at ".
            "GlobalAddr $intr_reg->{'globalAddr'}\n";
      defined $procNameMap->{$imap->{'Proc'}} or
        die "Proc of interrupt register at GlobalAddr ".
            "$intr_reg->{'globalAddr'} $imap->{'Proc'} has to be a ".
            "processor name\n";

      !defined $procNameMap->{$imap->{'Proc'}}->{'mmio'} or
        die "Proc $imap->{'Proc'} cannot have both an local ".
            "MMIO and SubSystemMMIO interrupt\n";

      # Always Edge if not defined
      $intr_reg->{'intrTypeMap'}{$imap->{'BitOffset'}} = 'Edge';
      if (defined $imap->{'Type'}) {
        $imap->{'Type'} eq 'Edge' or $imap->{'Type'} eq 'Level' or
        die "Error: Type of interrupt has to Edge or Level for ".
            "interrupt register at GlobalAddr $intr_reg->{'globalAddr'}\n";
        $intr_reg->{'intrTypeMap'}{$imap->{'BitOffset'}} = $imap->{'Type'};
      }

      # Check for unique BInterrupt to bit offset mapping
      !defined $bitOffsetToBIntrProcMap->{$imap->{'BitOffset'}} or 
        die "Duplicate mapping for BitOffset $imap->{'BitOffset'} in ".
            "interrupt register at GlobalAddr $intr_reg->{'globalAddr'}\n";
      $bitOffsetToBIntrProcMap->{$imap->{'BitOffset'}} = 1;

      # Check for unique ProcInterrupt to bit offset mapping
      if (defined $imap->{'ProcInterrupt'}) {
        !defined $bitOffsetToPIntrProcMap->{$imap->{'BitOffset'}} or 
          die "Duplicate mapping for BitOffset $imap->{'BitOffset'} in ".
              "interrupt register at GlobalAddr $intr_reg->{'globalAddr'}\n";
        $bitOffsetToPIntrProcMap->{$imap->{'BitOffset'}} = 1;
      }

      # Check for unique processor BInterrupt to bit offset mapping
      !defined $procBIntrMap->{$imap->{'Proc'}} or
      !grep { $imap->{'BInterrupt'} eq $_ } 
            @{$procBIntrMap->{$imap->{'Proc'}}} or 
        die "Duplicate BInterrupt $imap->{'BInterrupt'} for Proc ".
            "$imap->{'Proc'} in interrupt register at GlobalAddr ".
            "$intr_reg->{'globalAddr'}\n";

      push @{$procBIntrMap->{$imap->{'Proc'}}}, $imap->{'BInterrupt'};

      # Check for unique processor BInterrupt to bit offset mapping
      # in the global map (across all SubSystemMMIOs)
      !defined $gProcBIntrMap->{$imap->{'Proc'}} or
      !grep { $imap->{'BInterrupt'} eq $_ } 
            @{$gProcBIntrMap->{$imap->{'Proc'}}} or 
        die "Duplicate BInterrupt $imap->{'BInterrupt'} for Proc ".
            "$imap->{'Proc'} in interrupt register at GlobalAddr ".
            "$intr_reg->{'globalAddr'}\n";

      push @{$gProcBIntrMap->{$imap->{'Proc'}}}, $imap->{'BInterrupt'};

      # Check for unique processor Proc interrupt to bit offset mapping
      if (defined $imap->{'ProcInterrupt'}) {
        !defined $procPIntrMap->{$imap->{'Proc'}} or
        !grep { $imap->{'ProcInterrupt'} eq $_ } 
              @{$procPIntrMap->{$imap->{'Proc'}}} or 
        die "Duplicate ProcInterupt $imap->{'ProcInterrupt'} for ".
            "Proc $imap->{'Proc'} in interrupt register at GlobalAddr ".
            "$intr_reg->{'globalAddr'}\n";

        push @{$procPIntrMap->{$imap->{'Proc'}}}, $imap->{'ProcInterrupt'};
      }
      
      $intr_reg->{'bIntrMap'}{$imap->{'BitOffset'}} = $imap->{'BInterrupt'};
      if (defined $imap->{'ProcInterrupt'}) {
        $intr_reg->{'pIntrMap'}{$imap->{'BitOffset'}} = 
                                       $imap->{'ProcInterrupt'};
      }
      $intr_reg->{'procMap'}{$imap->{'BitOffset'}} = $imap->{'Proc'};

      if (defined $imap->{'xipcNotify'}) {
        $imap->{'xipcNotify'} == 1 or 
          die "Error: xipcNotify flag on interrupt register at ".
              "GlobalAddr $intr_reg->{'globalAddr'} needs to be true\n";
        # xipcNotify should only defined for one of the interrupts
        !defined $procXIPCIntrMap->{$imap->{'Proc'}} or
          die "$imap->{'Proc'} already defined as an XIPC/XRP interrupt\n";

        !defined $imap->{'xrpNotify'} or
          die "XIPC and XRP interrupts can be set for the same interrupt\n";

        $intr_reg->{'xipcIntrMap'}{$imap->{'BitOffset'}} = 1;
        $procXIPCIntrMap->{$imap->{'Proc'}} = $imap->{'BInterrupt'};

        # Record the SubSystemMMIO register and the bit offset of the 
        # XIPC interrupt
        push @{$procNameMap->{$imap->{'Proc'}}->{'xipcSubSystemMMIO'}}, 
             $intr_reg;
        push @{$procNameMap->{$imap->{'Proc'}}->{'xipcSubSystemMMIO'}}, 
             $imap->{'BitOffset'};
      }

      if (defined $imap->{'xrpNotify'}) {
        $imap->{'xrpNotify'} == 1 or 
          die "Error: xrpNotify flag on interrupt register at GlobalAddr ".
              "$intr_reg->{'globalAddr'} needs to be true\n";
        # xrpNotify should only defined for one of the interrupts
        !defined $procXRPIntrMap->{$imap->{'Proc'}} or
          die "$imap->{'Proc'} already defined as an XIPC/XRP interrupt\n";
        !defined $imap->{'xipcNotify'} or
          die "XIPC and XRP interrupts can be set for the same interrupt\n";
        $intr_reg->{'xrpIntrMap'}{$imap->{'BitOffset'}} = 1;
        $procXRPIntrMap->{$imap->{'Proc'}} = $imap->{'BInterrupt'};

        # Record the SubSystemMMIO register and the bit offset of the 
        # XRP interrupt
        push @{$procNameMap->{$imap->{'Proc'}}->{'xrpSubSystemMMIO'}}, 
             $intr_reg;
        push @{$procNameMap->{$imap->{'Proc'}}->{'xrpSubSystemMMIO'}}, 
             $imap->{'BitOffset'};
      }
    }
    push @{$subSystemMMIO->{'intrRegs'}}, $intr_reg;
  }

  # Process the Controls
  if (defined $subSystemMMIOComp->{'Controls'}) {
    ref ($subSystemMMIOComp->{'Controls'}) eq 'ARRAY' or
      die "Error. Control specification for SubSystemMMIO has to be a list\n";

    my $controls = $subSystemMMIOComp->{'Controls'};

    my $procControlMap = {};
    my $procAddrMap = {};
    my $l2ControlMap = {};

    my $num = 0;
    foreach my $ctrlSpec (@$controls) {
      ref ($ctrlSpec) eq 'HASH' or
        die "Error. SubSystemMMIO control specification has to be a ".
            "list of maps\n";

      my $ctrl = new ControlReg;

      defined $ctrlSpec->{'ControlMap'} or
      die "Error: ControlMap undefined for SubSystemMMIO control register ".
          "at $ctrlSpec->{'GlobalAddr'}\n";
      ref ($ctrlSpec->{'ControlMap'}) eq 'ARRAY' or
        die "Error. ControlMap specification for SubSystemMMIO ".
            "control register at $ctrlSpec->{'GlobalAddr'} has to be a list\n";
      scalar @{$ctrlSpec->{'ControlMap'}} > 0 
        or die "Error: No controls mapped in SubSystemMMIO control ".
               "register at $ctrlSpec->{'GlobalAddr'}\n";

      defined $ctrlSpec->{'GlobalAddr'} or
        die "Error: GlobalAddr undefined for SubSystemMMIO control register ".
            "in SubSystemMMIO\n";
      isValidHex($ctrlSpec->{'GlobalAddr'}) or
        die "Error: Control register GlobalAddr in SubSystemMMIO ".
            "has to be in hex\n";

      # Check for unique interrupt register address mapping
      !defined $intrCtrlRegAddrMap->{$ctrlSpec->{'GlobalAddr'}} or 
        die "Duplicate mapping for for control register at GlobalAddr ".
            "$ctrlSpec->{'GlobalAddr'}\n";

      $intrCtrlRegAddrMap->{$ctrlSpec->{'GlobalAddr'}} = 1;
      $ctrl->{'globalAddr'} = $ctrlSpec->{'GlobalAddr'};

      if (defined $ctrlSpec->{'LocalAddr'}) {
        isValidHex($ctrlSpec->{'LocalAddr'}) or
          die "Error: Control register LocalAddr in SubSystemMMIO ".
              "has to be in hex\n";
        $ctrl->{'localAddr'} = $ctrlSpec->{'LocalAddr'};
      } else {
        $ctrl->{'localAddr'} = $ctrlSpec->{'GlobalAddr'};
      }

      if (!defined $subSystemMMIO->{'globalAddr'}) {
        verifyAddressRange($ctrl->{'globalAddr'}, 4);
      } else {
        ((hex($ctrl->{'globalAddr'}) >= 
          hex($subSystemMMIO->{'globalAddr'})) and
         ((hex($ctrl->{'globalAddr'}) + 4) <=
          (hex($subSystemMMIO->{'globalAddr'}) + $subSystemMMIO->{'size'}))) or
        die "Ctrl register at address $ctrl->{'globalAddr'} " .
            "not in address space of SubSystemMMIO at " .
            "$subSystemMMIO->{'globalAddr'}\n";
      }

      my $ctrl_map = $ctrlSpec->{'ControlMap'};

      if (defined $ctrlSpec->{'Width'}) {
        ($ctrlSpec->{'Width'} =~ /^\d+$/) or 
          die "Error: Width of SubSystemMMIO control register at GlobalAddr ".
              "$ctrlSpec->{'GlobalAddr'} has to be an integer\n";
        ($ctrlSpec->{'Width'} > 0 and $ctrlSpec->{'Width'} <= 32) or
          die "Width for SubSystemMMIO control register at ".
              "$ctrlSpec->{'GlobalAddr'} between 1..32\n";
        $ctrl->{'width'} = $ctrlSpec->{'Width'};
      } else {
        $ctrl->{'width'} = 1;
      }

      if (defined $ctrlSpec->{'InitValue'}) {
        $ctrl->{'initValue'} = $ctrlSpec->{'InitValue'};
      } else {
        $ctrl->{'initValue'} = 0;
      }

      $ctrl->{'initValue'} <= 2**$ctrl->{'width'}-1 or 
        die "Error: InitValue $ctrl->{'initValue'} of SubSystemMMIO ".
            "control register at GlobalAddr $ctrlSpec->{'GlobalAddr'} ".
            "has to be <= ".(2**$ctrl->{'width'}-1).
            " for Width $ctrl->{'width'}\n";

      if (defined $ctrlSpec->{'ReadOnly'}) {
        $ctrlSpec->{'ReadOnly'} == 1 or 
          die "Error: ReadOnly flag needs to be true\n";
        $ctrl->{'readOnly'} = 1;
      } else {
        $ctrl->{'readOnly'} = 0;
      }
    
      foreach my $cmap (@$ctrl_map) {
        my $ctrl_sreg = new ControlSubReg;

        ref($cmap) eq 'HASH' or 
          die "Error: ControlMap entry for SubSystemMMIO register at ".
              "GlobalAddr $ctrl->{'globalAddr'} expected to be a map\n";

        if (defined $cmap->{'BitOffsetStart'}) {
          ($cmap->{'BitOffsetStart'} =~ /^\d+$/) or 
          die "Error: Bit start offset in SubSystemMMIO register at ".
              "GlobalAddr $ctrl->{'globalAddr'} has to be an integer\n";
        } else {
          $cmap->{'BitOffsetStart'} = 0;
        }
        if (defined $cmap->{'BitOffsetEnd'}) {
          ($cmap->{'BitOffsetEnd'} =~ /^\d+$/) or 
            die "Error: Bit end offset in SubSystemMMIO register at ".
                "GlobalAddr $ctrl->{'globalAddr'} has to be an integer\n";
        } else {
          $cmap->{'BitOffsetEnd'} = 0;
        }

        # If Proc is defined, check for control map
        if (defined $cmap->{'Proc'}) {
          my $proc = $cmap->{'Proc'};
          defined $procNameMap->{$proc} or
            die "Proc of SubSystemMMIO register at GlobalAddr ".
                "$ctrl->{'globalAddr'} $proc has to be a processor name\n";
          !defined $procNameMap->{$proc}->{'mmio'} or
            die "Proc $proc cannot have both an local MMIO and ".
                "SubSystemMMIO control\n";

          # Check for unique processor control 
          !defined $procControlMap->{$proc} or
          !grep { $cmap->{'Name'} eq $_ } @{$procControlMap->{$proc}} or
            die "Duplicate control $cmap->{'Name'} for Proc $proc in ".
                "control register at GlobalAddr $ctrl->{'globalAddr'}\n";

          push @{$procControlMap->{$proc}}, $cmap->{'Name'};

          # Check for unique processor control across all SubSystemMMIOs
          !defined $gProcControlMap->{$proc} or
          !grep { $cmap->{'Name'} eq $_ } @{$gProcControlMap->{$proc}} or
            die "Duplicate control $cmap->{'Name'} for Proc $proc in ".
                "control register at GlobalAddr $ctrl->{'globalAddr'}\n";

          push @{$gProcControlMap->{$proc}}, $cmap->{'Name'};

          $ctrl_sreg->{'comp'} = $proc;
        }

        if (defined $cmap->{'L2'}) {
          my $l2 = $cmap->{'L2'};
          defined $subSystemL2s->{$l2} or
            die "$l2 of SubSystemMMIO register at GlobalAddr ".
                "$ctrl->{'globalAddr'} is not a L2 name\n";

          # Check for unique processor control 
          !defined $l2ControlMap->{$l2} or
          !grep { $cmap->{'Name'} eq $_ } @{$l2ControlMap->{$l2}} or
            die "Duplicate control $cmap->{'Name'} for L2 $l2 in ".
                "control register at GlobalAddr $ctrl->{'globalAddr'}\n";

          push @{$l2ControlMap->{$l2}}, $cmap->{'Name'};

          # Check for unique L2 control across all SubSystemMMIOs
          !defined $gProcControlMap->{$l2} or
          !grep { $cmap->{'Name'} eq $_ } @{$gProcControlMap->{$l2}} or
            die "Duplicate control $cmap->{'Name'} for L2 $l2 in ".
                "control register at GlobalAddr $ctrl->{'globalAddr'}\n";

          push @{$gProcControlMap->{$l2}}, $cmap->{'Name'};

          $ctrl_sreg->{'comp'} = $l2;
        }

        if (defined $cmap->{'Dir'}) {
          $cmap->{'Dir'} eq 'in' or $cmap->{'Dir'} eq 'out' or 
            die "Direction for control $cmap->{'Name'} has to be ".
                "'in' or 'out'\n";
          $cmap->{'Dir'} eq 'out' or !$ctrl->{'readOnly'} or 
            die "Cannot have 'in' $cmap->{'Name'} for read only control ".
                "register at GlobalAddr $ctrl->{'globalAddr'}\n";
          $ctrl_sreg->{'dir'} = $cmap->{'Dir'};
        } else {
          $ctrl_sreg->{'dir'} = 'out';
        }

        $cmap->{'BitOffsetStart'} <= $cmap->{'BitOffsetEnd'} or
          die "Bit offset start of control $cmap->{'Name'} should be ".
              "less than bit offset end of the control register at ".
              "GlobalAddr $ctrl->{'globalAddr'}\n";

        $cmap->{'BitOffsetEnd'} < $ctrl->{'width'} or
          die "Bit offset end of control $cmap->{'Name'} should be less ".
              "than width ($ctrl->{'width'}) of the control register at ".
              "GlobalAddr $ctrl->{'globalAddr'}\n";

        # For Dir==in, the bitStart/bitEnd should not overlap
        foreach my $reg (@{$ctrl->{'subRegs'}}) {
          if (($reg->{'dir'} eq 'in') or ($ctrl_sreg->{'dir'} eq 'in')) {
            (($cmap->{'BitOffsetStart'} < $reg->{'bitStart'}) and
             ($cmap->{'BitOffsetEnd'} < $reg->{'bitEnd'})) or
            (($cmap->{'BitOffsetStart'} > $reg->{'bitStart'}) and
             ($cmap->{'BitOffsetEnd'} > $reg->{'bitEnd'})) or
            die "Bitoffset overlap for control $cmap->{'Name'} at ".
                "GlobalAddr $ctrl->{'globalAddr'}\n";
          }
        }

        $ctrl_sreg->{'name'} = $cmap->{'Name'};
        $ctrl_sreg->{'bitStart'} = $cmap->{'BitOffsetStart'};
        $ctrl_sreg->{'bitEnd'} = $cmap->{'BitOffsetEnd'};

        push @{$ctrl->{'subRegs'}}, $ctrl_sreg;
      }
      push @{$subSystemMMIO->{'controlRegs'}}, $ctrl;
    }
  }
}

# Process the list SubSystemMMIOs
sub processSubSystemMMIOs {
  my $subSys = shift;

  if (!defined $subSys->{'SubSystemMMIO'}) {
    return;
  }

  my $subSystemMMIOs = $subSys->{'SubSystemMMIO'};
  ref($subSystemMMIOs) eq 'ARRAY' or 
    die "Error : SubSystemMMIO definitions needs to be an array\n";

  foreach my $smmio (@$subSystemMMIOs) {
    ref($smmio) eq 'HASH' or
      die "Error: SubSystemMMIO component specification needs to be a map\n";
    processSubSystemMMIO($smmio);
  }
}

# Process SubSystemIO
sub processSubSystemIOs {
  my $subSys = shift;
  
  if (!defined $subSys->{'SubSystemIO'}) {
    return;
  }

  my $subSystemIOs = $subSys->{'SubSystemIO'};
  ref($subSystemIOs) eq 'ARRAY' or
    die "Error : SubSystemIO definitions needs to be an array\n";

  my $subSysIOMap = {};

  foreach my $sio (@$subSystemIOs) {
    ref($sio) eq 'HASH' or
      die "Error: SubSystemIO component specification needs to be a map\n";
    processSubSystemIO($sio, $subSysIOMap);
  }
}
  
# SystemDMA
sub processSystemDMA {
  my $subSys = shift;

  if (!defined $subSys->{'SystemDMA'}) {
    return;
  }

  my $sysDMA = $subSys->{'SystemDMA'};

  pushCurrentLogLevel($logDebugLevel1);

  printLog($logDebugLevel2, "In processSystemDMA()\n");

  ref($sysDMA) eq 'HASH' or 
      die "Error: System DMA specification has to be a map\n";

  $SystemDMA = new SystemDMA;
  if (defined $sysDMA->{'NumRequests'}) {  
    ($sysDMA->{'NumRequests'} =~ /^\d+$/) or
      die "Error: SystemDMA NumRequests has to be an integer\n";
    $SystemDMA->{'numRequests'} = $sysDMA->{'NumRequests'};
  } else {
    $SystemDMA->{'numRequests'} = 16;
  }

  if (defined $sysDMA->{'NumChannels'}) {  
    ($sysDMA->{'NumChannels'} =~ /^\d+$/) or
      die "Error: SystemDMA NumChannels has to be an integer\n";
    $SystemDMA->{'numChannels'} = $sysDMA->{'NumChannels'};
  } else {
    $SystemDMA->{'numChannels'} = 1;
  }

  defined $sysDMA->{'BaseAddr'} or 
    die "Error: SystemDMA $sysDMA->{'Name'}'s BaseAddr undefined\n";

  isValidHex($sysDMA->{'BaseAddr'}) or
    die "Error: SystemDMA $sysDMA->{'Name'}'s has to be in hex\n";

  # 8Kb address range reserved for xtsc_dma registers per channel
  $SystemDMA->{'baseAddr'} = $sysDMA->{'BaseAddr'};
  $SystemDMA->{'size'} = 256*256*$SystemDMA->{'numChannels'};

  verifyAddressRange($SystemDMA->{'baseAddr'}, $SystemDMA->{'size'});
}

# Interfaces
sub processSubSystemInterface {
  my $subSys = shift;
  if (!defined $subSys->{'SubSystemExternalInterfaces'}) {
    # No interface spec. Create a single interface with a dedicated port 
    # for each proc/xnne in the subsystem
    my @restProcs = ();
    my @restXnnes = ();
    my $numPorts = 0;
    foreach my $proc (values %$procIdMap) {
      # Check for connectivity to/from bus
      if ((grep { $_ eq $proc->{'id'} } 
           @{$subSysInterconnectFrom->{$COMMON_BUS_ID}}) or
          (grep { $_ eq $proc->{'id'} } 
           @{$subSysInterconnectTo->{$COMMON_BUS_ID}})) {
        $proc->{'extIntfId'} = 0;
        # Ports exists if there is connectivity to bus
        if (grep { $_ eq $proc->{'id'} } 
            @{$subSysInterconnectFrom->{$COMMON_BUS_ID}}) {
          $numPorts++;
        }
        push @restProcs, $proc->{'id'};
      }
    }
    # Add the XNNEs to the interface
    foreach my $xnne (values %$xnneIdMap) {
      $xnne->{'extIntfId'} = 0;
      foreach my $mw (@{$xnne->{'masterCompMap'}->{$COMMON_BUS_ID}}) {
        $numPorts++;
      }
      push @restXnnes, $xnne->{'id'};
    }
    if (scalar @restProcs) {
      my $subSystemExternalInterface = new SubSystemExternalInterface;
      $subSystemExternalInterface->{'numPorts'} = $numPorts;
      @{$subSystemExternalInterface->{'procs'}} = @restProcs;
      @{$subSystemExternalInterface->{'xnnes'}} = @restXnnes;
      $subSystemExternalInterface->{'id'} = 0;
      push @subSystemExternalInterfaces, $subSystemExternalInterface;
    }
  } else {
    # Requires a list of interfaces
    ref ($subSys->{'SubSystemExternalInterfaces'}) eq 'ARRAY' or 
      die "SubSystemExternalInterfaces has to be a list\n";
    # Unique id per interface
    my $id = 0;
    foreach my $extIntf (@{$subSys->{'SubSystemExternalInterfaces'}}) {
      defined $extIntf->{'NumPorts'} or 
        die "SubSystemExternalInterface interface needs NumPorts ",
            "to be specified\n";
      my $subSystemExternalInterface = new SubSystemExternalInterface;

      # NumPorts is always required
      $subSystemExternalInterface->{'numPorts'} = $extIntf->{'NumPorts'};
      ($extIntf->{'NumPorts'} =~ /^\d+$/) or
        die "SubSystemExternalInterface NumPorts has to be an integer\n";

      my $corePorts = 0;

      if (defined $extIntf->{'Procs'}) {
        # Process the list of procs connected to this interface
        my $procs1 = $extIntf->{'Procs'};
        ref($procs1) eq 'ARRAY' or 
          die "SubSystemExternalInterface Procs needs to be a list\n";

        foreach my $p (@$procs1) {
          defined $procNameMap->{$p} or 
            die "SubSystemExternalInterface has unknown proc $p\n";

          $procNameMap->{$p}->{'extIntfId'} == -1 or
            die "Proc $p already part of SubSystemExternalInterface ",
                "$procNameMap->{$p}->{'extIntfId'}\n";

          # Proc needs connectivity to Bus
          grep { $_ eq $procNameMap->{$p}->{'id'} } 
               @{$subSysInterconnectFrom->{$COMMON_BUS_ID}} or
            die "Proc $p in SubSystemExternalInterface does not have ",
                "a connection to the Bus\n";

          $procNameMap->{$p}->{'extIntfId'} = $id;
          push @{$subSystemExternalInterface->{'procs'}}, 
               $procNameMap->{$p}->{'id'};

          $corePorts++;
        }
      } else {
        # No proc spec. Create a single interface with a dedicated port for
        # each proc in the subsystem
        my @restProcs;
        foreach my $pid (keys %$procIdMap) {
          $procIdMap->{$pid}->{'extIntfId'} == -1 or
            die "Proc $procIdMap->{$pid}->{'name'} ",
                " already part of SubSystemExternalInterface ",
                "$procIdMap->{$pid}->{'extIntfId'}\n";

          # Check for connectivity to/from bus
          if ((grep { $_ eq $pid } 
               @{$subSysInterconnectFrom->{$COMMON_BUS_ID}}) or
              (grep { $_ eq $pid } 
               @{$subSysInterconnectTo->{$COMMON_BUS_ID}})) {
            $procIdMap->{$pid}->{'extIntfId'} = $id;
            # Ports exists if there is connectivity to bus
            if (grep { $_ eq $pid } 
                @{$subSysInterconnectFrom->{$COMMON_BUS_ID}}) {
              $corePorts++;
            }
            push @restProcs, $pid;
          }
        }
        if (scalar @restProcs) {
          @{$subSystemExternalInterface->{'procs'}} = @restProcs;
        }
      }

      # Add the XNNEs
      my $xnnePorts = 0;

      if (defined $extIntf->{'XNNEs'}) {
        # Process the list of xnnes connected to this interface
        my $xnnes1 = $extIntf->{'XNNEs'};
        ref($xnnes1) eq 'ARRAY' or 
          die "SubSystemExternalInterface XNNEs needs to be a list\n";

        foreach my $x (@$xnnes1) {
          defined $xnneNameMap->{$x} or 
            die "SubSystemExternalInterface has unknown XNNE $x\n";

          $xnneNameMap->{$x}->{'extIntfId'} == -1 or
            die "XNNE $x already part of SubSystemExternalInterface ",
                "$xnneNameMap->{$x}->{'extIntfId'}\n";

          # XNNE needs connectivity to Bus
          grep { $_ eq $xnneNameMap->{$x}->{'id'} } 
               @{$subSysInterconnectFrom->{$COMMON_BUS_ID}} or
            die "XNNE $x in SubSystemExternalInterface does not have ",
                "a connection to the Bus\n";

          $xnneNameMap->{$x}->{'extIntfId'} = $id;
          push @{$subSystemExternalInterface->{'xnnes'}}, 
               $xnneNameMap->{$x}->{'id'};

          # XNNE can have multiple master ports
          $xnnePorts += 
            (scalar @{$xnneNameMap->{$x}->{'masterCompMap'}->{$COMMON_BUS_ID}});
        }
      } else {
        # No XNNE spec. Create a single interface with a dedicated port for
        # each xnne in the subsystem
        my @restXnnes;
        foreach my $xid (keys %$xnneIdMap) {
          $xnneIdMap->{$xid}->{'extIntfId'} == -1 or
            die "XNNE $xnneIdMap->{$xid}->{'name'} ",
                " already part of SubSystemExternalInterface ",
                "$xnneIdMap->{$xid}->{'extIntfId'}\n";

          # XNNE needs connectivity to Bus
          grep { $_ eq $xid } 
               @{$subSysInterconnectFrom->{$COMMON_BUS_ID}} or
            die "XNNE $xnneIdMap->{$xid}->{'name'} ",
                "in SubSystemExternalInterface does not have ",
                "a connection to the Bus\n";

          $xnneIdMap->{$xid}->{'extIntfId'} = $id;
          push @restXnnes, $xid;

          # XNNE can have multiple master ports
          $xnnePorts += 
            (scalar @{$xnneIdMap->{$xid}->{'masterCompMap'}->{$COMMON_BUS_ID}});
        }

        if (scalar @restXnnes) {
          @{$subSystemExternalInterface->{'xnnes'}} = @restXnnes;
        }
      }

      # Verify
      $extIntf->{'NumPorts'} > 0 and 
      $extIntf->{'NumPorts'} <= ($corePorts + $xnnePorts) or
        die "SubSystemExternalInterface NumPorts has to be > 0 and <= ".
            ($corePorts + $xnnePorts)."\n";

      # ROB spec
      if (defined $extIntf->{'ROB'}) {
        ref ($extIntf->{'ROB'}) eq 'HASH' or die "ROB has to be a map\n";
        $subSysMasterProc->{'axi'} == 1 or die "ROB requires AXI cores\n";

        my $rob = new ROB;

        # Requires NumEntries
        defined $extIntf->{'ROB'}->{'NumEntries'}
          or die "ROB needs number of entries to be specified\n";
        ($extIntf->{'ROB'}->{'NumEntries'} =~ /^\d+$/) or
          die "Error: ROB number of entries has to be an integer\n";

        $rob->{'numEntries'} = $extIntf->{'ROB'}->{'NumEntries'};

        $subSystemExternalInterface->{'rob'} = $rob;
      }

      $subSystemExternalInterface->{'id'} = $id;
      push @subSystemExternalInterfaces, $subSystemExternalInterface;
      $id++;
    }

    # Any other proc in the subsystem not explicitly listed in the 
    # SubSystemExternalInterface spec is assigned to a single interface 
    # with a dedicated port per proc.
    my @restProcs = ();
    my $numPorts = 0;
    foreach my $proc (values %$procIdMap) {
      # Check for connectivity to/from bus
      if ($proc->{'extIntfId'} == -1 and
          ((grep { $_ eq $proc->{'id'} } 
            @{$subSysInterconnectFrom->{$COMMON_BUS_ID}}) or
           (grep { $_ eq $proc->{'id'} } 
            @{$subSysInterconnectTo->{$COMMON_BUS_ID}}))) {
        $proc->{'extIntfId'} = $id;
        # Ports exists if there is connectivity to bus
        if (grep { $_ eq $proc->{'id'} } 
            @{$subSysInterconnectFrom->{$COMMON_BUS_ID}}) {
          $numPorts++;
        }
        push @restProcs, $proc->{'id'};
      }
    }
    if (scalar @restProcs) {
      my $subSystemExternalInterface = new SubSystemExternalInterface;
      $subSystemExternalInterface->{'numPorts'} = $numPorts;
      @{$subSystemExternalInterface->{'procs'}} = @restProcs;
      $subSystemExternalInterface->{'id'} = $id;
      push @subSystemExternalInterfaces, $subSystemExternalInterface;
      $id++;
    }
  }
}

# L2
sub processL2 {
  my $L2Comp = shift;

  pushCurrentLogLevel($logDebugLevel1);

  printLog($logDebugLevel2, "In processL2()\n");

  ref ($L2Comp) eq 'HASH' or die "Error: L2 specification has to be a map\n";

  my $L2 = new L2;

  # Assign a unique component Id
  $L2->{'id'} = getNewComponentID();

  # Verify the components
  defined $L2Comp->{'Name'} or die "L2 needs a name\n";

  ($L2Comp->{'Name'} =~ /^[a-zA-Z][a-zA-Z0-9_]+$/) or 
    die "Error: L2 name has to be a alpha numerical ".
        "(underscores allowed) beginning with a letter \n";

  !defined $subSystemL2s->{$L2Comp->{'Name'}} or
    die "L2 $L2Comp->{'Name'} already defined\n";

  $L2->{'name'} = $L2Comp->{'Name'};

  $subSystemL2s->{$L2->{'name'}} = $L2;
  $subSystemL2Ids->{$L2->{'id'}} = $L2;

  defined $L2Comp->{'RAMGlobalAddr'} or 
    die "Error: L2 RAMGlobalAddr undefined\n";

  isValidHex($L2Comp->{'RAMGlobalAddr'}) or
    die "Error: L2 RAMGlobalAddr has to be in hex\n";

  defined $L2Comp->{'Size'} or die "Error: L2 Size undefined\n";

  verifyAddressRange($L2Comp->{'RAMGlobalAddr'}, $L2Comp->{'Size'});

  $L2->{'size'} = computeSize($L2Comp->{'Size'});
  if (defined $L2Comp->{'RAMAddr'}) {
    $L2->{'localAddr'} = $L2Comp->{'RAMAddr'};
  } else {
    $L2->{'localAddr'} = $L2Comp->{'RAMGlobalAddr'};
  }
  $L2->{'globalAddr'} = $L2Comp->{'RAMGlobalAddr'};

  if (defined $L2Comp->{'HostShared'}) {
    ($L2Comp->{'HostShared'} == 1) or
      die "Error: HostShared flag on L2 needs to be true\n";
    $L2->{'host_shared'} = 1;
  } else {
    $L2->{'host_shared'} = 0;
  }

  if (defined $L2Comp->{'NumBanks'}) {
    # L2RAM specification
    ($L2Comp->{'NumBanks'} =~ /^\d+$/) or  
      die "Expected L2 num banks to be a number\n";
    $L2->{'numBanks'} = $L2Comp->{'NumBanks'};
    $L2->{'isL2CC'} = 0;
    $L2->{'numBanks'} > 0 and 
      (($L2->{'numBanks'} & ($L2->{'numBanks'}-1)) == 0) or
      die "Number of banks of L2 has to be a power of 2\n";
    
    if (defined $L2Comp->{'NumPorts'}) {
      ($L2Comp->{'NumPorts'} =~ /^\d+$/) or  
        die "Expected L2 num ports to be a number\n";
      $L2Comp->{'NumPorts'} > 0 or
        die "Number of ports has to be > 0\n";
      $L2->{'numPorts'} = $L2Comp->{'NumPorts'};
      $L2->{'numBanks'} == 1 or 
        die "NumPorts specification for L2 requires number of banks to be 1\n";
    }

    if (defined $L2Comp->{'NumCorePorts'}) {
      ($L2Comp->{'NumCorePorts'} =~ /^\d+$/) or  
        die "Expected L2 num core ports to be a number\n";
      $L2Comp->{'NumCorePorts'} > 0 or
        die "Number of core ports has to be > 0\n";
      $L2->{'numCorePorts'} = $L2Comp->{'NumCorePorts'};
      $L2->{'numBanks'} == 1 or die "NumCorePorts specification for L2 ".
                                    "requires number of banks to be 1\n";
    }

    if (defined $L2Comp->{'Interleave'}) {
      $L2Comp->{'Interleave'} eq 'Low' or $L2Comp->{'Interleave'} eq 'High' or
        die "Interleave order of L2 has to be Low or High\n";
      $L2->{'interleave'} = $L2Comp->{'Interleave'};
    } else {
      $L2->{'interleave'} = 'High';
    }

    if (defined $L2Comp->{'ReadDelay'}) {
      ($L2Comp->{'ReadDelay'} =~ /^\d+$/) or
      die "Error: L2 ReadDelay has to be an integer\n";
    }

    if (defined $L2Comp->{'ReadRepeat'}) {
      ($L2Comp->{'ReadRepeat'} =~ /^\d+$/) or
      die "Error: L2 ReadRepeat has to be an integer\n";
    }

    if (defined $L2Comp->{'WriteDelay'}) {
      ($L2Comp->{'WriteDelay'} =~ /^\d+$/) or
      die "Error: L2 WriteDelay has to be an integer\n";
    }

    if (defined $L2Comp->{'WriteRepeat'}) {
      ($L2Comp->{'WriteRepeat'} =~ /^\d+$/) or
      die "Error: L2 WriteRepeat has to be an integer\n";
    }

    if (defined $L2Comp->{'WriteResponse'}) {
      ($L2Comp->{'WriteResponse'} =~ /^\d+$/) or
      die "Error: L2 WriteResponse has to be an integer\n";
    }

    if (defined $L2Comp->{'RequestFIFODepth'}) {
      ($L2Comp->{'RequestFIFODepth'} =~ /^\d+$/) or
      die "Error: L2 RequestFIFODepth has to be an integer\n";
    }

    if (!defined $L2Comp->{'ReadDelay'}) {
      $L2->{'read_delay'} = 1;
    } else {
      $L2->{'read_delay'} = $L2Comp->{'ReadDelay'};
    }

    if (!defined $L2Comp->{'WriteDelay'}) {
      $L2->{'write_delay'} = 1;
    } else {
      $L2->{'write_delay'} = $L2Comp->{'WriteDelay'};
    }

    if (!defined $L2Comp->{'ReadRepeat'}) {
      $L2->{'read_repeat'} = 1;
    } else {
      $L2->{'read_repeat'} = $L2Comp->{'ReadRepeat'};
    }

    if (!defined $L2Comp->{'WriteRepeat'}) {
      $L2->{'write_repeat'} = 1;
    } else {
      $L2->{'write_repeat'} = $L2Comp->{'WriteRepeat'};
    }

    if (!defined $L2Comp->{'WriteResponse'}) {
      $L2->{'write_response'} = 1;
    } else {
      $L2->{'write_response'} = $L2Comp->{'WriteResponse'};
    }
  
    if (!defined $L2Comp->{'RequestFIFODepth'}) {
      $L2->{'request_fifo_depth'} = 2;
    } else {
      $L2->{'request_fifo_depth'} = $L2Comp->{'RequestFIFODepth'};
    }

    defined $L2Comp->{'Width'} or die "Error: L2 Width undefined\n";
    $L2->{'dataWidth'} = computeSize($L2Comp->{'Width'});

    (!defined $L2Comp->{'ControlRegGlobalAddr'} and 
     !defined $L2Comp->{'DataWidth'} and 
     !defined $L2Comp->{'InstWidth'} and 
     !defined $L2Comp->{'MasterWidth'} and 
     !defined $L2Comp->{'SlaveWidth'} and 
     !defined $L2Comp->{'Coherent'}) or
      die "L2 RAM specification cannot include L2 CC components ".
          "such as ControlRegGlobalAddr, Data/InstWidth, Master/SlaveWidth, ".
          "Coherent\n";

    # If ports/banks are defined, ignore rest of the fields that are specific
    # to the L2 cc model
    return;
  }

  # For L2CC

  $subSysMasterProc->{'axi'} or die "L2 CC supported only for NX pipelines\n";

  $L2->{'isL2CC'} = 1;

  if (!defined $L2Comp->{'ControlRegGlobalAddr'} and
      !defined $L2Comp->{'ControlRegAddr'}) {
    die "Error: L2 ControlRegAddr undefined\n";
  }

  !defined $L2Comp->{'ControlRegGlobalAddr'} or
  isValidHex($L2Comp->{'ControlRegGlobalAddr'}) or
    die "Error: L2 ControlRegGlobalAddr has to be in hex\n";

  !defined $L2Comp->{'ControlRegAddr'} or
  isValidHex($L2Comp->{'ControlRegAddr'}) or
    die "Error: L2 ControlRegAddr has to be in hex\n";

  defined $L2Comp->{'DataWidth'} or die "Error: L2 DataWidth undefined\n";
  defined $L2Comp->{'InstWidth'} or die "Error: L2 InstWidth undefined\n";
  defined $L2Comp->{'MasterWidth'} or die "Error: L2 MasterWidth undefined\n";
  defined $L2Comp->{'SlaveWidth'} or die "Error: L2 SlaveWidth undefined\n";

  $L2->{'controlRegAddr'} = defined $L2Comp->{'ControlRegGlobalAddr'}
                              ? $L2Comp->{'ControlRegGlobalAddr'}
                              : $L2Comp->{'ControlRegAddr'};
  $L2->{'dataWidth'} = computeSize($L2Comp->{'DataWidth'});
  $L2->{'instWidth'} = computeSize($L2Comp->{'InstWidth'});
  $L2->{'masterWidth'} = computeSize($L2Comp->{'MasterWidth'});
  $L2->{'slaveWidth'} = computeSize($L2Comp->{'SlaveWidth'});
  if (defined $L2Comp->{'DmaWidth'}) {
    $L2->{'dmaWidth'} = computeSize($L2Comp->{'DMAWidth'});
  }
  if (defined $L2Comp->{'LineSize'}) {
    $L2->{'lineSize'} = computeSize($L2Comp->{'LineSize'});
  }
  if (defined $L2Comp->{'NumWays'}) {
    $L2->{'numWays'} = computeSize($L2Comp->{'NumWays'});
  }
  if (defined $L2Comp->{'Coherent'}) {
    ($L2Comp->{'Coherent'} == 0 || $L2Comp->{'Coherent'} == 1) or 
      die "Error: Coherent flag on L2 needs to be true/false\n";
    $L2->{'coherent'} = $L2Comp->{'Coherent'};
  } else {
    $L2->{'coherent'} = 0;
  }
  if (defined $L2Comp->{'RamOnly'}) {
    $L2->{'coherent'} == 0 or die "Error: L2 RamOnly cannot be coherent\n";
    ($L2Comp->{'RamOnly'} == 0 || $L2Comp->{'RamOnly'} == 1) or
      die "Error: RamOnly flag on L2 needs to be true/false\n";
    $L2->{'ramOnly'} = $L2Comp->{'RamOnly'};
  } else {
    $L2->{'ramOnly'} = 0;
  }

  if (defined $L2Comp->{'NumSlavePorts'}) {
    ($L2Comp->{'NumSlavePorts'} =~ /^\d+$/) or  
      die "Expected L2CC slave ports to be a number\n";
    $L2Comp->{'NumSlavePorts'} > 0 or
      die "Number of L2CC slave ports has to be > 0\n";
    $L2->{'numPorts'} = $L2Comp->{'NumSlavePorts'};
  } else {
    $L2->{'numPorts'} = 1;
  }

  if (defined $L2Comp->{'NumCorePorts'}) {
    ($L2Comp->{'NumCorePorts'} =~ /^\d+$/) or  
      die "Expected L2 num core ports to be a number\n";
    $L2->{'numCorePorts'} = $L2Comp->{'NumCorePorts'};
  } else {
    $L2->{'numCorePorts'} = 0;
  }

  if (defined $L2Comp->{'NumExclusives'}) {
    ($L2Comp->{'NumExclusives'} =~ /^\d+$/) or  
      die "Expected L2 num exclusives has to be a number\n";
    $L2->{'numExclusives'} = $L2Comp->{'NumExclusives'};
  } 

  if (defined $L2Comp->{'CacheLineSize'}) {
    ($L2Comp->{'CacheLineSize'} =~ /^\d+$/) or  
      die "Expected CacheLineSize to be a number\n";
    $L2->{'cacheLineSize'} = computeSize($L2Comp->{'CacheLineSize'});
  }
    
  return $L2;
}

# Process all L2s in the subsystem
sub processL2s {
  my $subSys = shift;

  if (!defined $subSys->{'L2'}) {
    return;

  }
  my $L2s = $subSys->{'L2'};
  ref($L2s) eq 'ARRAY' or die "Error : L2 definitions needs to be an array\n";

  foreach my $L2Comp (@$L2s) {
    ref($L2Comp) eq 'HASH' or
      die "Error: L2 component specification needs to be a map\n";
    processL2($L2Comp);
  }
}

# Generate XIPC software layer
sub processSystemSoftware {
  my $subSys = shift;

  pushCurrentLogLevel($logDebugLevel1);

  printLog($logDebugLevel2, "In processSystemSoftware()\n");

  if (!defined $subSys->{'SubSystemSoftware'}) {
    $subSystemSoftware->{'xipcSharedDataBuffer'} = '0x0';
    $subSystemSoftware->{'xipcMsgChannelDefaultNumMsgs'} = 8;
    $subSystemSoftware->{'xipcMasterProc'} = $subSysMasterProc->{'id'};
    return;
  }

  ref ($subSys->{'SubSystemSoftware'}) eq 'HASH' or 
    die "Error: SubSystemSoftware specification has to be a map\n";

  my $subSysSW = $subSys->{'SubSystemSoftware'};
  
  if (defined $subSysSW->{'XIPCSharedDataBuffer'}) {
    $subSystemSoftware->{'xipcSharedDataBuffer'} = 
                        $subSysSW->{'XIPCSharedDataBuffer'};
  } else {
    $subSystemSoftware->{'xipcSharedDataBuffer'} = '0x0';
  }

  if (defined $subSysSW->{'XRPDeviceTreeSpec'}) {
    processXRPDeviceTreeSpec($subSysSW->{'XRPDeviceTreeSpec'});
  }

  if (defined $subSysSW->{'XIPCProcs'}) {
    my $procs = $subSysSW->{'XIPCProcs'};
    ref($procs) eq 'ARRAY' or die "Error : XIPCProcs needs to be an array\n";
    foreach my $proc (@$procs) {
      defined $procNameMap->{$proc} or
        die "XIPCProcs component $proc has to be a processor name\n";
      push @{$subSystemSoftware->{'xipcProcs'}}, $procNameMap->{$proc}->{'id'};
    }
  }

  if (defined $subSysSW->{'XIPCMasterProc'}) {
    my $proc = $subSysSW->{'XIPCMasterProc'};
      defined $procNameMap->{$proc} or
        die "XIPCMasterProc $proc has to be a processor name\n";
    $subSystemSoftware->{'xipcMasterProc'} = $procNameMap->{$proc}->{'id'};
  } else {
    $subSystemSoftware->{'xipcMasterProc'} = $subSysMasterProc->{'id'};
  }

  my $xipcProcList;
  if (defined $subSystemSoftware->{'xipcProcs'}) {
    @$xipcProcList = @{$subSystemSoftware->{'xipcProcs'}};
  } else {
    @$xipcProcList = keys %$procIdMap;
  }


  grep { $_ eq $subSystemSoftware->{'xipcMasterProc'} } @$xipcProcList  or
    die "xipcMasterProc ".
        "$procIdMap->{$subSystemSoftware->{'xipcMasterProc'}}->{'name'} ".
        "should be one of ".join(", ", map ({$procIdMap->{$_}->{'name'} } 
                                            @$xipcProcList))."\n";
  
  my $prev_pid = -1;
  foreach my $pid (sort {$a<=>$b} @$xipcProcList) {
    if ($prev_pid != -1) {
      $pid == ($prev_pid + 1) or 
        die "Processor ids in  xipcProc list @$xipcProcList ".
            "has to be contiguous\n";
    }
    if ($prev_pid == -1) {
      $pid == $subSystemSoftware->{'xipcMasterProc'} or 
        die "XIPC master proc $subSystemSoftware->{'xipcMasterProc'} has ".
            "to be the lowest numbered proc in xipcProc list @$xipcProcList\n";
    }
    $prev_pid = $pid;
  }

  if (defined $subSysSW->{'XIPCMsgChannelDefaultNumMsgs'}) {
    ($subSysSW->{'XIPCMsgChannelDefaultNumMsgs'} =~ /^\d+$/) or 
      die "Error: XIPCMsgChannelDefaultNumMsgs has to be an integer\n";
    int($subSysSW->{'XIPCMsgChannelDefaultNumMsgs'}) >= 2 
      or die "XIPCMsgChannelDefaultNumMsgs has to be >= 2\n";
    $subSystemSoftware->{'xipcMsgChannelDefaultNumMsgs'} =
                        $subSysSW->{'XIPCMsgChannelDefaultNumMsgs'};
  } else {
    $subSystemSoftware->{'xipcMsgChannelDefaultNumMsgs'} = 8;
  }

  printLog($logDebugLevel2, "Leaving processSystemSoftware()\n");

  popCurrentLogLevel;
}

# Generate XRP DTS
sub generateXRPDeviceTreeSpec {
  my $xrp_gen_dir = shift;

  if (!defined $xrpDTS) {
    return;
  }

  my $xrp_dts = "$xrp_gen_dir/$subSystemName.dts";

  if (-d $xrp_gen_dir) {
    rmtree($xrp_gen_dir);
    $? == 0 or sysBuildError("Cannot delete $xrp_gen_dir\n");
  }
  mkpath($xrp_gen_dir);
  $? == 0 || die sysBuildError("Cannot create $xrp_gen_dir\n");

  open(xrp_dts, ">$xrp_dts") or sysBuildError("Could not open $xrp_dts\n");

  my $header = <<'END_HEADER';
/dts-v1/;

/ {
  compatible = "cdns,xtensa-iss";
  #address-cells = <1>;
  #size-cells = <1>;
  interrupt-parent = <&pic>;

  chosen {
    bootargs = "console=ttyS0,115200n8 debug eth0=tuntap,,tap9 root=/dev/simdisk0";
  };

  cpus {
    #address-cells = <1>;
    #size-cells = <0>;
    cpu@0 {
      compatible = "cdns,xtensa-cpu";
      reg = <0>;
    };
  };

  pic: pic {
    compatible = "cdns,xtensa-pic";
    /* one cell: internal irq number,
     * two cells: second cell == 0: internal irq number
     *            second cell == 1: external irq number
     */
    #interrupt-cells = <2>;
    interrupt-controller;
  };
END_HEADER

  print xrp_dts $header;
  print xrp_dts "\n";

  # Offset from shared memory where the lua script polls for interrupts
  my $shared_mem_offset = "0x100";

  my $exit_loc = 0;
  if ($xrpDTS->{'shared_mem'}->{'host_shared'} == 1) {
    print xrp_dts "  sim-shmem {\n";
    print xrp_dts "    compatible = \"cdns,sim-shmem\";\n";
    print xrp_dts "    reg = <" . 
          sprintf("%s", $xrpDTS->{'shared_mem'}->{'globalAddr'}) . " "  .
          sprintf("0x%x", $xrpDTS->{'shared_mem'}->{'size'});
    foreach my $l2 (values %$subSystemL2s) {
      if ($l2->{'host_shared'}) {
        print xrp_dts sprintf("\n           %s", $l2->{'globalAddr'}) . " ";
        print xrp_dts sprintf("0x%x", $l2->{'isL2CC'} ? $l2->{'size'}/2 
                                                      : $l2->{'size'}); 
      }
    }
    foreach my $devMem (@DeviceMemories) {
      if ($devMem == $xrpDTS->{'shared_mem'} or !$devMem->{'host_shared'}) {
        next;
      }
      print xrp_dts sprintf("\n           %s", $devMem->{'globalAddr'}) . " ";
      print xrp_dts sprintf("0x%x", $devMem->{'size'}); 
    }
    print xrp_dts ">;\n";
    $exit_loc = sprintf("%u", hex($xrpDTS->{'shared_mem'}->{'globalAddr'})) +
                        hex($shared_mem_offset) + (scalar keys %$procIdMap)*4;
    print xrp_dts "    /* Start of shared mem " . 
                  $xrpDTS->{'shared_mem'}->{'globalAddr'} .
                  " + num procs(" . (scalar keys %$procIdMap) . ") * 4 */\n";
    print xrp_dts "    exit-loc = <" . sprintf("0x%x", $exit_loc) . ">;\n";
    print xrp_dts "    reg-names = \"" . 
                  $xrpDTS->{'shared_mem'}->{'host_name'} . 
                  ".%d\"";
    foreach my $l2 (values %$subSystemL2s) {
      if ($l2->{'host_shared'}) {
        print xrp_dts ", \"$l2->{'name'}.%d\"";
      }
    }
    foreach my $devMem (@DeviceMemories) {
      if ($devMem == $xrpDTS->{'shared_mem'} or !$devMem->{'host_shared'}) {
        next;
      }
      print xrp_dts ", \"" . $devMem->{'host_name'}.".%d\"";
    }
    print xrp_dts ";\n";
    print xrp_dts "  };\n\n";
  } 

  foreach my $pid (sort {$a<=>$b} (keys %$procIdMap)) {
    my $proc = $procIdMap->{$pid};
    if (defined $subSysHostProc and $proc == $subSysHostProc) {
      next;
    }
    my $num_procs = (scalar keys %$procNameMap) - ($subSysHostProc ? 1 : 0);
    print xrp_dts "  xvp@" . $pid . " {\n";
    print xrp_dts "    #address-cells = <1>;\n";
    print xrp_dts "    #size-cells = <1>;\n";
    print xrp_dts "    compatible = \"cdns,xrp-hw-simple\";\n";
    print xrp_dts 
          "    /* MMIO start, size; Comm area start, size; ".
          "Shared memory start, size */\n";
   print xrp_dts "    reg = <";
    if (defined $proc->{'mmio'} and 
        defined $proc->{'mmio'}->{'intrReg'}->{'xrpIntrOffset'}) {
      print xrp_dts sprintf("%s 0x%x\n",
          $proc->{'mmio'}->{'globalAddr'}, $proc->{'mmio'}->{'size'});
    } elsif (defined $proc->{'xrpSubSystemMMIO'}) {
      my $car = @{$proc->{'xrpSubSystemMMIO'}}[0];
      print xrp_dts sprintf("%s 0x%x\n", $car->{'globalAddr'}, 4);
    } else {
      print xrp_dts "0x0 0x0\n";
    }
    # Add comm area
    my $comm_size = 4*1024;
    print xrp_dts "           " .
                  sprintf("0x%x 0x%x\n",
                          hex($xrpDTS->{'shared_mem'}->{'globalAddr'}) + 
                          $pid*$comm_size, $comm_size);
    # Make size to be aligned to 4 bytes
    my $size = $xrpDTS->{'shared_mem'}->{'size'};
    $size = int(($size - 4)/4 + 1) * 4;
    print xrp_dts "           " .
                  sprintf("0x%x 0x%x>;\n", 
                          hex($xrpDTS->{'shared_mem'}->{'globalAddr'}) + 
                          $num_procs*$comm_size, $size-$num_procs*$comm_size);
    if (defined $proc->{'mmio'} and 
        defined $proc->{'mmio'}->{'intrReg'}->{'xrpIntrOffset'}) {
      my $bo = $proc->{'mmio'}->{'intrReg'}->{'xrpIntrOffset'};
      my $h = $proc->{'mmio'}->{'intrReg'}->{'pIntrMap'};
      my $h1 = $proc->{'mmio'}->{'intrReg'}->{'intrTypeMap'};
      print xrp_dts "    /* interrupt reg offset (offset from MMIO start), ".
                    "bit offset, proc interrupt */\n";
      print xrp_dts "    device-irq = <" . sprintf("0x%x %d %d>;\n", 
        (hex($proc->{'mmio'}->{'intrReg'}->{'globalAddr'}) - 
            hex($proc->{'mmio'}->{'globalAddr'})) & 0xffffffff, $bo, $h->{$bo});
      my $edge = "2 /* Edge */";
      if ($xrpDTS->{'shared_mem'}->{'host_shared'} == 1) {
        $edge = "3 /* SW Edge */";
      }
      print xrp_dts "    device-irq-mode = <" .
            (($h1->{$bo} eq 'Edge') ? $edge : "1 /* Level */") . 
            ">;\n";
      if ($xrpDTS->{'shared_mem'}->{'host_shared'} == 1) {
        print xrp_dts "    /* Offset from MMIO start (" . 
              $proc->{'mmio'}->{'globalAddr'} . ") to start of shared memory\n";
        print xrp_dts "     * (" . $xrpDTS->{'shared_mem'}->{'globalAddr'} . 
                      ") + $shared_mem_offset + " . ($pid*4) .
                    " */\n";
        print xrp_dts "    device-irq-host-offset = <" . 
              sprintf("0x%x>;\n", 
                      (hex($xrpDTS->{'shared_mem'}->{'globalAddr'}) + 0x100 + 
                      ($pid*4) -  hex($proc->{'mmio'}->{'globalAddr'})) &
                      0xffffffff);
      } else {
        print xrp_dts "    device-irq-host-offset = <0x0>;\n";
      }

      # Generate host interrupt info
      if (defined $subSysHostProc and defined $subSysHostProc->{'mmio'} and
          defined $subSysHostProc ->{'mmio'}->{'intrReg'}->{'xrpIntrOffset'}) {
        my $h_h1 = $subSysHostProc->{'mmio'}->{'intrReg'}->{'intrTypeMap'};
        my $h_bo = $subSysHostProc->{'mmio'}->{'intrReg'}->{'xrpIntrOffset'};
        print xrp_dts "    /* Offset from MMIO (" .
              $proc->{'mmio'}->{'globalAddr'}. ") to host MMIO (" .
              $subSysHostProc->{'mmio'}->{'intrReg'}->{'globalAddr'} .
              "), bit offset */\n";
        print xrp_dts "    host-irq = <" . sprintf("0x%x %d>;\n",
          hex($subSysHostProc->{'mmio'}->{'intrReg'}->{'globalAddr'}) -
          hex($proc->{'mmio'}->{'globalAddr'}), $h_bo);
        print xrp_dts "    host-irq-mode = <" .
              (($h_h1->{$h_bo} eq 'Edge') ? "2 /* Edge */" : "1 /* Level */") . 
              ">;\n";
      }
    } elsif (defined $proc->{'xrpSubSystemMMIO'}) {
      my $bo =  @{$proc->{'xrpSubSystemMMIO'}}[1];
      my $car = @{$proc->{'xrpSubSystemMMIO'}}[0];
      print xrp_dts "    /* interrupt reg offset (offset from MMIO start), ".
                    "bit offset, proc interrupt */\n";
      print xrp_dts "    device-irq = <" . sprintf("0x0 %d %d>;\n", 
                                             $bo, $car->{'bIntrMap'}->{$bo});
      my $edge = "2 /* Edge */";
      if ($xrpDTS->{'shared_mem'}->{'host_shared'} == 1) {
        $edge = "3 /* SW Edge */";
      }
      print xrp_dts "    device-irq-mode = <$edge>;\n";
      if ($xrpDTS->{'shared_mem'}->{'host_shared'} == 1) {
        print xrp_dts "    /* Offset from MMIO start (" . 
              $car->{'globalAddr'} . ") to start of shared memory\n";
        print xrp_dts "     * (" . $xrpDTS->{'shared_mem'}->{'globalAddr'} . 
                      ") + $shared_mem_offset + " . ($pid*4) .
                      " */\n";
        print xrp_dts "    device-irq-host-offset = <" . 
              sprintf("0x%x>;\n",
                      (hex($xrpDTS->{'shared_mem'}->{'globalAddr'}) + 0x100 + 
                      ($pid*4) -  hex($car->{'globalAddr'})) & 0xffffffff);
      } else {
        print xrp_dts "    device-irq-host-offset = <0x0>;\n";
      }

      # Generate priority queues
      if (defined $xrpDTS->{'queues'}) {
        if (!exists $xrpDTS->{'queues'}->{$proc->{'name'}}) {
          next;
        }
        print xrp_dts "    queue-priority = <" .
          join(" ", map($_, values $xrpDTS->{'queues'}->{$proc->{'name'}})) .
          ">;\n";
      }

      # Generate host interrupt info
      if (defined $subSysHostProc and 
          defined $subSysHostProc->{'xrpSubSystemMMIO'}) {
        my $host_bo =  @{$subSysHostProc->{'xrpSubSystemMMIO'}}[1];
        my $host_car = @{$subSysHostProc->{'xrpSubSystemMMIO'}}[0];
        print xrp_dts "    /* Offset from MMIO start (" .
              $car->{'globalAddr'}. ") to host MMIO (" .
              $host_car->{'globalAddr'} .  "), bit offset */\n";
        print xrp_dts "    host-irq = <" . sprintf("0x%x %d>;\n",
          hex($host_car->{'globalAddr'}) - hex($car->{'globalAddr'}), $host_bo);
        print xrp_dts "    host-irq-mode = <2 /* Edge */>;\n";
      }
    } else {
      print xrp_dts "    device-irq = <0 0 0>;\n" ;
      print xrp_dts "    device-irq-mode = <0 /* None */>;\n";
    }
    print xrp_dts "    ranges = <";
    print xrp_dts sprintf("0x%x 0x%x 0x%x", 
          hex($xrpDTS->{'shared_mem'}->{'globalAddr'}), 
          hex($xrpDTS->{'shared_mem'}->{'globalAddr'}), 
          $xrpDTS->{'shared_mem'}->{'size'});
    if (defined $proc->{'instRam0'}) {
      print xrp_dts "\n";
      print xrp_dts "              " . sprintf("0x%x 0x%x 0x%x",
            hex($proc->{'instRam0'}->{'localAddr'}), 
            (defined $proc->{'instRam0'}->{'globalAddr'}
              ? hex($proc->{'instRam0'}->{'globalAddr'})
              : "0"), 
            $proc->{'instRam0'}->{'size'});
    }
    if (defined $proc->{'dataRam0'}) {
      print xrp_dts "\n";
      print xrp_dts "              " . sprintf("0x%x 0x%x 0x%x",
            hex($proc->{'dataRam0'}->{'localAddr'}), 
            (defined $proc->{'dataRam0'}->{'globalAddr'}
              ? hex($proc->{'dataRam0'}->{'globalAddr'})
              : "0"), 
            $proc->{'dataRam0'}->{'size'});
    }
    if (defined $proc->{'dataRam1'}) {
      print xrp_dts "\n";
      print xrp_dts "              " . sprintf("0x%x 0x%x 0x%x",
            hex($proc->{'dataRam1'}->{'localAddr'}), 
            (defined $proc->{'dataRam1'}->{'globalAddr'}
              ? hex($proc->{'dataRam1'}->{'globalAddr'})
              : "0"), 
            $proc->{'dataRam1'}->{'size'});
    }
    foreach my $l2 (values %$subSystemL2s) {
      if ($l2->{'host_shared'}) {
        print xrp_dts "\n";
        print xrp_dts "              " . sprintf("0x%x 0x%x 0x%x",
                      hex($l2->{'globalAddr'}), hex($l2->{'globalAddr'}),
                      $l2->{'isL2CC'} ? $l2->{'size'}/2 : $l2->{'size'});
      }
    }
    foreach my $devMem (@DeviceMemories) {
      if ($devMem == $xrpDTS->{'shared_mem'} or !$devMem->{'host_shared'}) {
        next;
      }
      print xrp_dts "\n";
      print xrp_dts "              " . sprintf("0x%x 0x%x 0x%x",
                    hex($devMem->{'globalAddr'}), hex($devMem->{'globalAddr'}),
                    $devMem->{'size'});
    }
    print xrp_dts ">;\n";
    print xrp_dts "  };\n\n";
  }

  print xrp_dts "\n";
  print xrp_dts "};\n";

  close xrp_dts;

  # Generate the lua script to deal with interrupts

  # If there is a real host, don't need the proxy 
  if (defined $subSysHostProc) {
    return;
  }

  my $lua_scr = dirname($xrp_dts) . "/XRP_Controller.lua";

  open(lua_scr, ">$lua_scr") or sysBuildError("Could not open $lua_scr\n");

  print lua_scr "#define INTR_SHMEM " . 
                sprintf("0x%x\n", hex($xrpDTS->{'shared_mem'}->{'globalAddr'}) +
                                  hex($shared_mem_offset));
  print lua_scr "#define INTR_SHMEM_NAME \"" . 
                $xrpDTS->{'shared_mem'}->{'name'} . "\"\n";
  print lua_scr "#define DSP_INTR_OFFSET {" . 
                join(", ", map(sprintf("0x%x", $_*4), 
                               sort {$a<=>$b} (keys %$procIdMap))) . 
                "}\n";
  print lua_scr 
        "#define DSP_MMIO {" . 
        join(", ", 
          map(defined $procIdMap->{$_}->{'mmio'}->{'globalAddr'}
                ? $procIdMap->{$_}->{'mmio'}->{'globalAddr'}
                : (defined $procIdMap->{$_}->{'xrpSubSystemMMIO'}
                  ? @{$procIdMap->{$_}->{'xrpSubSystemMMIO'}}[0]->{'globalAddr'}
                  : "0x0"),
                    sort {$a<=>$b} (keys %$procIdMap))) . "}\n";
  print lua_scr "#define DSP_NAMES_STR {" . join(", ",
                map(sprintf("\"%s\"", $procIdMap->{$_}->{'name'}),
                    sort {$a<=>$b} (keys %$procIdMap))) . "}\n";
  print lua_scr "#define CMD_ADDR " . sprintf("0x%x\n", $exit_loc);
  print lua_scr "#define NUM_DSPS " . (keys %$procIdMap) . "\n";

  # Generate Rest/Runstall (only for procs with local mmio)
  print lua_scr "#define DSP_RESET {";
  foreach my $pid (sort {$a<=>$b} (keys %$procIdMap)) {
    my $proc = $procIdMap->{$pid};
    foreach my $c (@{$proc->{'mmio'}->{'controls'}}) {
      foreach my $reg (@{$c->{'subRegs'}}) {
        if ($reg->{'name'} eq 'BReset') {
          print lua_scr $c->{'globalAddr'} . ", ";
        }
      }
    }
  }
  print lua_scr "}\n";

  print lua_scr "#define DSP_RESET_MASK {";
  foreach my $pid (sort {$a<=>$b} (keys %$procIdMap)) {
    my $proc = $procIdMap->{$pid};
    foreach my $c (@{$proc->{'mmio'}->{'controls'}}) {
      foreach my $reg (@{$c->{'subRegs'}}) {
        if ($reg->{'name'} eq 'BReset') {
          print lua_scr "0x01 0x00 0x00 0x00, ";
        }
      }
    }
  }
  print lua_scr "}\n";

  print lua_scr "#define DSP_RUNSTALL {";
  foreach my $pid (sort {$a<=>$b} (keys %$procIdMap)) {
    my $proc = $procIdMap->{$pid};
    foreach my $c (@{$proc->{'mmio'}->{'controls'}}) {
      foreach my $reg (@{$c->{'subRegs'}}) {
        if ($reg->{'name'} eq 'RunStall') {
          print lua_scr $c->{'globalAddr'} . ", ";
        }
      }
    }
  }
  print lua_scr "}\n";

  print lua_scr "#define DSP_RUNSTALL_MASK {";
  foreach my $pid (sort {$a<=>$b} (keys %$procIdMap)) {
    my $proc = $procIdMap->{$pid};
    foreach my $c (@{$proc->{'mmio'}->{'controls'}}) {
      foreach my $reg (@{$c->{'subRegs'}}) {
        if ($reg->{'name'} eq 'RunStall') {
          print lua_scr "0x01 0x00 0x00 0x00, ";
        }
      }
    }
  }
  print lua_scr "}\n";

  my @dsp_intr_mask = ();
  my @dsp_intr_type = ();
  foreach my $pid (sort {$a<=>$b} (keys %$procIdMap)) {
    my $proc = $procIdMap->{$pid};
    if ((!defined $proc->{'mmio'}->{'globalAddr'} or
         !defined $proc->{'mmio'}->{'intrReg'}->{'xrpIntrOffset'}) and
        !defined $proc->{'xrpSubSystemMMIO'}) {
      push @dsp_intr_mask, "0xff 0xff 0xff 0xff";
      push @dsp_intr_type, "None";
      next;
    }

    my $bo;
    my $intrType;
    if (defined $proc->{'mmio'}->{'globalAddr'} or
        defined $proc->{'mmio'}->{'intrReg'}->{'xrpIntrOffset'}) {
      $bo = $proc->{'mmio'}->{'intrReg'}->{'xrpIntrOffset'};
      my $h1 = $proc->{'mmio'}->{'intrReg'}->{'intrTypeMap'};
      $intrType = $h1->{$bo};
    } elsif (defined $proc->{'xrpSubSystemMMIO'}) {
      my $car = @{$proc->{'xrpSubSystemMMIO'}}[0];
      $bo = @{$proc->{'xrpSubSystemMMIO'}}[1];
      $intrType = 'Edge';
    } 
    my $intr_mask = 1 << $bo;
    my $intr_mask_str;
    if ($intr_mask <= 0x4) {
      $intr_mask_str = sprintf("0x0%x 0x00 0x00 0x00", $intr_mask);
    } 
    push @dsp_intr_mask, $intr_mask_str;
    push @dsp_intr_type, $intrType;
  }

  print lua_scr "#define DSP_INTERRUPT_MASK {"  . 
                 join(", ", map("\"" . $_ . "\"", @dsp_intr_mask)) . "}\n";
  print lua_scr "#define DSP_INTERRUPT_TYPE {"  . 
                 join(", ", map("\"" . $_ . "\"", @dsp_intr_type)) . "}\n";

  print lua_scr "\n";
  print lua_scr "#lua_beg\n\n";
  print lua_scr "  WAIT_ARG = tonumber(xtsc.user_state_get(\"".
                "PROXY_POLL_INTERVAL\"))\n\n";
  print lua_scr "  function get_int_value(addr)\n";
  print lua_scr "    local str = xtsc.cmd(\$(INTR_SHMEM_NAME) .. \" peek \" .. addr .. \" 4\")\n";
  print lua_scr "    local val = tonumber(string.sub(str, 16, 19) ..\n";
  print lua_scr "                         string.sub(str, 13, 14) ..\n";
  print lua_scr "                         string.sub(str, 8, 9) ..\n";
  print lua_scr "                         string.sub(str, 3, 4))\n";
  print lua_scr "    return val\n";
  print lua_scr "  end\n\n";

  print lua_scr "  DSP_INTR_OFFS  = \$(DSP_INTR_OFFSET)\n";
  print lua_scr "  DSP_MMIO_ADDRS = \$(DSP_MMIO)\n";
  print lua_scr "  DSP_INTR_MASK = \$(DSP_INTERRUPT_MASK)\n";
  print lua_scr "  DSP_INTR_TYPE = \$(DSP_INTERRUPT_TYPE)\n";
  print lua_scr "  DSP_NAMES = \$(DSP_NAMES_STR)\n";
  print lua_scr "  DSP_RUNSTALL_ADDRS = \$(DSP_RUNSTALL)\n";
  print lua_scr "  DSP_RESET = \$(DSP_RESET)\n";
  print lua_scr "  while true do\n";
  print lua_scr "    xtsc.cmd(\"sc wait \" .. WAIT_ARG)\n";
  print lua_scr "    for c = 1, \$(NUM_DSPS) do\n";
  print lua_scr "      intr_type = DSP_INTR_TYPE[c]\n";
  print lua_scr "      if (intr_type ~= \"None\") then\n";
  print lua_scr "        intr_off = \$(INTR_SHMEM) + DSP_INTR_OFFS[c]\n";
  print lua_scr "        intr = xtsc.cmd(\$(INTR_SHMEM_NAME) .. \" peek \" .. intr_off .. \" 4\")\n";
  print lua_scr "        mmio = DSP_MMIO_ADDRS[c]\n";
  print lua_scr "        intr_mask = DSP_INTR_MASK[c]\n";
  print lua_scr "        if (intr == intr_mask) then\n";
  print lua_scr "          -- Send interrupt and clear intr\n";
  print lua_scr "          if (intr_type == \"Edge\") then\n";
  print lua_scr "            xtsc.write(\"now poke \" .. mmio     .. \" 4 0x00 0x00 0x00 0x00\")\n";
  print lua_scr "          end\n";
  print lua_scr "          xtsc.write(\"now poke \" .. mmio     .. \" 4 \" .. intr_mask)\n";
  print lua_scr "          xtsc.cmd(\$(INTR_SHMEM_NAME) .. \" poke \" .. intr_off .. \" 4 0x00 0x00 0x00 0x00\")\n";
  print lua_scr "        end\n";
  print lua_scr "      end\n";
  print lua_scr "    end\n";
  print lua_scr "    exit = xtsc.cmd(\$(INTR_SHMEM_NAME) .. \" peek \" .. \$(CMD_ADDR) .. \" 4\")\n";
  print lua_scr "    if (exit == \"0xff 0x00 0x00 0x00\") then\n";
  print lua_scr "      xtsc.write(\"now poke \" .. \$(CMD_ADDR) .. \" 4 0x00 0x00 0x00 0x00\")\n";
  print lua_scr "      xtsc.cmd(\"sc sc_stop\")\n";
  print lua_scr "    end\n";
  print lua_scr "  end\n";
  print lua_scr "#lua_end\n";

  close lua_scr;
}

# Routine to read in the xtensa params file and populate a table of
# ProcParams. Can be used to infer processor fields instead of explicitly
# listing them in the YAML spec
sub createProcXtensaParams {
  my $config = shift;

  my $xtensaCoreParams = File::Spec->catfile($xtensaSystem, $config."-params");
  open(xtensaParamsFile, $xtensaCoreParams) or 
    die "Could not open params file $xtensaCoreParams : $\n";

  if (exists $procParamsNameMap->{$config}) {
    return $procParamsNameMap->{$config};
  }

  my $proc = new ProcParams;
  $proc->{'config'} = $config;
  $proc->{'NX'} = 0;
  $procParamsNameMap->{$config} = $proc;

  while(<xtensaParamsFile>) {
    $proc->{'DataMasterWidth'} = ($4/8)
        if ( /^DataMasterInterface\s+=\s+\[\s+(\w+)\s+(\d+)\s+(\d+)\s+(\d+)/ );
    $proc->{'InstMasterWidth'} = ($4/8)
        if ( /^InstMasterInterface\s+=\s+\[\s+(\w+)\s+(\d+)\s+(\d+)\s+(\d+)/ );
    $proc->{'DataSlaveWidth'} = ($4/8)
        if ( /^DataSlaveInterface\s+=\s+\[\s+(\w+)\s+(\d+)\s+(\d+)\s+(\d+)/ );
    $proc->{'iDMAWidth'} = ($4/8)
        if ( /^IDMAInterface\s+=\s+\[\s+(\w+)\s+(\d+)\s+(\d+)\s+(\d+)/ );
    $proc->{'NX'} = 1 if ( /^TargetHWVersion = NX/ );
    $proc->{'APBMaster'} = $2 
        if ( /^APBMasterInterface\s+=\s+\[\s+(\w+)\s+(\d+)\s+(\d+)\s+(\d+)/ );
  }
  close(xtensaParamsFile);

  return $proc;
}

# Routine to verify version info
sub verifyVersion {
  my $subSys = shift;
  if (!defined $subSys->{'Metadata'}) {
    return;
  }

  ref($subSys->{'Metadata'}) eq 'HASH' or 
    die "Error: Metadata specification needs to be a map\n";

  if (defined $subSys->{'Metadata'}->{'Version'}) {
    $specVersion = $subSys->{'Metadata'}->{'Version'};
    ($specVersion =~ /^\d+$/) or  die "Expected Version to be a number\n";
  }

  my @idxs = grep { $_ eq $specVersion } @supportedVesions;
  scalar @idxs or 
    die "Error: Unsupported version $specVersion. Supported versions are ". 
        join(", ", map("$_", @supportedVesions))."\n";
}

# Main routine to read in the PERL representation of the YAML specification,
# verify and build internal structures to represent the same
sub processSubSys {
  my $subSys = shift;

  pushCurrentLogLevel($logDebugLevel1);

  printLog($logDebugLevel2, "In processSubSys()\n");

  # Check if the components are supported
  foreach my $subSysComp (keys %$subSys) {
    my @idxs = grep { $_ eq $subSysComp } @knownSubsysComponents;
    scalar @idxs or die "Error: Unknown component $subSysComp\n";
  }
  
  # Set subSystemName
  defined $subSys->{'SubSystemName'} or 
    die "Error: SubSystemName undefined\n";

  ($subSys->{'SubSystemName'} =~ /^[a-zA-Z][a-zA-Z0-9_]+$/) or 
    die "Error: Subsystem name has to be a alpha numerical ".
        "(underscores allowed) beginning with a letter \n";

  $subSystemName = $subSys->{'SubSystemName'} ;

  printLog($logDebugLevel2, "  Processing subsystem $subSystemName\n");

  verifyVersion($subSys);

  # Read the Processors definition
  my $procs = $subSys->{'Processors'};
  defined $procs or die "Error: Processors undefined\n";
  ref($procs) eq 'ARRAY' or 
    die "Error : Subsystem $subSystemName needs to have an array ".
        "of one or more processors defined\n";

  printLog($logDebugLevel2, "  Start 'Processors' section\n");

  my $on_axi = 0;

  # Verify and process each processor description
  foreach my $proc (@$procs) {
    ref($proc) eq 'HASH' or 
      die "Error: Processor specification has to be a map\n";

    if ($inferConfigParams) {
      my $pr = createProcXtensaParams($proc->{'Config'});
    }

    verifyProc($proc);

    my $procDef = createProc($proc->{'Name'}, 
                             $proc->{'Config'}, 
                             $proc->{'Pipeline'}, 
                             $proc->{'AXI'}, 
                             $proc->{'ProcId'},
                             $proc->{'PRID'},
                             $proc->{'Master'},
                             $proc->{'Host'},
                             $proc->{'XNNECtrl'},
                             $proc->{'StaticVectorSel'},
                             $proc->{'AltResetVecAddr'});

    if (defined $proc->{'DataRamFetchWidth'}) {
      $procDef->{'dataRamFetchWidth'} = 
                                    computeSize($proc->{'DataRamFetchWidth'});
    }
    if (defined $proc->{'InstRamFetchWidth'}) {
      $procDef->{'instRamFetchWidth'} = 
                                    computeSize($proc->{'InstRamFetchWidth'});
    }

    if (defined $proc->{'SDMA'}) {
      my $sdma = createSDMA($proc);
      $procDef->{'sdma'} = $sdma;
    }

    if (defined $proc->{'IDMA'}) {
      my $idma = createIDMA($proc);
      $procDef->{'idma'} = $idma;
    }

    validateDMA($procDef);

    if ($procDef->{'pipeline'} eq 'NX') {
      if (defined $proc->{'MasterWidth'}) {
        $procDef->{'masterWidth'} = computeSize($proc->{'MasterWidth'});
        $procDef->{'mergedMasterWidth'} = computeSize($proc->{'MasterWidth'});
      } else {
        my $masterDataWidth = computeSize($proc->{'MasterDataWidth'});
        my $masterInstWidth = computeSize($proc->{'MasterInstWidth'});
        $procDef->{'masterDataWidth'} = $masterDataWidth;
        $procDef->{'masterInstWidth'} = $masterInstWidth;
        # 'masterWidth' is max of data/instr master widths
        $procDef->{'masterWidth'} = $masterDataWidth > $masterInstWidth
                                    ? $masterDataWidth : $masterInstWidth;
      }

      if (defined $procDef->{'idma'} && 
          defined $procDef->{'idma'}->{'width'}) {
        $procDef->{'dmaWidth'} = $procDef->{'idma'}->{'width'};
      } elsif (defined $procDef->{'sdma'} and 
               defined $procDef->{'sdma'}->{'width'}) {
        $procDef->{'dmaWidth'} = $procDef->{'sdma'}->{'width'};
      } else {
        $procDef->{'dmaWidth'} = defined $proc->{'MasterWidth'}
                                  ? $procDef->{'masterWidth'}
                                  : $procDef->{'masterDataWidth'};
      }

      if (defined $proc->{'SlaveWidth'}) {
        $procDef->{'slaveWidth'} = computeSize($proc->{'SlaveWidth'});
      } else {
        my $slaveDataWidth = 0;
        my $slaveInstWidth = 0;
        if (defined $proc->{'SlaveDataWidth'}) {
          $slaveDataWidth = computeSize($proc->{'SlaveDataWidth'});
          $procDef->{'slaveDataWidth'} = $slaveDataWidth;
        } 
        if (defined $proc->{'SlaveInstWidth'}) {
          $slaveInstWidth = computeSize($proc->{'SlaveInstWidth'});
          $procDef->{'slaveInstWidth'} = $slaveInstWidth;
        }
        $procDef->{'slaveWidth'} = $slaveDataWidth > $slaveInstWidth
                                    ? $slaveDataWidth : $slaveInstWidth;
      }
    } else {
      $procDef->{'pifWidth'} = computeSize($proc->{'PifWidth'});
      if (defined $procDef->{'idma'} and
          defined $procDef->{'idma'}->{'width'}) {
        $procDef->{'dmaWidth'} = $procDef->{'idma'}->{'width'};
      } elsif (defined $procDef->{'sdma'} and 
               defined $procDef->{'sdma'}->{'width'}) {
        $procDef->{'dmaWidth'} = $proc->{'sdma'}->{'width'};
      } else {
        $procDef->{'dmaWidth'} = $procDef->{'pifWidth'};
      }
    }

    if (defined $proc->{'InstRam0'}) {
      my $instRam0 = createLocalMem($proc->{'InstRam0'}, $procDef);
      $procDef->{'instRam0'} = $instRam0;
    }

    if (defined $proc->{'InstRam1'}) {
      my $instRam1 = createLocalMem($proc->{'InstRam1'}, $procDef);
      $procDef->{'instRam1'} = $instRam1;
    }

    if (defined $proc->{'DataRam0'}) {
      my $dataRam0 = createLocalMem($proc->{'DataRam0'}, $procDef);
      $procDef->{'dataRam0'} = $dataRam0;
    }

    if (defined $proc->{'DataRam1'}) {
      my $dataRam1 = createLocalMem($proc->{'DataRam1'}, $procDef);
      $procDef->{'dataRam1'} = $dataRam1;
    }

    if (defined $proc->{'UDMA'}) {
      my $udma = createUDMA($proc->{'UDMA'});
      $procDef->{'udma'} = $udma;
    }

    # Adjust the masterWidth if DMA is shared
    if ((defined $procDef->{'idma'} and $procDef->{'idma'}->{'shared'}) &&
        $procDef->{'pipeline'} eq 'NX') {
      $procDef->{'masterWidth'} = 
        $procDef->{'dmaWidth'} > $procDef->{'masterWidth'} 
          ? $procDef->{'dmaWidth'} : $procDef->{'masterWidth'};
    }

    if (defined $proc->{'LocalMMIO'}) {
      my $local_mmio = createMMIO($proc->{'LocalMMIO'});
      $procDef->{'mmio'} = $local_mmio;
    }

    if (defined $proc->{'Dcache'}) {
      my $dcache = createCache($proc->{'Dcache'});
      $procDef->{'dcache'} = $dcache;
    }

    if (defined $proc->{'BigEndian'}) {
      $procDef->{'isBigEndian'} = 1;
    } else {
      $procDef->{'isBigEndian'} = 0;
    }

    if (defined $proc->{'MasterDataInstMerged'}) {
      $procDef->{'masterDataInstMerged'} = 1;
    } else {
      $procDef->{'masterDataInstMerged'} = 0;
    }

    if (defined $proc->{'SlaveDataInstMerged'}) {
      $procDef->{'slaveDataInstMerged'} = 1;
    } else {
      $procDef->{'slaveDataInstMerged'} = 0;
    }

    if (defined $proc->{'SharedLocalMemClusterId'}) {
      $procDef->{'sharedLmemCid'} = $proc->{'SharedLocalMemClusterId'};
      push @{$sharedLocalMemClusterMap->{$proc->{'SharedLocalMemClusterId'}}}, 
           $procDef;
    }

    # If any proc on axi, the bus is axi;
    if ($procDef->{'axi'}) {
      $on_axi = 1;
    }

    if (defined $proc->{'APBMaster'}) {
      $procDef->{'apbMaster'} = 1;
    } else {
      $procDef->{'apbMaster'} = 0;
    }
  }
  printLog($logDebugLevel2, "  Done 'Processors' section\n");

  defined $subSysMasterProc or die "Master proc not defined\n";

  # Read the XNNE definition
  if (defined $subSys->{'XNNE'}) {
    my $xnnes = $subSys->{'XNNE'};
    ref($xnnes) eq 'ARRAY' or 
      die "Error : Subsystem $subSystemName XNNE has to an array\n";

    # Map to find unique proc to interface
    my $procToIntfMap = {};

    foreach my $xnne (@$xnnes) {
      ref($xnne) eq 'HASH' or 
        die "Error: XNNE specification has to be a map\n";

      my $xnne = createXNNE($xnne, $procToIntfMap);
    }

    # XNNEs are always on AXI
    $on_axi = 1;
  }

  # If bus is axi all processors are on AXI including any LX ones
  if ($on_axi) {
    foreach my $proc (values %$procNameMap) {
      $proc->{'axi'} = 1;
    }
  }

  printLog($logDebugLevel2, "Printing global address ranges...\n");
  printLog($logDebugLevel2, 
           join(", ", map("{".$_->{'startAddr'}.",".$_->{'size'}."}", 
                          @sortedAddrRanges))."\n");

  # ProcIds should be in the range from 0..(number of processors - 1)
  my $i = 0;
  foreach my $pid (sort {$a<=>$b} (keys %$procIdMap)) {
    if ($pid != $i) {
      sysBuildError("All processor ids are expected to be in the 0..".
                    (scalar(keys %$procIdMap)-1)."\n");
    }
    $i++;
  }

  if (defined $subSysHostProc) {
    $subSysHostProc->{'id'} == ((scalar keys %$procIdMap) - 1) or
      die "Host proc $subSysHostProc->{'name'} has to be last" .
          " proc id of " . ((scalar keys %$procIdMap) - 1);
  }
   

  # All procs should be either little or big endian.
  # If not specified, they are all assumed to be little endian
  # Similarly, all procs should be LX or NX.
  foreach my $proc (values %$procNameMap) {
    $proc->{'isBigEndian'} == $subSysMasterProc->{'isBigEndian'} or
      die "Endianess of $proc->{'name'} and ".
          "$subSysMasterProc->{'name'} differ\n";
    #$proc->{'pipeline'} eq $subSysMasterProc->{'pipeline'} or
    #  die "Pipeline of $proc->{'name'} and ".
    #      "$subSysMasterProc->{'name'} differ\n";
  }
 
  # Master proc should always be defined
  defined $subSysMasterProc or die "Error: Master proc undefined\n";

  # Process SystemRAM/SystemROM/DeviceMemories
  printLog($logDebugLevel2, 
           "  Start 'SystemRam/SystemROM/DeviceMemories' section\n");

  defined $subSys->{'SystemRAM'} or die "SystemRAM not defined\n";
    
  $systemRAM = new SystemMem;
  processSystemMemory($subSys->{'SystemRAM'}, 'SystemRAM', $systemRAM);

  $systemROM = new SystemMem;
  if (defined $subSys->{'SystemROM'}) {
    processSystemMemory($subSys->{'SystemROM'}, 'SystemROM', $systemROM);
  }

  if (defined $subSys->{'DeviceMemories'}) {
    my $devMems = $subSys->{'DeviceMemories'};
    ref($devMems) eq 'ARRAY' or 
      die "Error : Subsystem $subSystemName ".
          "device memories definitions needs to be an array\n";
    foreach my $devMem (@$devMems) {
      ref($devMem) eq 'HASH' or 
        die "Error: Device memory specification has to be a map\n";
      my $devMemDef = new SystemMem;

      # Special handling for __DefaultMem__
      if ($devMem->{'Name'} eq '__DefaultMem__') {
        $devMemDef->{'name'} = $devMem->{'Name'};
        # Create a default mem at offset 0 and size 4Gb
        $devMemDef->{'size'} = 4*1024*1024*1024 ;
        $devMemDef->{'globalAddr'} = 0;
        $devMemDef->{'read_delay'} = 1;
        $devMemDef->{'write_delay'} = 1;
        $devMemDef->{'read_repeat'} = 1;
        $devMemDef->{'write_repeat'} = 1;
        $devMemDef->{'write_response'} = 1;
        $devMemDef->{'request_fifo_depth'} = 2;
        $devMemDef->{'host_shared'} = 0;
        push @DeviceMemories, $devMemDef;
        next;
      }

      defined $devMem->{'Name'} or die "Error: Device memory name undefined\n";

      ($devMem->{'Name'} =~ /^[a-zA-Z][a-zA-Z0-9_]+$/) or 
        die "Error: Device memory name has to be a alpha numerical ".
            "(underscores allowed) beginning with a letter \n";
      foreach my $dm (@DeviceMemories) {
        ($dm->{'name'} ne $devMem->{'Name'}) or
          die "Duplicate definition of device memory $devMem->{'Name'}\n";
      }
      processSystemMemory($devMem, $devMem->{'Name'}, $devMemDef);
      push @DeviceMemories, $devMemDef;
    }
  }

  printLog($logDebugLevel2, 
           "  Done 'SystemRam/SystemROM/DeviceMemories' section\n");

  if (defined $subSys->{'CommonBusWidth'}) {
    $subSysBusWidth = computeSize($subSys->{'CommonBusWidth'});
  } else {
    # Compute the common bus width which is the max width across all procs.
    foreach my $proc (values %$procNameMap) {
      my $width;
      if ($proc->{'pipeline'} eq 'NX') {
        # Max of master, slave, idma, and xnne
        if (defined $proc->{'slaveWidth'}) {
          $width = $proc->{'slaveWidth'} > $proc->{'masterWidth'} 
                     ? $proc->{'slaveWidth'} 
                     : $proc->{'masterWidth'};
        } else {
          $width = $proc->{'masterWidth'};
        }
        $width = (defined $proc->{'dmaWidth'} and 
                  ($proc->{'dmaWidth'} > $width)) ? $proc->{'dmaWidth'} 
                                                  : $width;
      } else {
        # Max of pif, idma, and xnne
        $width = (defined $proc->{'dmaWidth'} and 
                  ($proc->{'dmaWidth'} > $proc->{'pifWidth'})) 
                    ? $proc->{'dmaWidth'} : $proc->{'pifWidth'};
      }
      $subSysBusWidth = $width > $subSysBusWidth ? $width : $subSysBusWidth;
    }
    # Use the XNNE master widths also in computing the common bus width
    foreach my $xnne (values %$xnneIdMap) {
      foreach my $mw (@{$xnne->{'masterWidths'}}) {
        $subSysBusWidth = $mw > $subSysBusWidth ? $mw : $subSysBusWidth;
      }
    }
  }

  processL2s($subSys);

  processSubSystemMMIOs($subSys);

  processSubSystemIOs($subSys);

  processSystemDMA($subSys);

  processInterconnect($subSys);

  processSubSystemInterface($subSys);

  processSystemSoftware($subSys);

  printLog($logDebugLevel2, "Leaving processSubSys()\n");

  printProcParams();

  printSubSystem();

  popCurrentLogLevel;
}

my %options = (
  # Prints usage
  "help"      => \$help,

   # YAML file describing the subsystem
  "subsys=s"  => \$subSysFile,

  # Dir containing s/w tools (XtensaTools or swtools-*)
  "swtools=s" => \$swtools, 

  # Directory where the xtsc-run, include, and the system hal directories
  # are to be generated. Defaults to current working directory.
  "build=s"   => \$buildDir,

  # Registry for subsystem cores
  "xtensa-system=s" => \$xtensaSystem,

  # Interal use only. Pointer to the Xtensa source in perforce
  "cvsroot=s" => \$cvsRoot,

  # Infer from config params
  "infer"     => \$inferConfigParams
);

# Start of main processing

# Option processing
$thisScript = $0;
GetOptions(%options);

if (defined $help) {
  usage();
  exit -1;
}

if (!defined $subSysFile) {
  print "Error: Subsystem definition file not defined\n";
  usage();
  exit -1;
}

if (!defined $swtools) {
  print "Error: swtools path not defined\n";
  usage();
  exit -1;
}

# Assume current dir if buildDir not specified
if (!defined $buildDir) {
  $buildDir = ".";
}

# Assume $swtools/config for xtensaSystem if xtensa-system not specified
if (!defined $xtensaSystem) {
  $xtensaSystem = File::Spec->catdir($swtools, "config");
}

# Read the subsystem specification YAML file
open my $fh, '<', $subSysFile or die "Cannot open config file $subSysFile: $!";

# Convert YAML file to PERL hash ref
my $subSys = LoadFile($fh);

# Dump the subsys 
# print Dumper($subSys), "\n";

processSubSys($subSys);

generateXTSCrun("$buildDir/xtsc-run");

generateSimCntrlLua("$buildDir/xtsc-run");

generateSysHeaderFile("$buildDir/include/xtensa/system");

if (defined $subSystemSoftware->{'xipcSharedDataBuffer'}) {
  if (-d "$buildDir/xipc_sys") {
    rmtree("$buildDir/xipc_sys");
    $? == 0 or sysBuildError("Cannot delete $buildDir/xipc_sys\n");
  }
  mkpath("$buildDir/xipc_sys");
  $? == 0 || die sysBuildError("Cannot create $buildDir/xipc_sys\n");

  # Generate and build libxipc_sys.a for each core
  foreach my $proc (values %$procNameMap) {
    if (defined $subSystemSoftware->{'xipcProcs'}) {
      if (! grep { $_ eq $proc->{'id'} } 
            @{$subSystemSoftware->{'xipcProcs'}}) {
        next;
      }
    }
    generateXIPCSysLib("$buildDir/xipc_sys", $proc);
    compileSysLib("$buildDir/xipc_sys", $proc->{'config'}, 
                  "xipc_sys.$proc->{'name'}");
  }
}

# Generate XRP DTS spec
generateXRPDeviceTreeSpec("$buildDir/xrp");
